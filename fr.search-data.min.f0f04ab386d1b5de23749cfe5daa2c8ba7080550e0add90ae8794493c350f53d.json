[{"id":0,"href":"/orientee_donnees/docs/modules/a_module_json/","title":"Module JSON","section":"Modules","content":" Module JSON # Ce module explore le format JSON (JavaScript Object Notation) et ses applications pratiques. Il couvre les bases de la syntaxe JavaScript et JSON, les types de données supportés, et les bonnes pratiques pour l\u0026rsquo;échange de données structurées. Le module inclut également GeoJSON pour la représentation de données géographiques, la bibliothèque Gson pour le traitement JSON en Java, l\u0026rsquo;outil en ligne de commande jq pour la manipulation de fichiers JSON, les concepts d\u0026rsquo;encodage Unicode (UTF-8 et UTF-16), ainsi qu\u0026rsquo;une introduction au format Markdown avec un laboratoire interactif.\nUn problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l\u0026rsquo;amélioration du cours.\n"},{"id":1,"href":"/orientee_donnees/docs/modules/b_module_xml/valid/definition_de_type_de_document/","title":"Définition de type de document","section":"Validation","content":" Définition de type de document # Document XML valide # Nous avons vu ce qu\u0026rsquo;était un document XML bien formé : un seul élément-racine, les éléments ne se chevauchent pas, les noms XML ne commencent pas par un chiffre, et ainsi de suite. De plus, un document XML bien formé peut contenir n\u0026rsquo;importe quel élément et dans n\u0026rsquo;importe quel ordre, et tous les éléments peuvent contenir des attributs, et peu importe ceux-ci.\nEn pratique, il est souvent suffisant pour les documents XML d\u0026rsquo;être bien formés, mais il arrive qu\u0026rsquo;on veuille imposer des contraintes supplémentaires aux éléments et attributs pouvant être utilisés. Par exemple, un élément « étudiant » pourrait posséder un numéro d\u0026rsquo;étudiant, mais pas l\u0026rsquo;inverse : un élément « numéro d\u0026rsquo;étudiant » ne pouvant contenir qu\u0026rsquo;un numéro et pas d\u0026rsquo;autres éléments. On peut aussi vouloir contraindre le contenu d\u0026rsquo;un document XML pour des raisons d\u0026rsquo;interopérabilité. Par exemple, si un groupe d\u0026rsquo;experts s\u0026rsquo;entendent sur un format XML pour un type de données, il est utile de pouvoir vérifier si un fichier XML donné correspond bien à ce sur quoi on s\u0026rsquo;est entendu. Un document XML qui est bien formé et qui respecte les contraintes définissant son type de document est dit valide (ou parfois valable).\nEn d\u0026rsquo;autres mots, un document XML qui est bien formé et qui, en plus, satisfait aux contraintes dictant quels éléments et attributs peuvent être utilisés, et dans quel ordre et avec quel contenu, est dit valide.\nNormes de définition de type de document # Il y a plusieurs façons de définir des types de documents XML. L\u0026rsquo;approche la plus répandue, la plus ancienne et la plus simple, est la norme de définition de type de document (DTD). Les deux autres possibilités émergentes les plus répandues sont XML Schema et Relax NG.\nOn fait généralement deux reproches à l\u0026rsquo;approche DTD : un document DTD n\u0026rsquo;est pas du XML et la norme n\u0026rsquo;est pas assez riche pour spécifier le contenu des documents XML avec finesse. En effet, L\u0026rsquo;approche DTD ne permet pas de déclarer qu\u0026rsquo;un contenu textuel doit être une date ou un nombre, et il n\u0026rsquo;y a pas de support pour les espaces de noms, sujet que nous traiterons plus loin dans ce module.\nD\u0026rsquo;un autre côté, la norme DTD est très répandue et tous les logiciels qui supportent XML supportent maintenant cette norme, incluant Java, Google Chrome et Firefox. Les formats comme XHTML 2.0 sont toujours publiés avec une spécification DTD. Les autres possibilités, comme XML Schema, Relax NG, Schematron et Examplotron, sont moins bien supportées.\nLa norme XML Schema permet de définir avec une grande finesse des types de données comme une date ou un code de langue (« fr », « en »). Cette norme est très utile si on veut spécifier avec beaucoup de détail le format de nos documents XML. Comme vous pouvez le constater dans l\u0026rsquo;exemple suivant, la norme XML Schema permet non seulement de spécifier le nom des éléments et des attributs (« shipTo », « billTo », « comment », « items », « orderDate »), mais aussi leur type (« xsd:string », « xsd:decimal », « xsd:date »).\n\u0026lt;xs:complexType name=\u0026#34;PurchaseOrderType\u0026#34;\u0026gt; \u0026lt;xs:sequence\u0026gt; \u0026lt;xs:element name=\u0026#34;shipTo\u0026#34; type=\u0026#34;USAddress\u0026#34;/\u0026gt; \u0026lt;xs:element name=\u0026#34;billTo\u0026#34; type=\u0026#34;USAddress\u0026#34;/\u0026gt; \u0026lt;xs:element ref=\u0026#34;comment\u0026#34; minOccurs=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;xs:element name=\u0026#34;items\u0026#34; type=\u0026#34;Items\u0026#34;/\u0026gt; \u0026lt;/xs:sequence\u0026gt; \u0026lt;xs:attribute name=\u0026#34;orderDate\u0026#34; type=\u0026#34;xs:date\u0026#34;/\u0026gt; \u0026lt;/xs:complexType\u0026gt; La norme XML Schema est supportée en Java depuis la version 1.5. Il n\u0026rsquo;est pas nécessaire d\u0026rsquo;utiliser une librairie spécialisée. Elle est cependant sujette à des critiques sévères de la part des experts en XML tels que Tim Bray (co-inventeur du XML) qui écrivait en novembre 2006 sur son blogue :\nEverybody who actually touches the technology has known the truth for years, and it\u0026rsquo;s time to stop sweeping it under the rug. W3C XML Schemas (XSD) suck. They are hard to read, hard to write, hard to understand, have interoperability problems, and are unable to describe lots of things you want to do all the time in XML. Schemas based on Relax NG, also known as ISO Standard 19757, are easy to write, easy to read, are backed by a rigorous formalism for interoperability, and can describe immensely more different XML constructs.\nEn somme, XML Schema est trop difficile à utiliser et à comprendre. Tim Bray, ainsi que de nombreux autres experts, préconisent plutôt l\u0026rsquo;utilisation de Relax NG. Cette norme, comme XML Schema, possède plusieurs avantages sur la norme DTD : elle permet de spécifier des types de données (comme une date ou un nombre), supporte les espaces de noms, etc. De plus, la norme Relax NG est plus élégante techniquement et parfois plus simple que la norme XML Schema. Des formats importants comme l\u0026rsquo;Open Document Format, DocBook (format XML), TEI, XHTML et Atom sont définis par RelaxNG plutôt que par XML Schema. (Une définition XML Schema sera sans doute produite pour le format XHTML 2.0.) Relax NG dispose aussi d\u0026rsquo;une syntaxe « compacte », qui n\u0026rsquo;est pas en XML contrairement au format par défaut de Relax NG, et que nous allons utiliser dans nos exemples. Voici un exemple de Relax NG :\nelement addressBook { element card { element name { text } element email { text } }* } Cet exemple spécifie que le document XML doit avoir comme élément racine un élément « addressBook », contenant zéro ou plus éléments « card ». Un élément « card » doit obligatoirement contenir un élément « name » suivi d\u0026rsquo;un élément « email ».\nTout en étant plus élégante que la norme DTD, le format Relax NG est plus limitée que XML Schema puisqu\u0026rsquo;il ne permet que quatre types de contraintes sur le nombre d\u0026rsquo;occurences d\u0026rsquo;un élément (zeroOrMore comme dans notre exemple, optional, un nombre précis (comme une seule fois) et oneOrMore) alors que le XML Schema permet des contraintes beaucoup plus spécifiques. Cependant, la richesse de la norme XML Schema a un coût : il s\u0026rsquo;agit d\u0026rsquo;une norme beaucoup plus difficile à utiliser et à apprendre en pratique.\nOn peut passer automatiquement d\u0026rsquo;un document DTD à un document XML Schema ou Relax NG avec un outil comme NekoDTD.\nEn somme, la norme DTD n\u0026rsquo;est sans doute pas ce qui se fait de mieux, mais c\u0026rsquo;est de loin la norme la plus utilisée historiquement, et c\u0026rsquo;est celle que nous allons étudier en détail. Pour certaines applications, la norme DTD demeure supérieure aux alternatives mentionnées précédemment: la définition d\u0026rsquo;entités n\u0026rsquo;est pas possible en XML Schema ou Relax NG, par exemple. Si vous maîtrisez la norme DTD, vous n\u0026rsquo;aurez aucun mal à utiliser une autre norme comme Relax NG puisque les principes essentiels sont les mêmes.\nDocuments valides utilisant la norme DTD # Un document valide commence par une déclaration XML, comme celle qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;no\u0026#34; ?\u0026gt; Elle est suivie d\u0026rsquo;une déclaration de type de document sous la forme \u003c!DOCTYPE ... SYSTEM ... \u003e , où l\u0026rsquo;on remplace les premiers trois points par le nom XML de l\u0026rsquo;élément-racine que le document doit avoir, et les deuxièmes trois points par une URL vers le document DTD. L\u0026rsquo;URL peut être absolue, comme « http://www.google.com/mydtd.dtd », ou locale, comme « madtd.dtd » ou « ../dtd/madtd.dtd ». Dans le second cas, il faut que le fichier DTD soit sur le disque, à l\u0026rsquo;endroit indiqué par rapport au fichier XML. Ainsi, dans l\u0026rsquo;exemple « ../dtd/madtd.dtd », il faudrait que le fichier « madtd.dtd» soit dans le répertoire « dtd », voisin du répertoire où se trouve le fichier XML. Ainsi, immédiatement après la déclaration XML, on pourrait avoir le texte suivant :\n\u0026lt;!DOCTYPE baliseracine SYSTEM \u0026#34;http://www.mondomain.com/madtd.dtd\u0026#34;\u0026gt; où « baliseracine » est le nom de l\u0026rsquo;élément-racine du document, alors que le chemin « http://www.mondomain.com/madtd.dtd» nous dit où trouver le document DTD.\nRappelons que l\u0026rsquo;attribut « encoding » nous donne le jeu des caractères. On choisit souvent « ISO-8859-1 », mais par défaut, XML utilise un jeu de caractères Unicode (UTF-8). Si le contenu est en français (avec les accents), il est essentiel que le fichier soit enregistré avec le jeu de caractères déclaré sinon on pourra constater des messages d\u0026rsquo;erreurs ou des accents manquants. L\u0026rsquo;attribut « standalone » permet au logiciel de décider, s\u0026rsquo;il est nécessaire, d\u0026rsquo;aller chercher la DTD externe avant de lire le fichier XML, même si, très souvent, un logiciel tel Mozilla Firefox ignore la consigne et ne va pas chercher la DTD externe. En gros, s\u0026rsquo;il y a une DTD externe, on utilisera l\u0026rsquo;attribut « standalone=\u0026ldquo;no\u0026rdquo; », autrement on utilise « standalone=\u0026ldquo;yes\u0026rdquo; ».\nLa syntaxe des documents DTD # Les documents DTD contiennent des instructions de la forme \u003c!ELEMENT ... \u003e. Bien que celle-ci ait l\u0026rsquo;apparence d\u0026rsquo;une balise XML, ce n\u0026rsquo;est pas du XML. Dans une instruction, on met d\u0026rsquo;abord un nom XML qui correspond à un nom d\u0026rsquo;élément : par exemple, l\u0026rsquo;instruction « \u003c!ELEMENT montant ... \u003e » définira ce qui peut être contenu dans un élément de nom « montant ». Tout ce qui suit le nom de l\u0026rsquo;élément dicte ce que l\u0026rsquo;élément peut contenir. Le plus souvent, on place la description du contenu entre parenthèses (« \u003c!ELEMENT montant (quelque chose) \u003e »), sauf pour les cas particuliers (« ANY » et « EMPTY ») définis plus loin. De façon courante, on définit le contenu d\u0026rsquo;un élément par une liste de noms XML, correspondant à des noms d\u0026rsquo;élément et séparés par des virgules. Par exemple, l\u0026rsquo;instruction « \u003c!ELEMENT montant (devise,valeur) \u003e » nous informe qu\u0026rsquo;un élément « montant » doit contenir un élément « devise » suivi d\u0026rsquo;un élément « valeur ». Notons que l\u0026rsquo;ordre des éléments importe et que les instructions « \u003c!ELEMENT montant (devise,valeur) \u003e » et « \u003c!ELEMENT montant (valeur,devise) \u003e » ne sont pas équivalentes.\nBien qu\u0026rsquo;on ne puisse exprimer toutes les possibilités, la syntaxe DTD permet tout de même de spécifier un grand nombre de règles. Par exemple, le symbole « ? » permet de spécifier qu\u0026rsquo;un élément peut être présent ou non (élément optionnel). Ainsi, l\u0026rsquo;instruction « \u003c!ELEMENT montant (devise?,valeur) \u003e » signifie que l\u0026rsquo;élément « montant » peut contenir un élément « devise » (ou non) et doit contenir un élément « valeur ». Si jamais l\u0026rsquo;élément « devise » apparaît, il doit apparaître avant l\u0026rsquo;élément « valeur ». Si jamais on veut qu\u0026rsquo;un élément soit optionnel et que, s\u0026rsquo;il apparaît, il puisse apparaître plus d\u0026rsquo;une fois, on utilise le symbole « * ». Ainsi, l\u0026rsquo;instruction « \u003c!ELEMENT montant (devise*,valeur) \u003e » signifie qu\u0026rsquo;on peut avoir zéro, un ou plusieurs éléments « devise », puis un élément « valeur ». De la même façon, le symbole « + » est utilisé pour spécifier qu\u0026rsquo;un élément doit être présent, mais peut apparaître plus d\u0026rsquo;une fois.\nAu lieu d\u0026rsquo;utiliser la virgule, on peut utiliser le symbole « | » pour spécifier qu\u0026rsquo;un élément ou un autre peut apparaître. Ainsi, l\u0026rsquo;instruction « \u003c!ELEMENT montant (devise|valeur) \u003e » signifie que l\u0026rsquo;élément « montant » peut contenir soit l\u0026rsquo;élément « devise », soit l\u0026rsquo;élément « valeur » (l\u0026rsquo;un ou l\u0026rsquo;autre, mais pas les deux ou aucun des deux). Finalement, on peut combiner le tout; par exemple, l\u0026rsquo;instruction « \u003c!ELEMENT montant (devise+|valeur*) \u003e » signifie que l\u0026rsquo;élément « montant » peut contenir au moins un élément « devise » (et rien d\u0026rsquo;autre) ou alors, aucun, 1 ou plusieurs éléments « valeur ».\nSi jamais on veut qu\u0026rsquo;un élément puisse contenir du texte, on utilise le terme technique « #PCDATA » dans l\u0026rsquo;instruction DTD. Par exemple, l\u0026rsquo;instruction « \u003c!ELEMENT montant (#PCDATA) \u003e » signifie que l\u0026rsquo;élément « montant » contient du texte et seulement du texte (pas d\u0026rsquo;éléments). Supposons maintenant qu\u0026rsquo;on veut permettre du contenu mixte, comme dans l\u0026rsquo;exemple qui suit :\n\u0026lt;mixte\u0026gt; du texte et \u0026lt;important\u0026gt;un élément\u0026lt;/important\u0026gt; \u0026lt;/mixte\u0026gt; On pourrait penser que l\u0026rsquo;instruction « \u003c!ELEMENT mixte (#PCDATA|important) \u003e » permettra du texte ou des éléments « important », et c\u0026rsquo;est vrai; mais elle permet l\u0026rsquo;un (juste du texte) ou l\u0026rsquo;autre (juste un élément « important »), mais pas un mélange des deux. Pour pouvoir obtenir le résultat désiré, soit un mélange d\u0026rsquo;éléments « important » et de texte, il faut permettre la répétition du choix, comme dans l\u0026rsquo;instruction « \u003c!ELEMENT mixte (#PCDATA|important)* \u003e ». Il s\u0026rsquo;agit de la seule façon de spécifier qu\u0026rsquo;on permet un mélange de texte et d\u0026rsquo;éléments (contenu mixte).\nVoyons un autre exemple de contenu mixte. Considérons l\u0026rsquo;instruction « \u003c!ELEMENT montant (#PCDATA|devise)* \u003e ». Ce qu\u0026rsquo;elle signifie exactement, c\u0026rsquo;est que les éléments « montant » peuvent contenir un mélange de texte et des éléments « devise », comme l\u0026rsquo;exemple qui suit :\n\u0026lt;montant\u0026gt;10 $ et \u0026lt;devise\u0026gt;dollars\u0026lt;/devise\u0026gt;\u0026lt;/montant\u0026gt; On peut aussi utiliser « ANY » pour spécifier qu\u0026rsquo;un élément peut contenir n\u0026rsquo;importe quoi (n\u0026rsquo;importe quelle séquence d\u0026rsquo;éléments déclarés dans la DTD et du texte) ou « EMPTY » pour spécifier qu\u0026rsquo;un élément doit être vide (sans même un seul espace). C\u0026rsquo;est le seul cas où l\u0026rsquo;on n\u0026rsquo;utilise pas de parenthèses lors de la définition du contenu, comme dans ces exemples : \u003c!ELEMENT question ANY\u003e et \u003c!ELEMENT question EMPTY\u003e.\nUn document DTD prendra donc la forme d\u0026rsquo;un fichier en format texte contenant une suite d\u0026rsquo;instructions comme :\n\u0026lt;!ELEMENT lettre (#PCDATA|personne)* \u0026gt; \u0026lt;!ELEMENT personne (age,nom) \u0026gt; \u0026lt;!ELEMENT age (#PCDATA) \u0026gt; \u0026lt;!ELEMENT nom (#PCDATA) \u0026gt; Notez qu\u0026rsquo;on écrit rarement de nouvelles DTD : dans un domaine particulier, il existera souvent des DTD déjà utilisées; sinon, on fera l\u0026rsquo;effort de les créer, mais qu\u0026rsquo;une seule fois. L\u0026rsquo;important demeure toutefois de pouvoir lire et comprendre les DTD.\nExemple supplémentaire # Pour s\u0026rsquo;assurer de bien comprendre, voyons un autre exemple :\n\u0026lt;!ELEMENT lettre (#PCDATA|personne)* \u0026gt; \u0026lt;!ELEMENT personne (age,nom) \u0026gt; Cette DTD nous spécifie que l\u0026rsquo;élément « lettre » contient du mélange de texte et d\u0026rsquo;éléments « personne » (contenu mixte), alors que l\u0026rsquo;élément « personne » doit contenir un élément « age », suivi d\u0026rsquo;un élément « nom ».\nPar exemple, ce document XML serait valide :\n\u0026lt;lettre\u0026gt; Bonjour \u0026lt;personne\u0026gt;\u0026lt;age\u0026gt;30\u0026lt;/age\u0026gt;\u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt;\u0026lt;/personne\u0026gt; \u0026lt;/lettre\u0026gt; Assurez-vous de bien comprendre pourquoi ce document est valide avant de continuer.\nLes attributs # Par défaut, aucun élément n\u0026rsquo;est autorisé à avoir un attribut. Pour permettre d\u0026rsquo;ajouter un attribut à un élément, il faut une instruction de la forme \u003c!ATTLIST recipiendaire age ...\u003e qui spécifie que l\u0026rsquo;élément recipiendaire peut avoir un attribut « age ». On permet généralement aux valeurs d\u0026rsquo;attribut de contenir n\u0026rsquo;importe quel texte, ce qu\u0026rsquo;on représente par « CDATA ». Hormis le contenu, il existe deux types d\u0026rsquo;attributs : les attributs obligatoires (« #REQUIRED ») et les attributs optionnels (« #IMPLIED »). Par exemple, l\u0026rsquo;instruction « \u003c!ATTLIST recipiendaire age CDATA #IMPLIED\u003e » signifie qu\u0026rsquo;on peut (ou pas) accorder à un élément « recipiendaire » un attribut nommé « age » pouvant contenir n\u0026rsquo;importe quel texte. Si l\u0026rsquo;on désire que l\u0026rsquo;attribut soit obligatoire, on utilise une instruction comme « \u003c!ATTLIST recipiendaire age CDATA #REQUIRED\u003e ».\nSi l\u0026rsquo;on veut permettre à un élément d\u0026rsquo;avoir plusieurs attributs, on peut le faire en utilisant plusieurs instructions comme dans « \u003c!ATTLIST recipiendaire age CDATA #REQUIRED\u003e \u003c!ATTLIST recipiendaire nom CDATA #REQUIRED\u003e »; on peut aussi combiner les instructions dans une seule : « \u003c!ATTLIST recipiendaire age CDATA #REQUIRED nom CDATA #REQUIRED\u003e ». Cependant, il n\u0026rsquo;est pas possible de spécifier l\u0026rsquo;ordre dans lequel les attributs doivent apparaître, les instructions « \u003c!ATTLIST recipiendaire age CDATA #REQUIRED nom CDATA #REQUIRED\u003e » et « \u003c!ATTLIST recipiendaire nom CDATA #REQUIRED age CDATA #REQUIRED\u003e » sont équivalentes.\nL\u0026rsquo;attribut « xml:lang » utilisé pour définir la langue d\u0026rsquo;un texte, peut être déclaré comme ceci : « \u003c!ATTLIST monelement xml:lang CDATA #IMPLIED\u003e ». L\u0026rsquo;attribut xml:space peut être déclaré comme ceci : « \u003c!ATTLIST monelement xml:space (default|preserve) #IMPLIED\u003e ».\nOn peut également spécifier qu\u0026rsquo;un élément donné a toujours un attribut donné (indiqué ou non dans le XML) comme ceci : «\u003c!ATTLIST recipiendaire age CDATA #FIXED \"40 ans\"\u003e». Dans ce dernier exemple, tous les éléments « recipiendaire » ont l\u0026rsquo;attribut « age=\u0026ldquo;40 ans\u0026rdquo; », même si on omet de l\u0026rsquo;indiquer dans la balise de départ de l\u0026rsquo;élément « recipiendaire ».\nPlus simplement, on peut spécifier une valeur par défaut qui ne prendra effet que si l\u0026rsquo;on n\u0026rsquo;a pas explicitement indiqué l\u0026rsquo;attribut. Par exemple, l\u0026rsquo;instruction « \u003c!ATTLIST recipiendaire age CDATA \"40 ans\"\u003e » signifie que l\u0026rsquo;élément « recipiendaire » aura l\u0026rsquo;attribut « age=\u0026ldquo;40 ans\u0026rdquo; », à moins qu\u0026rsquo;on ne spécifie autre chose dans le XML.\nIl peut être utile de donner une liste de valeurs que pourra prendre un attribut. Par exemple, une pièce de monnaie est soit sur « face », soit sur « pile » : il n\u0026rsquo;y a que deux choix. Si la liste de choix est composée de textes sans espace ou ponctuation, sauf la barre du soulignement ( _ ), le trait d\u0026rsquo;union ( - ) et le point ( . ), alors on peut faire une énumération comme dans l\u0026rsquo;exemple suivant : « \u003c!ATTLIST piece position (face|pile) #REQUIRED\u003e». On peut aussi spécifier une valeur par défaut, si l\u0026rsquo;on suppose, jusqu\u0026rsquo;à preuve du contraire, que la pièce est dans la position « face », comme ceci « \u003c!ATTLIST piece position (face|pile) \"face\"\u003e »\nOn peut également spécifier qu\u0026rsquo;un attribut servira à identifier un élément de façon unique. Pour ce faire, on utilise une instruction comme « \u003c!ATTLIST recipiendaire code ID\u003e ». Il n\u0026rsquo;est pas possible, pour deux attributs de type ID, d\u0026rsquo;avoir la même valeur dans un même document XML. En somme, si l\u0026rsquo;on donne une valeur « ID », elle devrait correspondre de façon unique à un élément et un seul. Un attribut de type « ID » doit avoir comme valeur un « nom XML », c\u0026rsquo;est-à-dire un texte sans espace ou ponctuation, sauf la barre du soulignement ( _ ), le trait d\u0026rsquo;union ( - ) et le point ( . ), et qui ne commence pas par un chiffre, un trait d\u0026rsquo;union ou un point.\nOn peut faire référence aux attributs de type « ID » avec des attributs de type « IDREF ». La valeur d\u0026rsquo;un attribut « IDREF » doit non seulement être un nom XML, mais doit aussi avoir un attribut de type « ID » qui possède cette même valeur quelque part dans le document XML. Par exemple, si on a l\u0026rsquo;instruction « \u003c!ATTLIST recipiendaire code ID\u003e », on pourra ensuite faire référence à l\u0026rsquo;élément ayant une valeur d\u0026rsquo;attribut « code » particulière, avec une instruction comme « \u003c!ATTLIST mauvaispayeur code IDREF\u003e ».\nDans ce contexte, le document XML qui suit n\u0026rsquo;est pas valide :\n\u0026lt;recipiendaire code=\u0026#34;123\u0026#34;\u0026gt;...\u0026lt;/recipiendaire\u0026gt; \u0026lt;mauvaispayeur code=\u0026#34;456\u0026#34;\u0026gt;...\u0026lt;/mauvaispayeur\u0026gt; Par contre, l\u0026rsquo;exemple qui suit est valide :\n\u0026lt;recipiendaire code=\u0026#34;123\u0026#34;\u0026gt;...\u0026lt;/recipiendaire\u0026gt; \u0026lt;mauvaispayeur code=\u0026#34;123\u0026#34;\u0026gt;...\u0026lt;/mauvaispayeur\u0026gt; Il existe d\u0026rsquo;autres types d\u0026rsquo;attributs, mais ils sont peu utilisés.\nLes entités # Vous vous rappelez sans doute que le XML définit quelques entités par défaut, « \u0026lt; », par exemple. On peut toutefois définir ses propres entités avec une instruction DTD comme celle-ci :\n\u0026lt;!ENTITY monentite \u0026#34;Introduction à XML\u0026#34;\u0026gt; La signification de ce dernier exemple, c\u0026rsquo;est que partout où « \u0026amp;monentite; » apparaît dans un document, il sera remplacé par le texte « Introduction à XML ». Ce remplacement s\u0026rsquo;applique aussi aux valeurs par défaut des attributs de la DTD.\nOn peut mettre des éléments et des attributs dans une entité comme dans cet exemple :\n\u0026lt;!ENTITY monentite \u0026#34;\u0026lt;paragraphe\u0026gt;texte\u0026lt;/paragraphe\u0026gt;\u0026#34;\u0026gt; Il n\u0026rsquo;est cependant pas permis de ne mettre qu\u0026rsquo;une partie d\u0026rsquo;un élément comme ceci :\n\u0026lt;!ENTITY monentite \u0026#34;\u0026lt;paragraphe\u0026gt;\u0026#34;\u0026gt; Une entité peut faire appel à une autre entité :\n\u0026lt;!ENTITY monentite1 \u0026#34;\u0026amp;monentite2;\u0026#34;\u0026gt; \u0026lt;!ENTITY monentite2 \u0026#34;texte\u0026#34;\u0026gt; Une entité ne peut cependant pas faire appel à elle même de manière récursive, directement ou indirectement. Cet exemple n\u0026rsquo;est donc pas valide :\n\u0026lt;!ENTITY monentite \u0026#34;\u0026amp;monentite;\u0026#34;\u0026gt; DTD interne et externe # Normalement, on fait référence à un document DTD à l\u0026rsquo;aide d\u0026rsquo;une URL, c\u0026rsquo;est ce qu\u0026rsquo;on appelle la DTD externe. Mais il est possible d\u0026rsquo;ajouter ses propres instructions DTD directement dans le document XML, en ajoutant une DTD interne qui est lue avant la DTD externe.\nPrenons l\u0026rsquo;exemple suivant, soit un document XML qui débute par :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE question SYSTEM \u0026#34;question.dtd\u0026#34; [ \u0026lt;!ELEMENT question #PCDATA\u0026gt; ]\u0026gt; Dans ce cas, tout ce passe comme si on ajoutait la ligne « \u003c!ELEMENT question #PCDATA\u003e » à la DTD externe. Normalement, il ne devrait jamais y avoir de conflit entre les deux DTD (interne et externe); on ne peut pas redéfinir un élément, mais on peut y définir des éléments! Par contre, les entités peuvent être redéfinies et la définition trouvée dans le DTD interne l\u0026rsquo;emporte.\nOn peut même omettre complètement la DTD externe comme dans l\u0026rsquo;exemple suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE question [ \u0026lt;!ELEMENT question #PCDATA\u0026gt; ]\u0026gt; Les entités paramètres # On peut aussi définir des entités particulières qui ne s\u0026rsquo;appliquent que dans le contexte de la DTD, et non pas dans le document XML. Pour ces entités, au lieu d\u0026rsquo;utiliser l\u0026rsquo;esperluette ( \u0026amp; ), on utilise plutôt le symbole du pourcentage ( % ). Ainsi, l\u0026rsquo;instruction suivante :\n\u0026lt;!ENTITY % monentite \u0026#34;#PCDATA|age*\u0026#34;\u0026gt; signifie que partout, dans la DTD externe, où se trouve le texte « %monentite; », il sera remplacé par « #PCDATA|age* »; on appelle ces entités des « entités paramètres ». On peut définir une entité paramètre dans la DTD interne, mais on ne peut pas l\u0026rsquo;y utiliser; elle doit être utilisée dans la DTD externe. Si l\u0026rsquo;entité paramètre « %monentite; » est définie, à la fois dans la DTD interne et dans la DTD externe, la DTD interne a préséance. En somme, les entités paramètres ne s\u0026rsquo;appliquent que dans la DTD externe; elles ne s\u0026rsquo;appliquent ni dans le document XML, ni dans le DTD interne, soit la partie de la DTD définie dans le document XML.\nCommentaires dans les fichiers DTD # Pour rendre un fichier DTD plus compréhensible, on peut ajouter des commentaires. La syntaxe est la même que pour les fichiers XML comme le montre l\u0026rsquo;exemple suivant.\n\u0026lt;!-- ceci est un commentaire --\u0026gt; Les commentaires dans les fichiers Relax NG non-textuel sont obtenus en débutant une ligne par le symbole « # » comme dans cet exemple.\n# ceci est un commentaire Une comparaison entre Relax NG et DTD # Une fois qu\u0026rsquo;on connaît bien le format DTD, il est facile d\u0026rsquo;apprendre Relax NG. Prenons d\u0026rsquo;abord un de nos exemples de fichier DTD.\n\u0026lt;!ELEMENT lettre (#PCDATA|personne)* \u0026gt; \u0026lt;!ELEMENT personne (age,nom) \u0026gt; Une étude attentive vous permettra de constater que ce fichier est très similaire au fichier Relax NG suivant, qui lui est essentiellement équivalent.\nelement lettre { (text | element personne { element age { text }, element nom { text } })* } Pour bien comprendre, prenons un autre exemple, plus complexe cette fois-ci. Voici un autre fichier DTD discuté précédemment.\n\u0026lt;!ELEMENT question (questionText,answer+) \u0026gt; \u0026lt;!ELEMENT questionText (#PCDATA) \u0026gt; \u0026lt;!ELEMENT answer (#PCDATA) \u0026gt; Voici l\u0026rsquo;équivalent en Relax NG. Si vous l\u0026rsquo;étudiez avec soin, vous verrez qu\u0026rsquo;encore une fois, le format Relax NG est très similaire au format DTD.\nelement question { element questionText { text }, element answer { text }+ } Prenons maintenant un exemple de fichier DTD contenant un attribut.\n\u0026lt;!ELEMENT personne (nom,age) \u0026gt; \u0026lt;!ATTLIST personne code CDATA #REQUIRED\u0026gt; L\u0026rsquo;équivalent Relax NG est, encore une fois, assez compréhensible comme vous pourrez le constater, l\u0026rsquo;instruction ATTLIST étant remplacée par l\u0026rsquo;instruction « attribute ».\nelement personne { attribute code { text }, element nom { text }, element age { text } } Lorsqu\u0026rsquo;on utilise l\u0026rsquo;instruction attribute, la présence de l\u0026rsquo;attribut est requise à moins d\u0026rsquo;ajouter le point d\u0026rsquo;interrogation (« ? ») à la suite de l\u0026rsquo;instruction.\nLe format Relax NG permet aussi de définir des motifs qui peuvent être réutilisés. Prenons ce fichier DTD simple.\n\u0026lt;!ELEMENT problemset (choice+) \u0026gt; \u0026lt;!ELEMENT choice (#PCDATA) \u0026gt; L\u0026rsquo;équivalent en Relax NG donne ceci.\nchoiceele = element choice { text } element problemset { choiceele+ } Le format Relax NG a cependant plusieurs avantages. Par exemple, l\u0026rsquo;esperluette (\u0026amp;) permet de spécifier que des éléments puissent être inclus dans n\u0026rsquo;importe quel ordre. Il n\u0026rsquo;y a pas d\u0026rsquo;équivalent en DTD. Considérons l\u0026rsquo;exemple suivant.\nelement card { element name { text } \u0026amp; element email { text } } On peut alors permettre le XML suivant. Il n\u0026rsquo;est pas possible de spécifier le contenu de l\u0026rsquo;élément card avec une instruction DTD similaire.\n\u0026lt;card\u0026gt;\u0026lt;email\u0026gt;jean@exemple.com\u0026lt;/email\u0026gt;\u0026lt;name\u0026gt;Jean\u0026lt;/name\u0026gt;\u0026lt;/card\u0026gt; Supposons maintenant qu\u0026rsquo;un élément puisse avoir soit l\u0026rsquo;attribut nas, soit à la fois les attributs nas1 et nas2. Alors qu\u0026rsquo;il n\u0026rsquo;est pas possible de représenter cette condition en DTD, c\u0026rsquo;est une chose facile en Relax NG.\nelement personne { attribute nas { text } | (attribute nas1 { text } \u0026amp; attribute nas2 { text }) } Une approche plus modulaire # En pratique, les fichiers DTD et Relax NG peuvent devenir complexes. On souhaite donc souvent les diviser en plusieurs fichiers plus petits. Par exemple, pour une spécification portant des ventes et achats de biens, on pourra avoir un fichier portant sur la description des biens, un fichier portant sur la description des acheteurs, et ainsi de suite. Une approche modulaire, avec de petits fichiers, a aussi l\u0026rsquo;avantage qu\u0026rsquo;on peut réutiliser les fichiers dans plus d\u0026rsquo;une spécification.\nÀ titre d\u0026rsquo;exemple, reprenons le fichier DTD portant sur la définition de l\u0026rsquo;élément « problemset ». Au lieu de définir tout d\u0026rsquo;un seul coup, on peut commencer par un fichier DTD qui ne définit que l\u0026rsquo;élément « choice » :\n\u0026lt;!ELEMENT choice (#PCDATA)\u0026gt; Pour les fins de notre exemple, supposons que ce dernier fichier porte le nom de « choice.dtd » et se trouve à l\u0026rsquo;adresse « http://www.mondomaine.com/choice.dtd ». On pourra alors en importer le contenu dans un autre fichier externe avec une « entité paramètre externe ». À la différence d\u0026rsquo;une entité paramètre usuelle, une entité paramètre externe pointe vers un autre document que le logiciel devra traiter. On définit l\u0026rsquo;entité paramètre externe avec l\u0026rsquo;instruction « SYSTEM » suivie d\u0026rsquo;une adresse web comme dans cet exemple :\n\u0026lt;!ENTITY % monentite SYSTEM \u0026#34;http://www.mondomaine.com/choice.dtd\u0026#34;\u0026gt; Pour inclure le contenu du fichier externe (« choice.dtd » dans notre exemple), il suffit tout simplement de faire appel à l\u0026rsquo;entité comme ceci :\n%monentite; Dans ce cas, tout se déroule comme si le contenu du fichier « choice.dtd » était inséré à l\u0026rsquo;endroit où se trouve l\u0026rsquo;appel (« %monentite; »). On peut définir l\u0026rsquo;élément « problemset » à l\u0026rsquo;aide du fichier DTD suivant :\n\u0026lt;!ELEMENT problemset (choice+)\u0026gt; On peut obtenir le même résultat avec Relax NG, un peu plus simplement avec l\u0026rsquo;utilisation de l\u0026rsquo;instruction « include ». Créons d\u0026rsquo;abord un fichier « choice.rnc » avec le contenu suivant :\nchoiceele = element choice { text } On peut alors réutiliser le motif « choiceele » dans n\u0026rsquo;importe quel autre fichier Relax NG comme le montre cet exemple :\ninclude \u0026#34;choice.rnc\u0026#34; element problemset { choiceele+ } En bref, il est facile de diviser des spécifications Relax NG ou DTD en plusieurs fichiers plus petits, plus faciles à éditer, et qui peuvent être plus facilement réutilisés.\nDéfinir l\u0026rsquo;élément-racine # Avec une DTD, il n\u0026rsquo;est pas possible de définir l\u0026rsquo;élément-racine. Celui-ci est déclaré par l\u0026rsquo;instruction DOCTYPE qui se trouve dans le document XML. Avec Relax NG, on peut non seulement spécifier l\u0026rsquo;élément-racine avec le mot-clef start, mais on peut aussi permettre une certaine flexibilité. Par exemple, l\u0026rsquo;instruction « start = problemset | choice » placée dans un fichier Relax NG, nous indique qu\u0026rsquo;on peut utilisé l\u0026rsquo;élément problemset ou l\u0026rsquo;élément choice comme élément-racine.\nDéfinir le type de contenu en Relax NG # Dans tous nos exemples de Relax NG, nous n\u0026rsquo;avons prévu que du contenu textuel (text) ou des éléments vides (empty). Relax NG permet de spécifier le contenu d\u0026rsquo;un élément ou d\u0026rsquo;un attribut d\u0026rsquo;une manière très fine. Il emprunte ici la spécification mise au point par XML Schema. En particulier, on peut spécifier un contenu textuel à l\u0026rsquo;aide d\u0026rsquo;une expression régulière. Voici quelques exemples.\nType Explication Exemple xsd:date Une date formattée avec la convention YYYY-MM-DD 2001-01-01 ou 1999-12-30 xsd:dateTime Un moment spécifique à la seconde près 2000-12-31T03:32:00 xsd:string {pattern = \u0026ldquo;[^:]+\u0026rdquo; } Une chaîne de caractères contenant au moins un caractère, à l\u0026rsquo;exclusion du symbole : maison xsd:string { pattern = \u0026ldquo;.+/.+\u0026rdquo; } Deux chaînes de caractères séparée par un caractère / 01/01 xsd:string { pattern = \u0026ldquo;.+@.+\u0026rdquo;} Deux chaînes de caractères séparée par un caractère @ lala@to.com \u0026ldquo;text\u0026rdquo; | \u0026ldquo;html\u0026rdquo; text ou html text xsd:string { minLength=\u0026ldquo;7\u0026rdquo; maxLength=\u0026ldquo;25\u0026rdquo; } Une chaîne caractères faisant entre 7 et 25 caractères monmotdepasse xsd:decimal { minExclusive=\u0026ldquo;0.0\u0026rdquo; maxInclusive=\u0026ldquo;10.0\u0026rdquo; } Un nombre entre 0 et 10 5 xsd:decimal { fractionDigits=\u0026ldquo;3\u0026rdquo; } Un nombre n\u0026rsquo;ayant pas plus de 3 chiffres après la virgule (le point) 5.001 On déclare ensuite le contenu d\u0026rsquo;un élément ou d\u0026rsquo;un attribut comme ceci : element madate {xsd:date}.\nEst-ce qu\u0026rsquo;il existe un outil pour passer d\u0026rsquo;un format à l\u0026rsquo;autre (DTD, Relax NG, XML Schema)? # Oui, le programme Java Trang permet de passer facilement d\u0026rsquo;un format à l\u0026rsquo;autre.\nEst-ce qu\u0026rsquo;un document DTD est un document XML? # Absolument pas. Par contre, une DTD est un document textuel. Les fichiers XML Schema sont par contre toujours en XML, alors que les fichiers Relax NG sont parfois en XML, parfois en simple format textuel comme dans nos exemples.\nPourquoi est-ce qu\u0026rsquo;il n\u0026rsquo;est pas suffisant d\u0026rsquo;utiliser des documents bien formés? À quoi sert la validation? # Les documents XML sont faits pour être échangés et assurer la pérennité des informations. Si plusieurs individus ou plusieurs institutions s\u0026rsquo;entendent sur une DTD commune, il sera beaucoup plus facile d\u0026rsquo;échanger de l\u0026rsquo;information.\nEst-ce vraiment nécessaire d\u0026rsquo;avoir des documents valides? Est-ce que je dois vraiment toujours travailler avec des fichiers DTD, XML Schema ou Relax NG? # En pratique, la validation n\u0026rsquo;est pas essentielle et une application logicielle ne devrait pas exiger des documents valides. Si vous concevez une application, la règle implicite est que toute balise ou attribut non prévue devrait être ignorée. Un navigateur qui sait lire et afficher du XML devrait pouvoir lire tout XML bien formé, même s\u0026rsquo;il n\u0026rsquo;est pas valide. Si vous inventez une nouvelle balise XHTML, le navigateur devrait tout simplement ne pas en tenir compte. Les concepteurs du XML n\u0026rsquo;ont pas inscrit la nécessité d\u0026rsquo;être valide à même la définition du XML et c\u0026rsquo;est un choix qui n\u0026rsquo;a jamais été remis en question par l\u0026rsquo;organisme de normalisation W3C.\nIl arrive, par exemple, qu\u0026rsquo;il soit inutilement complexe d\u0026rsquo;exiger que les documents soient valides. Si on se contraint à des documents valides, on peut même en arriver à des solutions qui sont techniquement inférieures.\n"},{"id":2,"href":"/orientee_donnees/docs/modules/b_module_xml/espaces/espace_de_nom/","title":"Espace de noms","section":"Espaces de nom","content":" Espace de noms # Les espaces de noms en XML permettent de distinguer des éléments et attributs provenant de vocabulaires différents, évitant ainsi les conflits de noms. Ils sont essentiels pour combiner plusieurs schémas XML dans un même document.\nLes vocabulaires XML # Un « vocabulaire XML » est un ensemble de noms de balises et d\u0026rsquo;attributs ayant une signification donnée. Par exemple, les gens de la comptabilité au sein d\u0026rsquo;une entreprise pourraient avoir un vocabulaire XML pour décrire certaines transactions, alors que les ingénieurs pourraient avoir leur propre vocabulaire pour décrire certains processus techniques. Les deux équipes pourraient utiliser les mêmes noms d\u0026rsquo;élément, comme « échéance », mais avec des significations différentes. On dira alors que nous avons deux vocabulaires XML.\nVoyons un autre exemple. Imaginez que votre institution ait un vocabulaire XML pour les expéditions de marchandise et un vocabulaire XML pour la rédaction des factures. Un document XML combinant à la fois de l\u0026rsquo;information concernant une expédition et une facture devra utiliser deux vocabulaires. Un vocabulaire XML peut être associé à un document DTD; il peut aussi être associé à un espace de noms.\nLes identificateurs de ressources uniformes (URI) # Un identificateur de ressources uniformes (Uniform Resource Identifier ou URI) est une adresse Internet composée d\u0026rsquo;un nom de protocole ou « schéma », comme file, http, ftp, news, mailto, gopher, urn, suivi d\u0026rsquo;un deux-points « : », lui-même suivi d\u0026rsquo;un chemin, comme « www.mondomain.com/fichier ». Un URI ne pointe pas nécessairement vers un fichier, mais peut très bien être une adresse purement fictive ou une adresse pointant vers une application logicielle sur un serveur.\nPar exemple, « http://www.mondomain.com/fichier » et « mailto:billg@microsoft.com » sont des URI. Les URI ne doivent pas contenir d\u0026rsquo;accents, et la casse est significative sauf pour ce qui est du nom du protocole (HTTP versus http) et du nom de domaine (xerox.com versus XEROX.COM). Nous reviendrons sur les URI dans le module 5.\nLes espaces de noms # Un espace de noms est identifié par un URI; il y a correspondance unique entre les espaces de noms et les URI. Deux espaces de noms ayant le même URI sont identiques. Tous les utilisateurs d\u0026rsquo;un même vocabulaire XML devraient s\u0026rsquo;entendre sur un même URI. Par exemple, l\u0026rsquo;URI de l\u0026rsquo;espace de noms du XHTML est « http://www.w3.org/1999/xhtml ». L\u0026rsquo;URI agit un peu comme le numéro d\u0026rsquo;assurance sociale des vocabulaires XML. Il s\u0026rsquo;agit d\u0026rsquo;une analogie un peu étrange, voire originale, mais c\u0026rsquo;est ainsi.\nÉvidemment, la notion d\u0026rsquo;espace de noms n\u0026rsquo;a de sens que si l\u0026rsquo;on considère plusieurs espaces de noms et, par conséquent, plusieurs vocabulaires.\nLes DTD et les espaces de noms # Avant de préciser le lien entre les DTD et les espaces de noms, il importe de comprendre que les espaces de noms furent proposés après l\u0026rsquo;adoption des DTD. Il y a donc une certaine incompatibilité entre les DTD et les espaces de noms. C\u0026rsquo;est d\u0026rsquo;ailleurs l\u0026rsquo;une des raisons pour laquelle plusieurs organismes, dont OASIS et le W3C, tentent de proposer des solutions de remplacement pour les DTD.\nRappelons que l\u0026rsquo;on donne une DTD à un document, en ajoutant une déclaration de type de document, immédiatement après la déclaration XML, et dont la forme est :\n\u0026lt;!DOCTYPE balise SYSTEM \u0026#34;http://www.mondomain.com/madtd.dtd\u0026#34;\u0026gt; C\u0026rsquo;est la même chose avec les espaces de noms. Si vous avez, par exemple, un vocabulaire pour les expéditions et un vocabulaire pour les factures, définis respectivement par des DTD situées à :\nhttp://www.mondomain.com/expedition.dtd et\nhttp://www.mondomain.com/facture.dtd, vous ne pourriez pas combiner les deux vocabulaires ainsi :\n\u0026lt;!DOCTYPE balise SYSTEM \u0026#34;http://www.mondomain.com/expedition.dtd\u0026#34; \u0026#34;http://www.mondomain.com/facture.dtd\u0026#34;\u0026gt; Même si l\u0026rsquo;on pouvait combiner deux DTD de la sorte, cela aurait plusieurs inconvénients : quoi faire si les deux DTD définissent un élément « client », mais de façon différente? La solution est de créer un nouveau vocabulaire XML qui combine les deux et traite chaque vocabulaire comme un « espace de noms ».\nDans l\u0026rsquo;exemple qui suit, nous considérons deux vocabulaires, « facture » et « expedition » qui ont les DTD suivantes :\n\u0026lt;!ELEMENT facture (montant, nom)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT expedition (nom)\u0026gt; \u0026lt;!ELEMENT nom (prenom, nomfamille, adresse)\u0026gt; \u0026lt;!ELEMENT prenom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nomfamille (#PCDATA)\u0026gt; \u0026lt;!ELEMENT adresse (#PCDATA)\u0026gt; Déclaration de l\u0026rsquo;espace de noms # On peut utiliser le symbole « : » dans les noms XML, mais on ne l\u0026rsquo;utilise généralement qu\u0026rsquo;une seule fois dans un nom donné. Tout ce qui précède le deux-points est appelé le « préfixe ».\nOn a vu qu\u0026rsquo;un espace de noms est identifié par un URI. À leur tour, les URI peuvent être associés à un « préfixe ». Tout attribut ou élément qui utilise un préfixe donné fait automatiquement partie de l\u0026rsquo;espace de noms identifié par l\u0026rsquo;URI. Seul l\u0026rsquo;URI identifie un espace de noms : le choix du préfixe est sans importance. Un document peut avoir un seul espace de noms, mais douze préfixes différents. On définit un « préfixe » à l\u0026rsquo;aide d\u0026rsquo;un attribut ayant comme préfixe « xmlns ». La définition du préfixe est alors valable pour l\u0026rsquo;ensemble de l\u0026rsquo;élément, y compris la balise où se situe l\u0026rsquo;attribut « xmlns: ». Ainsi, dans le document XML suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:montant\u0026gt;10$\u0026lt;/fact:montant\u0026gt; \u0026lt;fact:nom\u0026gt;Jean\u0026lt;/fact:nom\u0026gt; \u0026lt;/fact:facture\u0026gt; on reconnaît que l\u0026rsquo;élément « fact:facture » et tout son contenu utilisent l\u0026rsquo;espace de noms « http://www.domaine.com/facture » que nous avons décrit par une DTD plus haut. Le préfixe « fact » est ici associé à l\u0026rsquo;URI « http://www.domaine.com/facture » et tous les éléments et attributs ayant le préfixe « fact » sont considérés faire partie de l\u0026rsquo;espace de noms « http://www.domaine.com/facture ».\nIl est « illégal » d\u0026rsquo;utiliser un préfixe qui n\u0026rsquo;a pas été défini\u0026hellip; Ainsi, le document suivant est bien formé, mais il ne respecte pas les conventions des espaces de noms :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture\u0026gt; \u0026lt;fact:montant\u0026gt;10$\u0026lt;/fact:montant\u0026gt; \u0026lt;fact:nom\u0026gt;Jean\u0026lt;/fact:nom\u0026gt; \u0026lt;/fact:facture\u0026gt; Avez-vous remarqué que ces derniers documents n\u0026rsquo;ont pas de déclaration de type de document et ne peuvent donc pas être des documents XML valables? La plupart des documents XML utilisant les espaces de noms sont dans ce cas. Si jamais nous avions une déclaration de type de document, il faudrait une DTD qui contiennent les éléments « fact:facture », « fact:montant » et « fact:nom ». En d\u0026rsquo;autres mots, ce nouveau document XML ne peut utiliser la DTD facture décrite plus haut. Nous ne traiterons pas de cette approche ici, car on combine rarement les DTD de la sorte.\nLe choix du préfixe « fact: » est arbitraire. On peut changer le nom du préfixe, car seul l\u0026rsquo;URI identifie de façon unique l\u0026rsquo;espace de noms. Par exemple, le document XML suivant est équivalent à celui que nous venons de décrire.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;facture:facture xmlns:facture=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;facture:montant\u0026gt;10$\u0026lt;/facture:montant\u0026gt; \u0026lt;facture:nom\u0026gt;Jean\u0026lt;/facture:nom\u0026gt; \u0026lt;/facture:facture\u0026gt; On peut aussi redéfinir un préfixe comme dans l\u0026rsquo;exemple qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;facture:facture xmlns:facture=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;facture:montant xmlns:facture=\u0026#34;http://www.domaine.com/facture2\u0026#34;\u0026gt; 10$\u0026lt;/facture:montant\u0026gt; \u0026lt;facture:nom\u0026gt;Jean\u0026lt;/facture:nom\u0026gt; \u0026lt;/facture:facture\u0026gt; Dans ce dernier cas, on dira que l\u0026rsquo;élément « montant » est dans l\u0026rsquo;espace de noms « http://www.domaine.com/facture2 » et non pas dans l\u0026rsquo;espace de noms « http://www.domaine.com/facture ». Tout élément et attribut, utilisant le préfixe « facture » dans l\u0026rsquo;élément « montant », seraient eux aussi dans l\u0026rsquo;espace de noms « http://www.domaine.com/facture2 ».\nL\u0026rsquo;endroit où apparaît la déclaration d\u0026rsquo;espace de noms est aussi sans conséquence. Par exemple, les deux documents suivants sont équivalents :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;enveloppe xmlns:facture=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;facture:facture \u0026gt; \u0026lt;facture:montant\u0026gt;10$\u0026lt;/facture:montant\u0026gt; \u0026lt;facture:nom\u0026gt;Jean\u0026lt;/facture:nom\u0026gt; \u0026lt;/facture:facture\u0026gt; \u0026lt;/enveloppe\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;enveloppe\u0026gt; \u0026lt;facture:facture xmlns:facture=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;facture:montant\u0026gt;10$\u0026lt;/facture:montant\u0026gt; \u0026lt;facture:nom\u0026gt;Jean\u0026lt;/facture:nom\u0026gt; \u0026lt;/facture:facture\u0026gt; \u0026lt;/enveloppe\u0026gt; On dit que deux documents sont équivalents, au sens des espaces de noms, s\u0026rsquo;ils ne diffèrent que par les préfixes d\u0026rsquo;espaces de noms et par les endroits où apparaissent les déclarations d\u0026rsquo;espaces de noms.\nÉvidemment, avec les espaces de noms, on peut combiner plusieurs vocabulaires. Par exemple, si nous voulons décrire une commande en utilisant les vocabulaires « facture » et « expedition », on peut très bien le faire comme le montre l\u0026rsquo;exemple suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:montant\u0026gt;10$\u0026lt;/fact:montant\u0026gt; \u0026lt;fact:nom\u0026gt;Jean\u0026lt;/fact:nom\u0026gt; \u0026lt;exp:expedition xmlns:exp=\u0026#34;http://www.domaine.com/expedition\u0026#34;\u0026gt; \u0026lt;exp:nom\u0026gt; \u0026lt;exp:prenom\u0026gt;Jean\u0026lt;/exp:prenom\u0026gt; \u0026lt;exp:nomfamille\u0026gt;Bertrand\u0026lt;/exp:nomfamille\u0026gt; \u0026lt;exp:adresse\u0026gt;1040, rue Jean\u0026lt;/exp:adresse\u0026gt; \u0026lt;/exp:nom\u0026gt; \u0026lt;/exp:expedition\u0026gt; \u0026lt;/fact:facture\u0026gt; En outre, on pourrait même combiner les espaces de noms de façon arbitraire comme le montre le prochain exemple :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:montant\u0026gt;10$\u0026lt;/fact:montant\u0026gt; \u0026lt;fact:nom\u0026gt;Jean\u0026lt;/fact:nom\u0026gt; \u0026lt;exp:nom xmlns:exp=\u0026#34;http://www.domaine.com/expedition\u0026#34;\u0026gt; \u0026lt;exp:prenom\u0026gt;Jean\u0026lt;/exp:prenom\u0026gt; \u0026lt;exp:nomfamille\u0026gt;Bertrand\u0026lt;/exp:nomfamille\u0026gt; \u0026lt;exp:adresse\u0026gt;1040, rue Jean\u0026lt;/exp:adresse\u0026gt; \u0026lt;/exp:nom\u0026gt; \u0026lt;/fact:facture\u0026gt; Les déclarations croisées # La déclaration d\u0026rsquo;espace de noms n\u0026rsquo;est valable qu\u0026rsquo;au sein de l\u0026rsquo;élément. Pour déterminer l\u0026rsquo;espace de nom auquel appartient un élément, il ne suffit donc pas de remonter et de s\u0026rsquo;arrêter à la première déclaration que l\u0026rsquo;on trouve. Voyez si vous pouvez voir pourquoi l\u0026rsquo;espace de nom de l\u0026rsquo;élément « fact:montant » dans l\u0026rsquo;exemple suivant est « http://www.domaine.com/facture » et non « http://www.domaine.com/facture2 ».\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture2\u0026#34;\u0026gt; \u0026lt;/fact:facture\u0026gt; \u0026lt;fact:montant /\u0026gt; \u0026lt;/fact:facture\u0026gt; Le préfixe par défaut # On peut utiliser le préfixe par défaut, c\u0026rsquo;est-à-dire ne pas mettre de préfixe du tout. L\u0026rsquo;utilisation du préfixe par défaut est optionnelle dans un document XML. Comme tout autre préfixe, le préfixe par défaut peut être réutilisé, redéfini plusieurs fois dans un même document. Voici un exemple de préfixe par défaut :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:montant\u0026gt;10$\u0026lt;/fact:montant\u0026gt; \u0026lt;nom xmlns=\u0026#34;http://www.domaine.com/expedition\u0026#34;\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nomfamille\u0026gt;Bertrand\u0026lt;/nomfamille\u0026gt; \u0026lt;adresse\u0026gt;1040, rue Jean\u0026lt;/adresse\u0026gt; \u0026lt;/nom\u0026gt; \u0026lt;/fact:facture\u0026gt; Notons cependant que le préfixe par défaut ne s\u0026rsquo;utilise que pour les éléments : les attributs sans préfixe ne sont dans aucun espace de noms, et cela sans exception.\nRappel des notions formelles # La définition d\u0026rsquo;un préfixe d\u0026rsquo;espace de noms inclut l\u0026rsquo;élément où le préfixe est défini et tout son contenu, et rien d\u0026rsquo;autre. Le document qui suit fait une utilisation incorrecte des espaces de noms :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;expedition\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;/fact:facture\u0026gt; \u0026lt;fact:nom\u0026gt;\u0026lt;/fact:nom\u0026gt; \u0026lt;/expedition\u0026gt; parce que le préfixe « fact » n\u0026rsquo;est défini qu\u0026rsquo;au sein de l\u0026rsquo;élément « facture ».\nBien que cela ne soit pas recommandable, il est possible de redéfinir les préfixes d\u0026rsquo;espace de noms. C\u0026rsquo;est simple si l\u0026rsquo;on se rappelle que la définition d\u0026rsquo;un préfixe inclut l\u0026rsquo;élément où la définition est faite. Ainsi, dans l\u0026rsquo;exemple :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;expedition\u0026gt; \u0026lt;fact:facture xmlns:fact=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;fact:nom xmlns:fact=\u0026#34;http://www.domaine.com/nom\u0026#34;\u0026gt;\u0026lt;/fact:nom\u0026gt; \u0026lt;/fact:facture\u0026gt; l\u0026rsquo;élément « nom » appartient à l\u0026rsquo;espace de noms « http://www.domaine.com/nom » et non à l\u0026rsquo;espace de noms « http://www.domaine.com/facture ».\nPar convention, on doit toujours accorder à un préfixe d\u0026rsquo;espace de noms un URI et il serait incorrect d\u0026rsquo;écrire \u0026lt;fact:facture /\u0026gt; au lieu de \u0026lt;fact:facture xmlns:fact=\u0026ldquo;http://www.domaine.com/facture\"\u003e dans l\u0026rsquo;exemple précédent.\nLes espaces de noms et Relax NG # Alors que les DTD ne permettent pas de traiter les espaces de noms, les spécifications Relax NG et XML Schema le permettent. L\u0026rsquo;utilisation des espaces de noms en Relax NG est particulièrement simple comme le montre cet exemple.\nnamespace fact = \u0026#34;http://www.domaine.com/facture\u0026#34; namespace fact2 = \u0026#34;http://www.domaine.com/facture2\u0026#34; element fact:facture { element fact:nom {text}, element fact:montant {text}, element fact2:id {text} }* } Le document XML suivant sera alors valable.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;f:facture xmlns:f=\u0026#34;http://www.domaine.com/facture\u0026#34;\u0026gt; \u0026lt;f:nom\u0026gt;Daniel\u0026lt;/f:nom\u0026gt; \u0026lt;f:montant\u0026gt;10,80$\u0026lt;/f:montant\u0026gt; \u0026lt;f2:id xmlns:f2=\u0026#34;http://www.domaine.com/facture2\u0026#34;\u0026gt;10,80$\u0026lt;/f2:id\u0026gt; \u0026lt;/f:facture\u0026gt; Par défaut, il n\u0026rsquo;y a pas d\u0026rsquo;espace de noms lorsqu\u0026rsquo;un préfixe n\u0026rsquo;est pas utilisé, mais on peut définir l\u0026rsquo;espace de noms par défaut comme ceci :\nnamespace fact = \u0026#34;http://www.domaine.com/facture\u0026#34; default namespace = \u0026#34;http://www.domaine.com/facture2\u0026#34; element fact:facture { element fact:nom {text}, element fact:montant {text}, element id {text} }* } Les deux exemples précédents de Relax NG sont d\u0026rsquo;ailleurs équivalents.\nLe préfixe « xml » # Par convention, le préfixe « xml » est réservé à des applications telles que la déclaration de la langue utilisée (« xml:lang ») ou le traitement des espaces (« xml:space »). Il n\u0026rsquo;est pas nécessaire d\u0026rsquo;y associer explicitement un URI : l\u0026rsquo;URI « http://www.w3.org/XML/1998/namespace » y est automatiquement associé.\nRappel : des espaces de noms pour les attributs? # Les choses se corsent un peu quand on considère les attributs. Alors qu\u0026rsquo;un élément sans préfixe tombe dans l\u0026rsquo;espace de noms par défaut si celui-ci a été défini par un attribut « xmlns=\u0026rdquo;\u0026hellip;\u0026quot; », ce n\u0026rsquo;est pas le cas pour les attributs. Un attribut sans préfixe n\u0026rsquo;est dans aucun espace de noms; pour y être, un attribut doit être muni d\u0026rsquo;un préfixe.\nEn résumé, qu\u0026rsquo;est-ce que les espaces de noms? # Une DTD définit un ensemble fixe d\u0026rsquo;éléments, ensemble qui ne peut être recombiné avec d\u0026rsquo;autres DTD; c\u0026rsquo;est un instrument rigide. Par contre, les espaces de noms permettent de recombiner des éléments provenant de différentes applications; ils permettent donc une grande flexibilité.\nAlors que la DTD définit des éléments et comment les utiliser ensemble, les espaces de noms ne permettent d\u0026rsquo;établir qu\u0026rsquo;un lien entre un élément et un URI, mais sans indiquer les contraintes d\u0026rsquo;utilisation.\n"},{"id":3,"href":"/orientee_donnees/docs/modules/b_module_xml/base/introduction_a_xml/","title":"Introduction à XML","section":"Les fondements","content":" Introduction à XML Le XML est un « métalangage » permettant d'échanger de l'information, principalement sur le web. Il a été conçu par Tim Bray, Jon Bosak et de nombreux autres collaborateurs, entre 1996 et 1999. On dit que c'est un « métalangage » parce qu'il est une façon pratique de créer de nouveaux langages pour échanger des informations, mais qu'il ne constitue pas un langage en soi. On dit que le XML est « extensible » (peut être étendu) et que c'est un métalangage : les deux affirmations vont dans le même sens et notent la capacité du XML à s'adapter à des besoins différents. Un document XML est essentiellement du texte contenant des balises. Une balise est un segment de texte commençant par \u0026lt; et se terminant par \u0026gt;, comme \u0026lt;personne\u0026gt;. Voici un exemple simple de document XML : \u0026lt;personne\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;42\u0026lt;/age\u0026gt; \u0026lt;/personne\u0026gt; Le XML est très présent sur le web et les documents XML peuvent être affichés par la plupart des navigateurs récents. On échange aussi le XML entre des logiciels et des serveurs sur le web, et le XML est de plus en plus utilisé en bureautique, comme format pour les traitements de texte par exemple. Comme un document XML est avant tout du texte, il n'est pas avantageux d'utiliser le XML pour stocker des informations de type multimédia (vidéo, musique); le champ d'application du XML demeure toutefois très vaste. Le XML définit une grammaire stricte et relativement simple de manière que les outils XML génériques puissent traiter tous les documents XML, peu importe leur domaine d'application. On dit d'un document qui respecte cette grammaire qu'il est bien formé . Ainsi, il n'est pas nécessaire d'utiliser des outils coûteux et propriétaires pour faire du XML. Une application possible du XML correspond au scénario suivant. Un groupe de personnes travaillant dans un domaine particulier, disons l'industrie de la construction, ont besoin d'échanger des informations, par exemple le prix et la description des matériaux. Elles doivent s'entendre sur un format informatique commun de manière que tous les logiciels, écrits ou utilisés par les différents participants, puissent communiquer entre eux, sans problème. L'information pourra ainsi être transmise sans intervention humaine. Concrètement, on utilise le XML dans le contexte d'une application XML . Une application XML est un jeu de balises et son utilisation dans un domaine particulier, par exemple la musique ou la cuisine. On peut définir un jeu de balises et, dans une certaine mesure, son utilisation en se servant d'un document DTD, Relax NG ou XML Schema (sujets que nous étudierons plus tard dans le cours). Dans un sens, une application XML forme un langage. On dit d'un document XML qui respecte les normes d'une application XML donnée qu'il est valide . Un document valide doit toujours être bien formé en plus de respecter les contraintes de l'application. En théorie, on pourrait penser que l'importance du XML est mineure. En effet, n'est-il pas facile de s'entendre sur des formats communs? L'expérience montre que ce n'est pas si facile. D'abord, définir avec rigueur un format de données est complexe. D'autre part, le développement de logiciels particuliers à chaque format est coûteux : avec un métalangage comme XML, on peut réutiliser souvent les mêmes librairies logicielles. Finalement, il est plus facile de trouver des experts en XML que des experts dans un format de données, format particulier à un domaine pointu. Le XML n'est pas un langage de programmation bien qu'on puisse l'utiliser avec des langages comme Java. On se sert par contre du XML pour les fichiers de configuration des logiciels. Par exemple, il est possible que, si vous utilisez un serveur web dans votre entreprise, ce serveur ait des fichiers de configuration en XML. Un document XML ne fait rien : ce n'est qu'une source passive d'informations, comme n'importe quel document, comme des pages web. On peut bien sûr programmer en utilisant une syntaxe XML cependant : nous verrons plus tard dans le cours comment programmer en XSLT. Mais, encore une fois, le fichier XML ne fait rien en lui-même si ce n'est que représenter le programme. Le XML met à profit un principe essentiel à l'architecture du web : be conservative in what you do, be liberal in what you accept from others (soyez strict dans ce que vous produisez, mais généreux dans ce que vous acceptez). En d'autres mots, le XML fonctionne parce que les gens tentent le plus possible de produire du XML de qualité (bien formé et valide), mais ils acceptent que les autres fassent des entorses aux règles. C'est, en partie, ce qu'on entend lorsqu'on dit que le XML est « extensible ». Cette règle est parfois appelée la loi de Postel parce qu'elle fut rédigée par Jon Postel dans la spécification RFC 793 . Par exemple, supposons que vous écriviez un logiciel qui s'attend à recevoir des commandes ayant la forme suivante. \u0026lt;commande\u0026gt; \u0026lt;produit\u0026gt;papier\u0026lt;/produit\u0026gt; \u0026lt;quantite\u0026gt;2\u0026lt;/quantite\u0026gt; \u0026lt;/commande\u0026gt; Supposons maintenant que le logiciel qui émet les commandes est mis à jour et qu'il vous transmet dorénavant les commandes sous le format suivant. \u0026lt;commande\u0026gt; \u0026lt;produit\u0026gt;papier\u0026lt;/produit\u0026gt; \u0026lt;quantite\u0026gt;2\u0026lt;/quantite\u0026gt; \u0026lt;emballage\u0026gt;oui\u0026lt;/emballage\u0026gt; \u0026lt;/commande\u0026gt; Selon les principes du XML, votre logiciel doit continuer à fonctionner, il doit ignorer le nouvel élément qu'il ne connaît pas. En d'autres mots, votre logiciel doit être généreux et ne pas exiger une conformité parfaite. Tant qu'il dispose des informations dont il a besoin, votre logiciel doit continuer à fonctionner. C'est ce principe fondateur qui permet à des millions de personnes d'utiliser le XML pour s'échanger des données sans le moindre arbitrage. Plus généralement, les technologies XML tentent de fonctionner le plus correctement possible même si les données ne correspondent pas à ce qu'on attendait. Plus généralement, le XML respecte plusieurs principes fondamentaux: Il est facile d'entretenir et modifier au fil du temps une application basée sur XML. Le XML est modulaire : on peut décomposer les applications en plusieurs fichiers, on peut traiter séparément différents morceaux d'un même document XML. Les spécifications XML minimisent la redondance sans la réduire à néant : il y a plusieurs façons de faire une même chose en XML, mais ce nombre est généralement limité. On a souvent le choix entre plusieurs stratégies, mais pas un trop grand nombre. Les technologies XML tiennent compte des personnes ayant des handicaps, notamment parce que plusieurs modes de présentation sont possibles. Le XML ne dépend pas d'une plate-forme particulière : que vous utilisiez Linux, Mac OS ou Windows, vous pouvez travailler avec le XML. Le XML est international : le XML supporte toutes les langues, pas seulement l'anglais. Le XML est extensible : on peut facilement faire évoluer les formats sans avoir à réécrire tous nos logiciels. Il est facile d'apprendre les fondements de base du XML. Il est facile pour un humain de lire du XML. Le XML est efficace : un ordinateur peu puissant peut traiter du XML rapidement. Le XML est un format textuel. Le XML est simple. La spécification technique de base tient sur quelques pages. Le XML assure la pérennité des informations. Le XML permet l'interopérabilité des systèmes. Un document XML peut être réutilisé facilement à plusieurs fins. Le XML est stable : les spécifications ne changent pas trop souvent. Le XML est universel : c'est un métalangage qui s'applique à un grand nombre de problèmes. Le XML n'est pas une nouveauté scientifique. Le XML représente, par contre, un pas en avant parce que c'est un des rares méta-langages universel. Le XML est aussi fondé sur des principes importants comme la pérennité, la simplicité, etc. qui ne sont pas toujours présents en technologie de l'information. "},{"id":4,"href":"/orientee_donnees/docs/modules/b_module_xml/rdf/introduction_au_rdf/","title":"Introduction au RDF","section":"RDF","content":" Introduction au RDF Introduction Le Resource Description Framework (RDF) est un langage pour les métadonnées sur le web, c'est-à-dire un langage pour énoncer ce que l'on sait sur quelque chose ou quelqu'un. Par exemple, le RDF est idéal pour indiquer qui est l'auteur d'un document ou quel est le titre du document. De plus, le langage RDF est prévu pour être à la fois simple (mais tout est relatif), suffisamment puissant pour « tout » décrire, et facilement utilisable par des logiciels. Dans le deuxième texte que nous proposons, nous verrons quelques applications intéressantes. Pour l'instant, nous ne présentons dans ce texte que les concepts de base. Notions de base Le RDF a été normalisé en 1999 (par une recommandation W3C) et est un effort commun de plusieurs experts. Le RDF se veut suffisamment riche pour représenter de façon formelle la connaissance tout en étant simple à utiliser. Une des prémisses du format RDF est que tout peut être énoncé en utilisant des triplets : sujet, verbe et objet . Notez que certains auteurs utiliseront le terme « prédicat » au lieu du terme « verbe ». Par exemple, pour décrire « Jean », nous dirons que « Jean est un garçon » et nous décomposerons ainsi cette affirmation : (Jean)(est)(garçon)]]\u0026gt;, ou l'afficherons dans un tableau : Sujet Verbe Objet Jean est garçon Nous ne faisons pas de la grammaire, mais bien de la représentation : le verbe n'a pas à être un verbe de la langue française ou anglaise. L'important est que le verbe soit un lien, une relation, entre une première chose (sujet) et une seconde (objet). Par exemple, si nous voulons affirmer que le titre de la page web « http://lemire.me/ » est « Daniel Lemire's blog », nous pouvons le faire à l'aide du tableau suivant : Sujet Verbe Objet http://lemire.me/ titre Daniel Lemire's blog Ces exemples de représentation ne sont pas encore des exemples de données « RDF », car en RDF, le verbe doit être un « URI ». Le RDF, tout comme le XML, est fait pour être traité par des machines et les machines sont bêtes. Elles ne savent pas ce que signifie le mot « titre » dans le tableau précédent. Est-ce un titre à la Bourse, le titre d'une fonction (comme docteur) ou le titre d'une page? Pour régler ce problème, il faut utiliser des URI ( Uniform Resource Identifier ), c'est-à-dire des adresses fictives qui identifient une ressource Internet. Un URI contient un protocole (http, mailto, ftp, etc.), un domaine comme « fichiers.com » et un chemin comme « /mesfichiers/index.html ». Dans ce cours, nous adoptons la norme RFC2396 et nous permettons que les URI comportent le symbole du dièse ( # ), comme « ftp://fichiers.com#maman » : tout ce qui apparaît après ce symbole forme le « fragment ». Notons que les accents ne peuvent pas être utilisés dans un URI; ainsi, « http://école.com » n'est pas un URI valable. Un protocole particulier, « urn », est parfois utilisé dans les URI. Par exemple, pour identifier un livre par son code ISBN, nous pouvons utiliser l'URI « urn:ISBN:0-123-12345-1 ». La casse est significative dans un URI sauf pour le nom du protocole (HTTP ou http) et le nom du domaine (xerox.com ou XEROX.COM). Toutes les URL ( Uniform Resource Locator ) utilisées sur le web, comme « http://www.google.com », « mailto:bill@microsoft.com », « ftp://fichiers.com », ainsi que d'autres adresses ayant la même syntaxe, mais qui ne pointent pas nécessairement vers une ressource Internet existante, sont des exemples d'URI. Ainsi, si l'on vous donne l'URI « http://www.mydomain.com/daniel », il n'est pas certain qu'une page web se trouve à cette adresse. Le seul but des URI est d'identifier des ressources. Le mot « ressource » a un sens très, très large : tout peut être considéré comme une ressource. Par exemple, pour identifier l'humoriste « Daniel Lemire », nous pouvons adopter l'URI « http://www.daniellemire.com/luimeme »; ce sera un bon choix si l'humoriste en question est propriétaire du nom de domaine (daniellemire.com) et compte le garder longtemps. Par ailleurs, on pourra utiliser l'URI « http://lemire.me/fr/ » pour identifier le professeur « Daniel Lemire » qui est responsable d'un cours portant sur le XML. Dans ce dernier exemple, l'URI est aussi un URL qui pointe vers la page personnelle du professeur. Nous voyons immédiatement l'avantage des URI : alors que l'ordinateur ne saura pas toujours faire la différence entre « Daniel Lemire » l'humoriste et « Daniel Lemire » le professeur, nous pourrons, en utilisant des URI, analyser automatiquement l'information, à la condition que tous utilisent le même URI pour représenter la même ressource. Pour distinguer les individus, nous pourrions utiliser leur numéro d'assurance sociale... Mais comme le concept de ressource est général, il faut aussi pouvoir distinguer les différentes significations que peuvent prendre le mot « titre », et ainsi de suite. La langue française (ou anglaise) permet à un mot d'avoir plusieurs sens, alors que chaque URI représente un concept et un concept seulement. L'URI n'a pas en soit un sens particulier. C'est un nom. Ainsi « http://google.com/2000/jacques/ » peut ne rien à voir avec l'an 2000 ou une personne appelée Jacques... tout comme un homme appelé Pierre n'a pas à travailler sur des pierres ou qu'une personne appelée Meunier n'a pas à être meunier. Supposons maintenant que nous voulions décrire l'affirmation suivante en RDF : « Il y a une personne appelée Daniel Lemire dont l'adresse de courriel est lemire@gmail.com et qui est professeur. » Cette phrase peut être très difficile à analyser par un ordinateur. Commençons par la décomposer en affirmations simples : sujet/verbe/objet. D'abord, pour qu'il n'y ait pas de confusion, nous allons identifier l'individu s'appelant Daniel Lemire par l'URI « http://lemire.me/fr/ ». http://lemire.me/fr/ est une personne. http://lemire.me/fr/ s'appelle Daniel Lemire. http://lemire.me/fr/ peut être joint par courriel à lemire@gmail.com. http://lemire.me/fr/ a le titre de professeur. Rappelons ici que tous les verbes et tous les sujets doivent être identifiés par des URI. En ce qui nous concerne, il n'y a qu'un seul sujet identifié par « http://lemire.me/fr/ ». Il reste à trouver des URI pour les verbes et certains objets. Prenons d'abord la première affirmation : « http://lemire.me/fr/ est une personne ». Le verbe « être », dans cette phrase, associe la classe « personne » (au même sens que dans la programmation orientée objet) à la ressource « http://lemire.me/fr/ ». Nous pourrions inventer un URI ayant ce sens, mais il en existe déjà un : « http://www.w3.org/1999/02/22-rdf-syntax-ns#type ». Chaque fois que nous rencontrons cet URI, cela signifie qu'une ressource appartient à une certaine classe. Quant à l'objet « personne », il existe au moins un URI pour noter la classe « personne », soit « http://www.w3.org/2000/10/swap/pim/contact#Person ». Nous verrons que dans d'autres contextes, d'autres URI peuvent être utilisés avec un sens similaire. Finalement, l'affirmation « http://lemire.me/fr/ est une personne » peut s'écrire comme ceci : Sujet Verbe Objet http://lemire.me/ fr/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://www.w3.org/2000/ 10/swap/pim/contact#Person Passons maintenant à la deuxième affirmation : « http://lemire.me/fr/ s'appelle Daniel Lemire ». Le verbe « s'appelle » peut être identifié par l'URI « http://www.w3.org/2000/10/swap/pim/contact#fullName ». Encore une fois, nous aurions pu inventer notre propre URI, en autant que nous utilisons toujours le même avec la même signification. L'objet, « Daniel Lemire », n'a pas de signification particulière et n'est qu'une chaîne de caractères; nous ne sommes donc pas tenus d'utiliser un URI. Cela n'est vrai que pour les objets : les sujets et les verbes doivent toujours être représentés par des URI en RDF. Nous obtenons le tableau suivant : Sujet Verbe Objet http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#fullName \"Daniel Lemire\" Nous notons les chaînes de caractères avec les guillemets : alors que « http://www.unuri.org » est un URI, « \"http://www.unuri.org\" » est une chaîne de caractères. Dans l'affirmation « http://lemire.me/fr/ peut être joint par courriel à lemire@gmail.com », nous pouvons remplacer le verbe par « http://www.w3.org/2000/10/swap/pim/contact#mailbox ». Quant à l'objet « lemire@gmail.com », c'est une adresse de courriel; afin qu'un ordinateur puisse comprendre qu'il s'agit d'une adresse de courriel et non d'une chaîne de caractères, nous utiliserons l'URL « mailto:lemire@gmail.com » pour le représenter. Nous avons donc le tableau suivant : Sujet Verbe Objet http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#mailbox mailto:lemire@gmail.com L'affirmation « http://lemire.me/fr/ a le titre de professeur » se traite de la même manière, de telle sorte que nous obtenons finalement le tableau suivant : Sujet Verbe Objet http://lemire.me/ en/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://www.w3.org/2000/ 10/swap/pim/contact#Person http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#fullName \"Daniel Lemire\" http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#mailbox mailto:lemire@gmail.com http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#personalTitle \"Professeur\" Précisons qu'en RDF, l'ordre des affirmations est sans importance. Ainsi, l'ordre des rangées dans le tableau est sans importance. Ce tableau est une description formelle de notre phrase d'origine « Il y a une personne appelée Daniel Lemire dont l'adresse de courriel est lemire@gmail.com et qui est professeur. »; cette description peut être traitée par un ordinateur. Comme nous le verrons plus loin, ce tableau RDF peut s'écrire en XML de la façon suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:contact=\"http://www.w3.org/2000/10/swap/pim/contact#\"\u0026gt; \u0026lt;contact:Person rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;contact:fullName\u0026gt;Daniel Lemire\u0026lt;/contact:fullName\u0026gt; \u0026lt;contact:mailbox rdf:resource=\"mailto:lemire@gmail.com\"/\u0026gt; \u0026lt;contact:personalTitle\u0026gt;Professeur\u0026lt;/contact:personalTitle\u0026gt; \u0026lt;/contact:Person\u0026gt; \u0026lt;/rdf:RDF\u0026gt; On peut aussi représenter graphiquement le tableau RDF : ../module5/dlprof.pdf http://www.daniel-lemire.com/fr/ http://www.daniel-lemire.com/fr/ Person Person http://www.daniel-lemire.com/fr/-\u0026gt;P erson Type Daniel Lemire Daniel Lemire http://www.daniel-lemire.com/fr/-\u0026gt;D aniel Lemire fullName lemire@gmail.com lemire@gmail.com http://www.daniel-lemire.com/fr/-\u0026gt;d lemire@teluq.ca mailbox Professeur Professeur http://www.daniel-lemire.com/fr/-\u0026gt;P rofesseur personalTitle Nous pouvons également spécifier dans quelle langue une chaîne de caractères est écrite; par exemple, le mot « professeur » n'a de sens qu'en français. Pour ce faire, nous utiliserons un attribut « xml:lang » ayant pour valeur un code ISO à deux caractères pour représenter la langue : « fr » pour français, « en » pour anglais, et ainsi de suite. Notre exemple modifié se lit comme suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:contact=\"http://www.w3.org/2000/10/swap/pim/contact#\"\u0026gt; \u0026lt;contact:Person rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;contact:fullName\u0026gt;Daniel Lemire\u0026lt;/contact:fullName\u0026gt; \u0026lt;contact:mailbox rdf:resource=\"mailto:lemire@gmail.com\"/\u0026gt; \u0026lt;contact:personalTitle xml:lang=\"fr\"\u0026gt;Professeur\u0026lt;/contact:personalTitle\u0026gt; \u0026lt;/contact:Person\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Le choix de la langue ne constitue pas une nouvelle relation RDF, mais vient simplement annoter l'objet : dans un tableau sujet/verbe/objet, nous nous contenterons, par exemple, de remplacer « \"Professeur\" » par « \"Professeur\" (français) ». Nous pouvons résumer le RDF comme ceci : Le RDF peut être utilisé pour représenter tout objet, tant un site web qu'un individu. Le RDF peut être traité par une machine. Le RDF est composé de triplets : sujet/verbe/objet. Le sujet est toujours identifié par un URI; mais dans certains cas, on peut omettre l'URI et alors, un URI factice sera généré dynamiquement. Le verbe est toujours identifié par un URI, sans aucune exception. L'objet est soit un URI, soit une valeur explicite (une chaîne de caractères, par exemple). Le RDF peut être représenté en XML. Le RDF en XML Avertissement.- Tous les contenus RDF ne peuvent être représentés en XML selon la méthode que nous venons de présenter. La grande majorité du contenu RDF peut l'être, mais il y a des exceptions. Pour éviter les problèmes, nous supposerons ici que l'URI du verbe prend la forme « http://www.domaine.com/blabla/bla#vvv ». En d'autres termes, l'URI du verbe contient le symbole du dièse ( # ) et le texte après ce symbole est un nom XML valable (pouvant être utilisé comme balise). Il existe plusieurs façons de représenter le RDF en XML, mais nous n'étudierons que l'approche préconisée par le W3C, qui est l'approche la plus courante. Par ailleurs, nous n'étudierons pas toute la syntaxe RDF/XML, mais seulement ce qui est nécessaire pour comprendre la majorité du RDF qui se trouve actuellement sur le web. En règle générale, les documents XML représentant du contenu RDF n'ont pas de DTD, mais utilisent les espaces de noms. Nous commençons habituellement un document par une déclaration XML qui sera soit « \u0026lt;?xml version=\"1.0\"?\u0026gt; », soit « \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; » pour permettre l'utilisation des accents français. Ensuite, viendra toujours l'élément RDF comme élément-racine. Ainsi, un des documents XML les plus simples possibles représentant du contenu RDF est : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Observez l'utilisation de l'espace de noms identifié par l'URI « http://www.w3.org/1999/02/22-rdf-syntax-ns# ». Le fait de noter l'espace de noms par les trois lettres « rdf » est sans conséquence et nous pourrions aussi écrire : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;nimportequoidautre:RDF xmlns:nimportequoidautre=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;/nimportequoidautre:RDF\u0026gt; L'important, c'est que l'élément-racine RDF soit dans l'espace de nom « http://www.w3.org/1999/02/22-rdf-syntax-ns# ». Supposons maintenant que nous voulions décrire l'affirmation RDF suivante : Sujet Verbe Objet http://lemire.me/fr/ http://www.w3.org/2000/ 10/swap/pim/contact#mailbox mailto:lemire@gmail.com La première étape consiste à décomposer l'URI du verbe en deux parties : l'URI jusqu'au symbole « # » inclusivement, soit « http://www.w3.org/2000/10/swap/pim/contact# », et le reste du texte, soit « mailbox ». La première partie devient un espace de noms, et la deuxième, appelée fragment, deviendra un nom d'élément. On utilise ensuite habituellement une balise « Description » dans l'espace de noms « http://www.w3.org/1999/02/22-rdf-syntax-ns# » avec le nom d'attribut « about » comme ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;mailbox rdf:resource=\"mailto:lemire@gmail.com\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Dans cet exemple, le sujet est la valeur d'attribut de « about », soit « http://lemire.me/fr/ », le verbe est le nom de l'élément contenu dans l'élément « rdf:Description », ici « mailbox », auquel on ajoute en préfixe l'espace de noms auquel il appartient, soit « http://www.w3.org/2000/10/swap/pim/contact# ». L'URI de l'objet est la valeur de l'attribut « rdf:resource », soit « mailto:lemire@gmail.com ». Pour nous assurer de bien comprendre, voyons un autre exemple, quoique plus abstrait. Supposons que nous ayons le contenu RDF suivant : Sujet Verbe Objet http://domaine.com/page/ http://domaine.com#unverbe http://www.objet.com/ Nous pourrions utiliser la représentation XML suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://domaine.com#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://domaine.com/page/\"\u0026gt; \u0026lt;unverbe rdf:resource=\"http://www.objet.com/\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Que devons-nous faire si l'objet n'est pas un URI, mais une chaîne de caractères? Dans ce cas, nous omettrons l'attribut « rdf:resource » et nous placerons notre valeur dans l'élément. Ainsi, pour représenter le contenu RDF suivant : Sujet Verbe Objet http://lemire.me/fr/ http://www.w3.org/2000/ 10/swap/pim/contact#personalTitle \"Professeur\" nous pourrons utiliser le code XML qui suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;personalTitle\u0026gt;Professeur\u0026lt;/personalTitle\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Encore une fois, les conventions relatives aux espaces de noms s'appliquent et nous pourrions remplacer le XML de l'exemple précédent par celui-ci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:espacedenom=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:personalTitle\u0026gt;Professeur\u0026lt;/espacedenom:personalTitle\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Donc, pour représenter l'ensemble des données RDF suivantes : Sujet Verbe Objet http://lemire.me/fr/ http://www.w3.org/2000/ 10/swap/pim/contact#fullName \"Daniel Lemire\" http://lemire.me/fr/ http://www.w3.org/2000/ 10/swap/pim/contact#mailbox mailto:lemire@gmail.com http://lemire.me/fr/ http://www.w3.org/2000/ 10/swap/pim/contact#personalTitle \"Professeur\" nous utiliserons plusieurs éléments, les uns à la suite des autres, comme ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:espacedenom=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:fullName\u0026gt;Daniel Lemire\u0026lt;/espacedenom:fullName\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:mailbox rdf:resource=\"mailto:lemire@gmail.com\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:personalTitle\u0026gt;Professeur\u0026lt;/espacedenom:personalTitle\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; En pratique toutefois, nous ne répétons pas l'élément « Description » avec la même valeur d'attribut « about »; nous préférons la syntaxe qui suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:espacedenom=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:fullName\u0026gt;Daniel Lemire\u0026lt;/espacedenom:fullName\u0026gt; \u0026lt;espacedenom:mailbox rdf:resource=\"mailto:lemire@gmail.com\" /\u0026gt; \u0026lt;espacedenom:personalTitle\u0026gt;Professeur\u0026lt;/espacedenom:personalTitle\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Et comme l'ordre est sans importance en RDF, nous pourrions aussi avoir le XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:espacedenom=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;espacedenom:personalTitle\u0026gt;Professeur\u0026lt;/espacedenom:personalTitle\u0026gt; \u0026lt;espacedenom:fullName\u0026gt;Daniel Lemire\u0026lt;/espacedenom:fullName\u0026gt; \u0026lt;espacedenom:mailbox rdf:resource=\"mailto:lemire@gmail.com\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Les classes en RDF Jusqu'à présent, nous n'avons pas représenté en XML l'affirmation suivante : Sujet Verbe Objet http://lemire.me/fr/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://www.w3.org/2000/ 10/swap/pim/contact#Person Évidemment, nous pouvons tout simplement écrire ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;rdf:type rdf:resource=\"http://www.w3.org/2000/10/swap/pim/contact#Person\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Mais, avouons-le, c'est assez peu lisible. Dans « http://www.w3.org/2000/10/swap/pim/contact#Person », « Person » est un fragment. Dans les cas où l'URI contient un fragment, nous représentons l'affirmation de la façon suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/10/swap/pim/contact#\" \u0026gt; \u0026lt;Person rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;/Person\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Nous remplaçons « rdf:Description » par le nom de la classe, soit « Person », avec le préfixe « http://www.w3.org/2000/10/swap/pim/contact# ». En pratique, cette dernière approche est presque toujours utilisée et son avantage devient évident quand on combine toutes les affirmations RDF de la première section : Sujet Verbe Objet http://lemire.me/ en/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://www.w3.org/2000/ 10/swap/pim/contact#Person http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#fullName \"Daniel Lemire\" http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#mailbox mailto:lemire@gmail.com http://lemire.me/ en/ http://www.w3.org/2000/ 10/swap/pim/contact#personalTitle \"Professeur\" Nous savons maintenant que nous pouvons représenter toutes ses informations par le XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/10/swap/pim/contact#\"\u0026gt; \u0026lt;Person rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;fullName\u0026gt;Daniel Lemire\u0026lt;/fullName\u0026gt; \u0026lt;mailbox rdf:resource=\"mailto:lemire@gmail.com\" /\u0026gt; \u0026lt;personalTitle\u0026gt;Professeur\u0026lt;/personalTitle\u0026gt; \u0026lt;/Person\u0026gt; \u0026lt;/rdf:RDF\u0026gt; C'est comme ça que nous pouvons écrire « Il y a une personne appelée Daniel Lemire dont l'adresse de courriel est lemire@gmail.com et qui est professeur. » en RDF/XML. Et s'il n'y a pas de symbole « # » dans l'URI? Dans les exemples précédents, nous supposions que l'URI (du verbe) contenait un symbole « # », ce qui nous permettait de la décomposer en deux parties (nom et préfixe). Mais quoi faire si l'URI prend plutôt la forme « http://www.ondelette.com/employeur »? Dans un tel cas, nous pouvons choisir de retenir « http://www.ondelette.com/ » comme préfixe et « employeur » comme nom. Nous pourrons donc représenter les données RDF suivantes : Sujet Verbe Objet http://lemire.me/fr/ http://www.ondelette.com/employeur http://www.uquebec.ca/ par le XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.ondelette.com/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://lemire.me/fr/\"\u0026gt; \u0026lt;employeur rdf:resource=\"http://www.uquebec.ca/\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Des objets qui sont eux-mêmes des sujets Supposons que nous voulons dire que la pièce de théatre Othello a comme auteur William Shakespeare. En fait, nous voulons faire quatre affirmations : « Othello est une pièce de théatre », « Shakespeare est une personne », « Shakespeare est l'auteur d'Othello » et « Shakespeare a pour nom \"William Shakespeare\" ». Nous pourrions choisir de représenter en RDF ces quatre affirmations selon le tableau qui suit : Sujet Verbe Objet http://www.othello.org/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://unuri.org/PieceDeTheatre http://www.othello.org/ http://unuri.org/auteur http://www.shakespeare.org http://www.shakespeare.org http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://unuri.org/Personne http://www.shakespeare.org http://unuri.org/nom \"William Shakespeare\" Nous pouvons utiliser la représentation XML suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://unuri.org/\"\u0026gt; \u0026lt;PieceDeTheatre rdf:about=\"http://www.othello.org/\"\u0026gt; \u0026lt;auteur rdf:resource=\"http://www.shakespeare.org\" /\u0026gt; \u0026lt;/PieceDeTheatre\u0026gt; \u0026lt;Personne rdf:about=\"http://www.shakespeare.org\"\u0026gt; \u0026lt;nom\u0026gt;William Shakespeare\u0026lt;/nom\u0026gt; \u0026lt;/Personne\u0026gt; \u0026lt;/rdf:RDF\u0026gt; La représentation graphique du tableau RDF est : ../module5/othello.pdf http://www.othello.org/ http://www.othello.org/ PieceDeTheatre PieceDeTheatre http://www.othello.org/-\u0026gt;PieceDeTheatre type http://www.shakespeare.org http://www.shakespeare.org http://www.othello.org/-\u0026gt;http://www.shakespeare.org auteur Personne Personne http://www.shakespeare.org-\u0026gt;Personne type William Shakespeare William Shakespeare http://www.shakespeare.org-\u0026gt;William Shakespeare nom Nous pouvons cependant le faire plus brièvement. Considérons d'abord le modèle suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://unuri.org/\"\u0026gt; \u0026lt;PieceDeTheatre rdf:about=\"http://www.othello.org/\"\u0026gt; \u0026lt;auteur\u0026gt; (...) \u0026lt;/auteur\u0026gt; \u0026lt;/PieceDeTheatre\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Nous avons vu que si nous mettons un nœud de texte là où les points « (...) » apparaissent, nous associerons « http://www.othello.org/ » avec un objet texte par le verbe « http://unuri.org/auteur ». Cependant, si nous mettons plutôt un élément muni d'un attribut « rdf:about », ce sera l'URI contenu dans l'attribut qui deviendra l'objet; nous gagnons alors la possibilité d'utiliser ce même objet comme sujet à son tour, comme dans cet exemple : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://unuri.org/\"\u0026gt; \u0026lt;PieceDeTheatre rdf:about=\"http://www.othello.org/\"\u0026gt; \u0026lt;!-- le verbe est http://unuri.org/auteur --\u0026gt; \u0026lt;auteur\u0026gt; \u0026lt;!-- début de l'objet --\u0026gt; \u0026lt;Personne rdf:about=\"http://www.shakespeare.org\"\u0026gt; \u0026lt;!-- l'objet devient un sujet à son tour --\u0026gt; \u0026lt;nom\u0026gt;William Shakespeare\u0026lt;/nom\u0026gt; \u0026lt;/Personne\u0026gt;\u0026lt;!-- fin de l'objet --\u0026gt; \u0026lt;/auteur\u0026gt; \u0026lt;/PieceDeTheatre\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Ce nouveau document RDF est équivalent aux trois affirmations RDF du début, mais il est un peu plus court. Nous pourrions pousser l'expérience plus loin - ce qui peut devenir absurde - comme dans l'exemple qui suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://unuri.org/\"\u0026gt; \u0026lt;PieceDeTheatre rdf:about=\"http://www.othello.org/\"\u0026gt; \u0026lt;auteur rdf:resource=\"http://www.shakespeare.org\" /\u0026gt; \u0026lt;/PieceDeTheatre\u0026gt; \u0026lt;Personne rdf:about=\"http://www.shakespeare.org\"\u0026gt; \u0026lt;nom\u0026gt; \u0026lt;Texte rdf:about=\"http://www.texte.org/william\"\u0026gt; \u0026lt;contenu\u0026gt; William Shakespeare \u0026lt;/contenu\u0026gt; \u0026lt;/Texte\u0026gt; \u0026lt;/nom\u0026gt; \u0026lt;/Personne\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Ce document est maintenant équivalent au tableau suivant : Sujet Verbe Objet http://www.othello.org/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://unuri.org/PieceDeTheatre http://www.othello.org/ http://unuri.org/auteur http://www.shakespeare.org http://www.shakespeare.org http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://unuri.org/Personne http://www.texte.org/william http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://unuri.org/Texte http://www.texte.org/william http://unuri.org/contenu \"William Shakespeare\" http://www.shakespeare.org http://unuri.org/nom http://www.texte.org/william Les contenants en RDF Il arrive fréquemment, en pratique, que l'on doive donner comme valeur à un objet, non pas une chaîne de caractères, mais plutôt un ensemble de chaînes de caractères. Par exemple, nous pouvons vouloir affirmer que « les étudiants du cours 101 sont Jean Roberge, Alexandre Coma et Julie LeChat ». Comment le faire? Supposons que l'URI du cours est « http://www.teluq.ca/101 » et que le verbe correspondant à « être inscrit à un cours » est identifié par l'URI « http://www.education.com#inscription ». Nous pouvons alors essayer ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.education.com#\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.teluq.ca/101\"\u0026gt; \u0026lt;inscription\u0026gt;Jean Roberge\u0026lt;/inscription\u0026gt; \u0026lt;inscription\u0026gt;Alexandre Coma\u0026lt;/inscription\u0026gt; \u0026lt;inscription\u0026gt;Julie LeChat\u0026lt;/inscription\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Cela équivaut à remplacer l'affirmation « les étudiants du cours 101 sont Jean Roberge, Alexandre Coma et Julie LeChat » par les trois affirmations « le cours 101 a comme étudiant Jean Roberge », « le cours 101 a comme étudiant Alexandre Coma », « le cours 101 a comme étudiant Julie LeChat ». Il n'est pas certain qu'une telle décomposition de l'affirmation préserve toujours le sens original. Par exemple, nous pourrions vouloir donner la liste complète de tous les étudiants dans le cours. RDF nous permet de regrouper tous les étudiants dans un seul élément « Bag » (sac, en anglais) comme ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.education.com#\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.teluq.ca/101\"\u0026gt; \u0026lt;inscription\u0026gt; \u0026lt;rdf:Bag\u0026gt; \u0026lt;rdf:li\u0026gt;Jean Roberge\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;Alexandre Coma\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;Julie LeChat\u0026lt;/rdf:li\u0026gt; \u0026lt;/rdf:Bag\u0026gt; \u0026lt;/inscription\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Les éléments dans un « Bag » ne sont pas ordonnés. Nous pourrons remplacer le XML précédent par celui-ci, sans problème : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.education.com#\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.teluq.ca/101\"\u0026gt; \u0026lt;inscription\u0026gt; \u0026lt;rdf:Bag\u0026gt; \u0026lt;rdf:li\u0026gt;Julie LeChat\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;Jean Roberge\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;Alexandre Coma\u0026lt;/rdf:li\u0026gt; \u0026lt;/rdf:Bag\u0026gt; \u0026lt;/inscription\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Si l'ordre importe, alors nous utiliserons un élément « Seq » (pour séquence), comme dans l'exemple suivant qui énonce les jours de la semaine, dans l'ordre : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.jourdelasemaine.com#\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.jourdelasemaine.com/\"\u0026gt; \u0026lt;journees\u0026gt; \u0026lt;rdf:Seq\u0026gt; \u0026lt;rdf:li\u0026gt;dimanche\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;lundi\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;mardi\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;mercredi\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;jeudi\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;vendredi\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;samedi\u0026lt;/rdf:li\u0026gt; \u0026lt;/rdf:Seq\u0026gt; \u0026lt;/journees\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Finalement, nous pourrions ne pas connaître exactement la valeur de l'objet, mais savoir que la valeur appartient à un ensemble fini de possibilités. Par exemple, si nous jouons à un jeu de détective et qu'il n'y a que trois coupables possibles (le majordome, la princesse et le seigneur), nous écrirons : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.jeududetective.com#\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.jeududetective.com/partie/2004/10/\"\u0026gt; \u0026lt;suspects\u0026gt; \u0026lt;rdf:Alt\u0026gt; \u0026lt;rdf:li\u0026gt;majordome\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;princesse\u0026lt;/rdf:li\u0026gt; \u0026lt;rdf:li\u0026gt;seigneur\u0026lt;/rdf:li\u0026gt; \u0026lt;/rdf:Alt\u0026gt; \u0026lt;/suspects\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; RDFa Il peut sembler un peu lourd de créer des fichiers XML distincts pour stocker le RDF. Heureusement, il existe donc plusieurs approches pour inscrire le RDF à même des fichiers XHTML. La spécification RDFa permet d'inscrire du RDF directement au sein d'un document XHTML avec les attributs about et property. Voici un exemple d'annotation RDFa ajoutée à un élément XHTML : \u0026lt;ul xmlns:dc=\"http://purl.org/dc/elements/1.1/\" about=\"http://www.example.com/books/wikinomics\"\u0026gt; \u0026lt;li property=\"dc:title\"\u0026gt;Wikinomics\u0026lt;/li\u0026gt; \u0026lt;li property=\"dc:author\"\u0026gt;Don Tapscott\u0026lt;/li\u0026gt; \u0026lt;li property=\"dc:date\"\u0026gt;2006-10-01\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; Conclusion Nous avons vu que le modèle RDF sert à décrire pratiquement n'importe quoi en associant des URI à tous les objets et relations. Les données RDF peuvent généralement être représentées en XML selon l'approche que nous avons décrite, ce qui permet de combiner les avantages du XML (format entièrement normalisé et non propriétaire, outils très disponibles, etc.), tout en gardant les avantages du RDF (contenu pouvant être traité par des machines, relative simplicité). "},{"id":5,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/introduction_au_xslt/","title":"Introduction au XSLT","section":"XSLT","content":" Introduction au XSLT # Qu\u0026rsquo;est-ce que le XSLT # La première version du langage XSLT (Extensible Stylesheet Language Transformation) a été publiée en 1997 et elle est devenue une recommandation W3C en 1999. Elle fait partie du XSL (Extensible Stylesheet Language) qui comprend une seconde composante, les XSL-FO (Extensible Stylesheet Language Formatting Objects). La technologie XSL tire son origine du besoin d\u0026rsquo;un langage simple, mais suffisamment puissant pour pouvoir contrôler finement l\u0026rsquo;affichage du XML. On utilise beaucoup le XSLT sur le web et au sein des systèmes d\u0026rsquo;information, alors que le XSL-FO est davantage utile pour les applications de mise en page spécialisées.\nL\u0026rsquo;objectif poursuivi par le XSLT est de transformer les documents XML en d\u0026rsquo;autres documents. Par exemple, supposons que vous ayez le document suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; et que vous vouliez transformer ce type de document XML en document HTML qui aurait la forme suivante :\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de Jean Rochond\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;p\u0026gt;Ceci est une facture pour Jean Rochond de 10.10$ pour: Achat d\u0026#39;ordinateur.\u0026lt;/p\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Si votre entreprise utilise du XML et que vous désirez envoyer des factures par courriel, vous pourriez envoyer le document HTML au lieu du document XML. De cette manière, le client pourrait consulter sa facture sans avoir à comprendre le XML.\nOn pourrait bien sûr écrire un programme en Java qui effectuerait cette opération, mais la conception d\u0026rsquo;un programme Java prend du temps et on cherche parfois une solution plus économique, plus rapide. Avec l\u0026rsquo;exemple que nous venons de voir, on pourrait automatiser la transformation de XML en HTML en moins d\u0026rsquo;une quinzaine de minutes. Pour obtenir le résultat désiré, il faut utiliser un petit fichier XSLT. À la fin de cette semaine, vous devriez être capable de faire ce travail.\nLes documents XSLT # Le document XSLT contient des règles qu\u0026rsquo;un « processeur XSLT » applique aux documents XML pour les transformer. Heureusement, si vous utilisez un navigateur récent, vous avez déjà un processeur XSLT moderne à même votre navigateur. Lors de l\u0026rsquo;ouverture d\u0026rsquo;un document XML, votre navigateur tente automatiquement de trouver et d\u0026rsquo;exécuter un document XSLT pour transformer le document XML.\nUn processeur XSLT va parcourir les noeuds de votre document en commençant par l\u0026rsquo;élément-racine et, à chaque fois, il va tenter d\u0026rsquo;appliquer une règle. Certaines règles peuvent lui dire de continuer l\u0026rsquo;application des règles au sein des noeuds contenus dans un élément (avec l\u0026rsquo;instruction apply-template) alors que d\u0026rsquo;autres peuvent simplement extraire une information particulière.\nCommençons par créer le fichier XSLT suivant qu\u0026rsquo;on enregistrera sur le disque comme étant « xslt.xml » :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Ce document ne contient aucune « règle » et constitue le document XSLT de base.\nNous vous suggérons de faire l’exercice de création de ce document avec Bloc-notes, par exemple.\nUn document XSLT est un document XML bien formé, utilisant l’espace de noms « http://www.w3.org/1999/XSL/Transform » et ayant pour élément-racine stylesheet (ou transform), lequel a lui-même un attribut « version ».\nOn ne discute ici que de la première version de XSLT (1.0) ; on utilise donc 1.0 comme valeur d’attribut pour version.\nPrenons maintenant le fichier XML que nous avions auparavant ; modifions-le un peu en le faisant pointer vers le fichier XSLT nouvellement créé :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;xslt.xml\u0026#34; type=\u0026#34;application/xml\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; On ajoute donc la ligne : \u0026lt;?xml-stylesheet href=\u0026quot;xslt.xml\u0026quot; type=\u0026quot;application/xml\u0026quot;?\u0026gt;.\nCette ligne indique au navigateur, ou à un autre logiciel, que le document XML peut être transformé par le fichier XSLT nommé « xslt.xml ». Le chemin peut être relatif ou absolu : on pourrait donc aussi avoir une ligne comme :\n\u0026lt;?xml-stylesheet href=\u0026#34;http://www.mondomaine.com/xslt.xml\u0026#34; type=\u0026#34;application/xml\u0026#34;?\u0026gt; si l’URL « http://www.mondomaine.com/xslt.xml » pointe vers un fichier XSLT.\nDans un navigateur, on peut enregistrer ce nouveau document XML dans le même répertoire que le fichier « xslt.xml », disons avec le nom « test.xml », puis ouvrir le fichier « test.xml » dans votre navigateur ; il est malheureusement nécessaire de déposer les fichiers sur un serveur web pour que cela fonctionne, les développeurs craignant les failles de sécurité associées aux fichiers locaux. Heureusement, vous n’avez pas à faire ce travail : nous fournissons un outil en ligne qui vous permet de saisir vos fichiers XSLT et XML dans votre navigateur sans devoir créer de fichiers. Nous vous présenterons cet outil dans le prochain article. Ceux qui souhaitent travailler avec des fichiers directement peuvent utiliser un serveur web.\nUne fois le fichier XML chargé et la transformation XSLT appliquée, normalement, on ne devrait rien voir à l’écran (une page vide), car le document XSLT utilisé est vide de toute instruction et le résultat ne sera donc pas du HTML. Le résultat peut cependant varier selon le navigateur utilisé, car votre navigateur pourrait afficher le texte, même s’il ne s’agit pas de HTML : dans ce cas, vous ne verriez que le texte contenu dans le document XML, les balises en moins. Nous expliquerons bientôt pourquoi cela est le cas.\napplication de bureau java (optionnelle) # Nous avons préparé une application conviviale en Java qui vous permet d’appliquer une transformation XSLT à un document XML.\nNous vous invitons à la mettre à l’essai en suivant nos consignes.\n"},{"id":6,"href":"/orientee_donnees/docs/modules/","title":"Modules","section":"Docs","content":" Modules du cours # Ce cours est organisé en plusieurs modules thématiques qui vous guideront à travers les technologies essentielles du développement web et des données structurées. Chaque module combine théorie, exemples pratiques et exercices pour une apprentissage progressif.\nModule JSON # Le premier module explore le format JSON (JavaScript Object Notation), format léger d\u0026rsquo;échange de données. Vous découvrirez la syntaxe JavaScript moderne, les opérations de sérialisation et désérialisation JSON, ainsi que des outils pratiques comme jq pour la manipulation de données JSON en ligne de commande.\nContenu clé :\nSyntaxe JavaScript (variables, fonctions, objets, chaînes de caractères) Génération et consommation de JSON GeoJSON pour les données géographiques Bibliothèque Gson pour Java Encodage Unicode et Markdown Module XML # Ce module approfondit le langage XML et ses applications. Vous apprendrez à créer des documents XML bien formés, à les styler avec CSS, et à les traiter programmatiquement avec l\u0026rsquo;API DOM en Java et JavaScript.\nContenu clé :\nStructure et syntaxe XML Espaces de noms et validation (DTD, schémas) Traitement XML avec DOM Formats XML courants (RSS, sitemaps, AndroidManifest) RDF et SPARQL pour le web sémantique Module XSLT # Découvrez les transformations XSLT pour convertir des documents XML. Ce module couvre les feuilles de style XSLT, les templates, et les fonctions XPath pour extraire et transformer des données XML.\nContenu clé :\nSyntaxe XSLT et templates Fonctions XPath Transformations XML vers HTML XSLT dans les navigateurs Module HTML # Maîtrisez le langage HTML pour structurer le contenu web. Ce module couvre les balises essentielles, la sémantique HTML5, et l\u0026rsquo;intégration avec CSS et JavaScript pour créer des pages web modernes.\nContenu clé :\nStructure HTML5 Balises sémantiques Formulaires et médias Accessibilité web Module Services Web # Le dernier module traite des communications asynchrones avec AJAX. Vous apprendrez à charger des données XML et JSON de manière asynchrone, à gérer les APIs REST, et à développer des applications web interactives.\nContenu clé :\nProgrammation asynchrone (Promises, async/await) API fetch() pour les requêtes HTTP AJAX avec XML et JSON Gestion des erreurs et sécurité Outils de développement JavaScript Chaque module est conçu pour être autonome tout en contribuant à une compréhension globale des technologies web. N\u0026rsquo;hésitez pas à naviguer entre les modules selon vos intérêts et besoins d\u0026rsquo;apprentissage.\n"},{"id":7,"href":"/orientee_donnees/docs/modules/b_module_xml/rdf/applications_du_rdf/","title":"Applications du RDF","section":"RDF","content":" Applications du RDF Le RDF se retrouve un peu partout sur le web, parfois de façon « invisible », c'est-à-dire qu'il est souvent utilisé dans les échanges automatiques entre les logiciels. En outre, il est utilisé au sein des portails, par exemple. Voyons maintenant quatre applications RDF bien établies : Dublin Core Il s'agit sans doute de l'utilisation la plus connue et la plus répandue du RDF. La norme Dublin Core est assez simple et vise à décrire les travaux rendus disponibles sur le web (auteur, titre, date, etc.). Elle est notamment utilisée au sein des livres électroniques (comme les EPUB). Cette norme s'inspire de la bibliothéconomie. Creative Commons Il s'agit d'une façon de décrire les droits accordés sur le contenu placé sur le web. Par exemple, vous voulez savoir si vous pouvez recopier telle ou telle page web; si l'auteur a utilisé la norme Creative Commons , alors vous devriez pouvoir savoir ce qui est permis par l'auteur. FOAF La norme FOAF (« Friend Of A Friend » - « ami d'un ami ») permet de décrire un individu et les gens qu'il connaît. Cette norme sert à traiter les réseaux sociaux. RSS/RDF La norme RSS est utilisée par les blogues et sites de nouvelles. En gros, un document RSS/RDF contient une version XML des dernières nouvelles. Par la suite, plusieurs de ces fichiers XML peuvent être combinés pour créer un portail de nouvelles ou utilisés avec un outil-client de type « RSS aggregator » pour obtenir automatiquement les dernières nouvelles. Un exemple : Dublin Core La norme Dublin Core définit plusieurs « verbes » (au sein du RDF); on peut en consulter la liste à l'adresse http://dublincore.org/documents/dcmi-terms/ (en anglais). Cette norme a été publiée pour la première fois en juillet 1999. Le préfixe de la norme Dublin Core est « http://purl.org/dc/elements/1.1/ », du moins pour les éléments de base présentés ici. Voici les URI complets et leur signification : http://purl.org/dc/elements/1.1/creator Personne ou organisme qui est l'auteur du travail. http://purl.org/dc/elements/1.1/contributor Personne ou organisme qui a contribué à un travail, mais sans en être l'auteur. http://purl.org/dc/elements/1.1/coverage Lieu et période correspondant au travail. http://purl.org/dc/elements/1.1/date Date associée au travail, généralement sous la forme AAAA-MM-JJ. Il peut s'agir de la date de publication, de création ou de la dernière révision. http://purl.org/dc/elements/1.1/description Brève description du travail. http://purl.org/dc/elements/1.1/format Format sous lequel est publié le travail. Si le travail est publié en HTML, alors on utilisera souvent « text/html » pour décrire le format. http://purl.org/dc/elements/1.1/identifier Code ou URI qui correspond de façon unique au travail. Si un travail est publié à une adresse web, on peut utiliser cette adresse comme URI; si c'est un livre avec un ISBN, on peut utiliser un URI de la forme « urn:ISBN:0-123-12345-1 ». http://purl.org/dc/elements/1.1/language Code ISO-639/ISO-3166 décrivant le travail. Si le travail est publié en français, on peut utiliser « fr-CA »; sinon, en anglais, ce serait « en-CA » (CA signifie Canada). http://purl.org/dc/elements/1.1/publisher Organisme responsable de la publication du travail. http://purl.org/dc/elements/1.1/relation Ressource liée au travail. Par exemple, pour un travail fait en classe, on peut établir un lien avec l'exposé du travail. http://purl.org/dc/elements/1.1/rights Contient souvent une affirmation permettant de savoir qui est propriétaire du travail (détenteur du droit d'auteur). http://purl.org/dc/elements/1.1/source Résumé du travail de quelqu'un d'autre. Cet URI permet de pointer vers la source originale. http://purl.org/dc/elements/1.1/subject Généralement, une liste de mots clés. http://purl.org/dc/elements/1.1/title Titre du travail. http://purl.org/dc/elements/1.1/type Type de la ressource (texte, image, etc.). Notons que le « type » est différent du « format ». Par exemple, une image peut être en format Jpeg ou Gif, un texte peut être en format Word ou ASCII. Voyons comment nous pouvons décrire ce texte que vous êtes en train de lire, en utilisant la norme Dublin Core . Attribuons-lui l'URI « http://teluq.ca/rdfexemples.html ». Sujet Verbe Objet http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/creator http://lemire.me/fr/ http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/date \"2004-07-27\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/title \"Introduction au RDF\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/type \"text\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/Language \"fr-CA\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/subject \"RDF, Dublin Core, Creative Commons, FOAF, RSS/RDF\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/rights \"Copyright 2005 Daniel Lemire\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/description \"Un document comprenant des exemples d'utilisation du RDF en gestion des connaissances.\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/format \"text/html\" http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/identifier http://teluq.ca/ rdfexemples.html Nous pouvons aussi représenter ce tableau en XML comme ceci : \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://teluq.ca/rdfexemples.html\"\u0026gt; \u0026lt;dc:creator rdf:resource=\"http://lemire.me/fr/\" /\u0026gt; \u0026lt;dc:date\u0026gt;2004-07-27\u0026lt;/dc:date\u0026gt; \u0026lt;dc:title\u0026gt;Introduction au RDF\u0026lt;/dc:title\u0026gt; \u0026lt;dc:type\u0026gt;text\u0026lt;/dc:type\u0026gt; \u0026lt;dc:Language\u0026gt;fr-CA\u0026lt;/dc:Language\u0026gt; \u0026lt;dc:subject\u0026gt;RDF, Dublin Core, Creative Commons, FOAF, RSS/RDF\u0026lt;/dc:subject\u0026gt; \u0026lt;dc:rights\u0026gt;Copyright 2005 Daniel Lemire\u0026lt;/dc:rights\u0026gt; \u0026lt;dc:description\u0026gt;Un document comprenant des exemples d'utilisation du RDF en gestion des connaissances.\u0026lt;/dc:description\u0026gt; \u0026lt;dc:format\u0026gt;text/html\u0026lt;/dc:format\u0026gt; \u0026lt;dc:identifier rdf:resource=\"http://teluq.ca/rdfexemples.html\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Nous pouvons aussi représenter ce tableau sous la forme d'un graphe : ../module5/dc.pdf rdfexemples.html identifier http://lemire.me/fr/ creator 2004-07-27 date Introduction au RDF title text type fr-CA Language RDF subject Copyright 2005 Daniel Lemire rights Un document comprenant des exemples d'utilisation du RDF en gestion des connaissances. description html format Évidemment, Dublin Core est une norme RDF et non pas une norme XML. Il est donc possible d'exprimer du contenu Dublin Core sans passer par le XML. Nous pourrions très bien nous en tenir au tableau sujet/verbe/complément ou utiliser une autre syntaxe. Un syntaxe plus populaire que le XML est sans doute celle décrite par la RFC 2731 . Elle est facile à comprendre: il suffit d'utiliser des éléments meta avec les attributs name et content. La convention est que si l'attribute débute par le préfixe « DC.» ce qui suit est une information Dublin Core. Voici un exemple: \u0026lt;meta name = \"DC.date\" content = \"2004-07-27\" /\u0026gt; \u0026lt;meta name = \"DC.title\" content = \"Introduction au RDF\" /\u0026gt; \u0026lt;meta name = \"DC.type\" content = \"text\" /\u0026gt; \u0026lt;meta name = \"DC.Language\" content = \"fr-CA\" /\u0026gt; \u0026lt;meta name = \"DC.subject\" content = \"RDF, Dublin Core, Creative Commons, FOAF, RSS/RDF\" /\u0026gt; \u0026lt;meta name = \"DC.rights\" content = \"Copyright 2005 Daniel Lemire\" /\u0026gt; \u0026lt;meta name = \"DC.description\" content = \"Un document comprenant des exemples d'utilisation du RDF en gestion des connaissances.\" /\u0026gt; \u0026lt;meta name = \"DC.format\" content = \"text/html\" /\u0026gt; Notons aussi que les conventions d'espace de noms s'appliquent et que l'ordre n'est pas important. Nous pouvons donc remplacer le XML précédent par celui-ci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/dc/elements/1.1/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://teluq.ca/rdfexemples.html\"\u0026gt; \u0026lt;creator rdf:resource=\"http://lemire.me/fr/\" /\u0026gt; \u0026lt;title\u0026gt;Introduction au RDF\u0026lt;/title\u0026gt; \u0026lt;date\u0026gt;2004-07-27\u0026lt;/date\u0026gt; \u0026lt;type\u0026gt;text\u0026lt;/type\u0026gt; \u0026lt;subject\u0026gt;RDF, Dublin Core, Creative Commons, FOAF, RSS/RDF\u0026lt;/subject\u0026gt; \u0026lt;rights\u0026gt;Copyright 2005 Daniel Lemire\u0026lt;/rights\u0026gt; \u0026lt;description\u0026gt;Un document comprenant des exemples d'utilisation du RDF en gestion des connaissances.\u0026lt;/description\u0026gt; \u0026lt;format\u0026gt;text/html\u0026lt;/format\u0026gt; \u0026lt;identifier rdf:resource=\"http://teluq.ca/rdfexemples.html\" /\u0026gt; \u0026lt;Language\u0026gt;fr-CA\u0026lt;/Language\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Il existe des applications plus sophistiquées de la norme Dublin Core , mais nous avons ici l'essentiel. Vous pouvez dès maintenant cataloguer les ressources d'une entreprise en utilisant simplement ce que nous venons de présenter. Comme la norme est utilisée partout dans le monde, il sera possible d'échanger ces descriptions ou d'utiliser des logiciels communs pour le traitement ou l'affichage des informations. Un exemple : Creative Commons Une des limites apparentes de la norme Dublin Core est son incapacité à spécifier de façon précise les droits accordés sur un travail. Le problème est particulièrement fréquent sur le web : a-t-on le droit d'utiliser telle ou telle image gratuitement, de la reproduire, de la modifier, et ainsi de suite. Pour résoudre cette difficulté, les gens font appel à la norme Creative Commons , qui utilise le préfixe « http://web.resource.org/cc/ ». Cette norme définit une classe « Work » (travail, en anglais, ici au sens d'oœuvre), mais emprunte pratiquement tout le reste à Dublin Core qu'elle vient compléter. La norme Creative Commons a été proposée en 2001 par James Boyle, Michael Carroll, Lawrence Lessig, Hal Abelson, Eric Saltzman et Eric Eldred. Voici un exemple très simple d'une description utilisant la norme Creative Commons : Sujet Verbe Objet http://teluq.ca/ rdfexemples.html http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://web.resource.org/ cc/Work http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/title \"Le RDF par l'exemple\" Et voici la version XML correspondante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns=\"http://web.resource.org/cc/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;Work rdf:about=\"http://teluq.ca/rdfexemples.html\"\u0026gt; \u0026lt;dc:title\u0026gt;Le RDF par l'exemple\u0026lt;/dc:title\u0026gt; \u0026lt;/Work\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Tout ce que nous avons affirmé dans ce dernier document, c'est que la page actuelle appartient à la classe « Work ». Dans l'état actuel des choses, nous affirmons par défaut qu'il n'est pas permis d'utiliser cette page, car nous n'avons attribué aucune permission. Supposons que l'auteur désire accorder le droit au lecteur de redistribuer, de modifier et de partager cette page, pour autant qu'il utilise la même licence. Nous pourrions alors utiliser la licence « Attribution-ShareAlike 2.0 » dont l'URI est « http://creativecommons.org/licenses/by-sa/2.0/ ». Évidemment, nous pouvons aussi créer notre licence de toute pièce, mais dans l'exemple, nous utiliserons la licence « Attribution-ShareAlike 2.0 ». Pour faire un lien entre notre travail et une licence, nous utilisons le verbe dont l'URI est « http://web.resource.org/cc/license », comme ce qui suit; observez bien la dernière ligne du tableau. Sujet Verbe Objet http://teluq.ca/ rdfexemples.html http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://web.resource.org/ cc/Work http://teluq.ca/ rdfexemples.html http://purl.org/ dc/elements/1.1/title \"Le RDF par l'exemple\" http://teluq.ca/ rdfexemples.html http://web.resource.org/ cc/license http://creativecommons.org/licenses/by-sa/2.0/ Nous pouvons aussi utiliser le XML correspondant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns=\"http://web.resource.org/cc/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;Work rdf:about=\"http://teluq.ca/rdfexemples.html\"\u0026gt; \u0026lt;dc:title\u0026gt;Le RDF par l'exemple\u0026lt;/dc:title\u0026gt; \u0026lt;license rdf:resource=\"http://creativecommons.org/licenses/by-sa/2.0/\" /\u0026gt; \u0026lt;/Work\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Voici la représentation sous la forme d'un graphe : ../module5/cc.pdf rdfexemples.html {Work} Le RDF par l'exemple title http://creativecommons.org/licenses/by-sa/2.0/ license Nous avons alors un document Creative Commons complet. Cependant, un problème demeure. Supposons qu'un logiciel fasse automatiquement une recherche pour vous et que vous ne désiriez obtenir que les textes que vous pouvez modifier librement. Il n'est pas évident pour une machine de comprendre que l'URI « http://creativecommons.org/licenses/by-sa/2.0/ » vous donne ce droit; d'ailleurs, une telle recherche n'est peut-être pas très simple pour un humain... Creative Commons définit trois verbes et des objets permettant de décrire une licence et une classe. Toutes les licences appartiennent à la classe ayant pour URI « http://web.resource.org/cc/License ». Les URI des trois verbes sont : http://web.resource.org/cc/permits La licence le permet. Creative Commons définit trois URI pouvant être utilisés comme objet de ce verbe. Il y a d'abord « http://web.resource.org/cc/Reproduction », le droit de reproduire en tout ou en partie le travail. Il y a ensuite « http://web.resource.org/cc/Distribution », le droit de redistribuer le travail. Finalement, il y a « http://web.resource.org/cc/DerivativeWorks », le droit de modifier le travail. Évidemment, il est possible de définir ses propres objets. http://web.resource.org/cc/requires La licence pose comme condition. Creatives Commons définit quatre URI pouvant être utilisés comme objet de ce verbe : « http://web.resource.org/cc/Notice » pour spécifier qu'il faut reproduire intégralement les notes légales (licence et droits d'auteurs); « http://web.resource.org/cc/Attribution » pour spécifier qu'il faut attribuer à l'auteur le crédit du travail; « http://web.resource.org/cc/ShareAlike » pour spécifier que si l'on redistribue le travail, il faut le faire en gardant la même licence; « http://web.resource.org/cc/SourceCode » pour spécifier que le code source doit être redistribué. http://web.resource.org/cc/prohibits La licence interdit. Il n'y a qu'un seul URI défini par Creative Commons qui peut être utilisé avec ce verbe : « http://web.resource.org/cc/CommercialUse »; cela permet d'interdire l'utilisation à des fins commerciales. Encore une fois, il est possible de définir ses propres objets. Dans le cas de la licence « Attribution-ShareAlike 2.0 », nous pouvons la décrire comme suit : Sujet Verbe Objet http://creativecommons.org/ licenses/by-sa/2.0/ http://www.w3.org/1999/ 02/22-rdf-syntax-ns#type http://web.resource.org/ cc/License http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/permits http://web.resource.org/ cc/Reproduction http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/permits http://web.resource.org/ cc/Distribution http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/requires http://web.resource.org/ cc/Notice http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/requires http://web.resource.org/ cc/Attribution http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/permits http://web.resource.org/ cc/DerivativeWorks http://creativecommons.org/ licenses/by-sa/2.0/ http://web.resource.org/ cc/requires http://web.resource.org/ cc/ShareAlike Nous pouvons aussi utiliser le XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns=\"http://web.resource.org/cc/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;License rdf:about=\"http://creativecommons.org/licenses/by-sa/2.0/\"\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Reproduction\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Distribution\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Notice\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Attribution\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/ShareAlike\" /\u0026gt; \u0026lt;/License\u0026gt; \u0026lt;/rdf:RDF\u0026gt; En pratique, nous combinons souvent le tout (description du travail et description de la licence) pour obtenir le XML suivant : \u0026lt;rdf:RDF xmlns=\"http://web.resource.org/cc/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;Work rdf:about=\"http://teluq.ca/rdfexemples.html\"\u0026gt; \u0026lt;dc:title\u0026gt;Le RDF par l'exemple\u0026lt;/dc:title\u0026gt; \u0026lt;license rdf:resource=\"http://creativecommons.org/licenses/by-sa/2.0/\" /\u0026gt; \u0026lt;/Work\u0026gt; \u0026lt;License rdf:about=\"http://creativecommons.org/licenses/by-sa/2.0/\"\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Reproduction\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Distribution\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Notice\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Attribution\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/ShareAlike\" /\u0026gt; \u0026lt;/License\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Voilà! De cette manière, une machine pourra automatiquement déterminer quels droits l'utilisateur a sur une œuvre. Un logiciel pourrait automatiquement avertir l'utilisateur de ses obligations si jamais il tentait d'enregistrer sur son disque une copie de l'œuvre. Dans le cas d'une entreprise qui utilise beaucoup de contenu multimédia, l'utilisation de cette norme pourrait être très utile pour détecter automatiquement les violations des droits d'auteur. Un exemple : FOAF Les personnes sont souvent ce qu'il y a de plus important dans une organisation; il n'est donc pas étonnant qu'on veuille utiliser le RDF pour les décrire. Pour ce faire, on utilise souvent la norme FOAF pour « Friend-Of-A-Friend », ou un ami d'un ami, en français, (préfixe http://xmlns.com/foaf/0.1/) qui définit la classe « Person » (personne, en anglais). Le projet FOAF a été lancé de façon informelle par Daniel Brickley en 1998. À l'époque, il avait mis un texte RDF ressemblant à ceci sur sa page personnelle : ( Attention.- Il ne s'agit pas de RDF/XML valable. ) \u0026lt;RDF:RDF xmlns=\"vocabdemo.rdf\"\u0026gt; xmlns:rdf=\"http://www.w3.org/TR/WD-rdf-syntax#\"\u0026gt; \u0026lt;Person ID=\"dan\"\u0026gt; \u0026lt;name\u0026gt; Dan Brickley \u0026lt;/name\u0026gt; \u0026lt;Email\u0026gt; daniel.brickley@bristol.ac.uk \u0026lt;/Email\u0026gt; \u0026lt;telephone rdf:resource = \"phone:44-1-+44(0)117-9287493\" /\u0026gt; \u0026lt;pager rdf:resource = \"phone:44-1-+44(0)2523-1781115\" /\u0026gt; \u0026lt;homePage rdf:resource= \"http://purl.org/net/danbri/\" /\u0026gt; \u0026lt;homePage rdf:resource= \"http://www.ilrt.bris.ac.uk/about/staff/dan.html\"/\u0026gt; \u0026lt;/Person\u0026gt; \u0026lt;/RDF:RDF\u0026gt; La norme FOAF est très riche; mais à la base, on trouve les verbes suivants : http://xmlns.com/foaf/0.1/name Verbe pointant vers le nom de la personne (John Smith) http://xmlns.com/foaf/0.1/nick Verbe pointant vers le surnom informel de la personne (joblo). http://xmlns.com/foaf/0.1/title Verbe pointant vers le titre de la personne (docteur, monsieur, madame). http://xmlns.com/foaf/0.1/homepage Verbe pointant vers la page personnelle de la personne. http://xmlns.com/foaf/0.1/mbox Verbe pointant vers l'adresse électronique de la personne. http://xmlns.com/foaf/0.1/img Verbe pointant vers une image de la personne, la représentant spécifiquement. http://xmlns.com/foaf/0.1/depiction Verbe pointant vers une image représentant la personne. Contrairement à « img », l'image peut être une photo de groupe. http://xmlns.com/foaf/0.1/family_name Verbe pointant vers le nom de famille de la personne (Smith). http://xmlns.com/foaf/0.1/givenname Verbe pointant vers le prénom de la personne (John). En XML, une description de l'auteur de ce document pourrait se présenter comme suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:foaf=\"http://xmlns.com/foaf/0.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;foaf:Person\u0026gt; \u0026lt;foaf:givenname\u0026gt;Daniel\u0026lt;/foaf:givenname\u0026gt; \u0026lt;foaf:family_name\u0026gt;Lemire\u0026lt;/foaf:family_name\u0026gt; \u0026lt;foaf:homepage rdf:resource=\"http://lemire.me/fr/\" /\u0026gt; \u0026lt;foaf:mbox\u0026gt;lemire@uqam.ca\u0026lt;/foaf:mbox\u0026gt; \u0026lt;foaf:img rdf:resource=\"http://lemire.me/fr/images/GIF/zel2p.gif\" /\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Voici le graphe équivalent : ../module5/foaf.pdf (anonyme) Person Daniel givenname Lemire family_name http://lemire.me/fr/ homepage lemire@uqam.ca mbox zel2p.gif img Notez que la balise « Person » n'a pas d'attribut « rdf:about ». Actuellement, il existe un débat sur cette question : Peut-on attribuer un URI unique à chaque individu et si oui, comment le choisir? C'est un cas où l'URI du sujet est « implicite » : cela signifie que dans les triplets sujet/verbe/objet, le sujet a un URI « fictif », qui n'est valable que dans le cadre du document que l'on traite. Autrement dit, le programme qui traite le document doit allouer dynamiquement un URI au sujet pour la durée du traitement. Rappelons-nous, en effet, que la norme RDF permet d'omettre le sujet, mais que si le sujet est spécifié, il doit être un URI. Nous pouvons imaginer que la norme FOAF sera éventuellement utilisée pour représenter les réseaux sociaux, les organisations, et ainsi de suite. Une fois l'information sociale représentée de façon formelle, nous pouvons croire qu'il sera possible de poser des questions à un ordinateur de l'ordre suivant : Est-ce que je connais quelqu'un qui connaît quelqu'un travaillant chez IBM? Un exemple : RSS/RDF La version 1.0 de la norme RSS est un exemple de RDF. Cette norme dont l'acronyme n'a pas de définition établie, sert à représenter des fils de nouvelles. Elle a été imaginée par la compagnie Netscape et servait alors à la production du portail Netscape (1999). Elle est devenue très populaire et on trouve maintenant des milliers de fils de nouvelles en format RSS dans le monde. Par exemple, sur http://www.yulblog.org/ , il y a des centaines de blogues écrits par des Montréalais et la plupart ont un fil de nouvelles en format RSS . Une nouvelle, appelée « item » en RSS , prend la forme suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/rss/1.0/\"\u0026gt; \u0026lt;item rdf:about=\"http://www.nouvelles.com/nouvelles1\"\u0026gt; \u0026lt;title\u0026gt;La bourse fait faillite\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;http://www.nouvelles.com/nouvelles1.html\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt; Aujourd'hui, on a appris que la bourse a fait faillite. \u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Nous constatons qu'il y a une classe (item) et trois verbes (title, link, description) qui représentent respectivement le titre, l'URL et le contenu de la nouvelle. Un document RSS est une liste d'items. Voici un document RSS : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/rss/1.0/\"\u0026gt; \u0026lt;channel rdf:about=\"http://www.nouvelles.com/nouvelles.rss\"\u0026gt; \u0026lt;title\u0026gt;Un site de nouvelles\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;http://www.nouvelles.com/\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt; Nouvelles.com est un superbe site de nouvelles \u0026lt;/description\u0026gt; \u0026lt;!-- Ensuite, on place une séquence de nouvelles, les unes après les autres--\u0026gt; \u0026lt;items\u0026gt; \u0026lt;rdf:Seq\u0026gt; \u0026lt;!-- chaque nouvelle a un URI --\u0026gt; \u0026lt;rdf:li resource=\"http://www.nouvelles.com/nouvelles1\" /\u0026gt; \u0026lt;rdf:li resource=\"http://www.nouvelles.com/nouvelles2\" /\u0026gt; \u0026lt;/rdf:Seq\u0026gt; \u0026lt;/items\u0026gt; \u0026lt;/channel\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Nous constatons une classe « channel » (canal, en anglais) qui contient un titre, un URL (link) et une description. Il y a aussi une liste de nouvelles (item). Généralement, nous combinons le tout dans un seul fichier, comme ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/rss/1.0/\"\u0026gt; \u0026lt;channel rdf:about=\"http://www.nouvelles.com/nouvelles.rss\"\u0026gt; \u0026lt;title\u0026gt;Un site de nouvelles\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;http://www.nouvelles.com/\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt; Nouvelles.com est un superbe site de nouvelles \u0026lt;/description\u0026gt; \u0026lt;!-- Ensuite, on place une séquence de nouvelles, les unes après les autres--\u0026gt; \u0026lt;items\u0026gt; \u0026lt;rdf:Seq\u0026gt; \u0026lt;!-- chaque nouvelle a un URI --\u0026gt; \u0026lt;rdf:li resource=\"http://www.nouvelles.com/nouvelles1\" /\u0026gt; \u0026lt;rdf:li resource=\"http://www.nouvelles.com/nouvelles2\" /\u0026gt; \u0026lt;/rdf:Seq\u0026gt; \u0026lt;/items\u0026gt; \u0026lt;/channel\u0026gt; \u0026lt;item rdf:about=\"http://www.nouvelles.com/nouvelles1\"\u0026gt; \u0026lt;title\u0026gt;La bourse fait faillite\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;http://www.nouvelles.com/nouvelles1.html\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt; Aujourd'hui, on a appris que la bourse a fait faillite. \u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;item rdf:about=\"http://www.nouvelles.com/nouvelles2\"\u0026gt; \u0026lt;title\u0026gt;Rien ne va plus à l'école\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;http://www.nouvelles.com/nouvelles2.html\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt; Un étudiant se serait rendu coupable d'apprentissage. \u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Les applications du RSS sont multiples. Supposons que votre organisation collabore avec plusieurs autres organisations et que vous vouliez rendre disponibles, sur une seule page web, toutes les nouvelles de toutes les organisations dont vous faites partie. Si chaque organisation rend disponible sur le web un document RSS toujours mis à jour, vous pouvez facilement récupérer les nouvelles de chacun et les afficher à un seul endroit. Au lieu de solliciter tous les membres par courriel, les fils de nouvelles RSS permettent à une machine de faire un tri et de personnaliser le contenu. La norme RSS est en voie d'être remplacée par la norme Atom . Un des avantages du nouveau format Atom est que chaque nouvelle doit avoir un identifiant unique ce qui permet d'éviter les doublons. Cependant, la norme RSS risque d'être toujours utile pendant bien des années. Atom n'est pas en RDF/XML. En voici un exemple : \u0026lt;?xml version=\"1.0\" encoding=\"utf-8\"?\u0026gt; \u0026lt;feed xmlns=\"http://www.w3.org/2005/Atom\"\u0026gt; \u0026lt;title\u0026gt;Un site de nouvelles\u0026lt;/title\u0026gt; \u0026lt;subtitle\u0026gt;Nouvelles.com est un superbe site de nouvelles\u0026lt;/subtitle\u0026gt; \u0026lt;link href=\"http://www.nouvelles.com/\"/\u0026gt; \u0026lt;updated\u0026gt;2003-12-13T18:30:02Z\u0026lt;/updated\u0026gt; \u0026lt;author\u0026gt; \u0026lt;name\u0026gt;John Doe\u0026lt;/name\u0026gt; \u0026lt;email\u0026gt;johndoe@example.com\u0026lt;/email\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;id\u0026gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6\u0026lt;/id\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;title\u0026gt;La bourse fait faillite\u0026lt;/title\u0026gt; \u0026lt;link href=\"http://www.nouvelles.com/nouvelles1.html\"/\u0026gt; \u0026lt;id\u0026gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a\u0026lt;/id\u0026gt; \u0026lt;updated\u0026gt;2003-12-13T18:30:02Z\u0026lt;/updated\u0026gt; \u0026lt;summary\u0026gt;Aujourd'hui, on a appris que la bourse a fait faillite. \u0026lt;/summary\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/feed\u0026gt; Conclusion Nous avons étudié quatre applications importantes du RDF sur le web. Le nombre d'applications est toutefois beaucoup plus important. Par exemple, Facebook fait la promotion de la norme Open Graph . Il faut garder à l'esprit que le RDF n'est pas le XML et que le XML ne sert qu'à représenter le RDF (et encore, ce n'est pas toujours possible). Pour en apprendre davantage sur le RDF, nous vous suggérons le livre de Shelley Powers, Practical RDF , publié chez O'Reilly. "},{"id":8,"href":"/orientee_donnees/docs/modules/b_module_xml/programmation/dom/","title":"DOM","section":"Modèles de programmation","content":" DOM # Le Document Object Model (DOM) est une interface de programmation standardisée pour accéder et manipuler des documents HTML et XML. Il représente la structure hiérarchique d\u0026rsquo;un document sous forme d\u0026rsquo;un arbre de nœuds, où chaque élément, attribut ou portion de texte est un nœud accessible via des méthodes de programmation. Cette approche permet aux développeurs de naviguer, modifier et interagir dynamiquement avec le contenu et la structure des documents web ou XML, facilitant ainsi la création d\u0026rsquo;applications interactives et la manipulation de données structurées.\nIntroduction # Nous supposons que vous disposez d’un environnement de développement Java et que vous ferez les exemples de ce tutoriel afin de mieux comprendre. Notre objectif est avant tout de vous rendre suffisamment à l’aise avec DOM pour pouvoir l’utiliser ; nous vous invitons toutefois à naviguer sur le web pour en apprendre davantage sur le sujet, au besoin.\nL’API Java elle-même est disponible sur le site d’Oracle. Pour pouvoir faire vos propres programmes, consultez l’API Java qui comprend tous les objets et fonctions du tutoriel.\nNotions de base # On dit qu’un modèle DOM est une structure en arbre. En informatique, un arbre est un graphe ou une structure constituée de nœuds, de façon telle que chaque nœud a un et un seul parent — ou aucun —, lequel a un seul ou plusieurs enfants. Un seul nœud est autorisé à ne pas avoir de parent : c’est le nœud-racine.\nPoint de vue critique # L’API DOM est très utilisée et supportée dans de nombreux langages (Java, JavaScript, C#, C++, etc.). Cependant, elle consomme beaucoup de mémoire et nécessite souvent beaucoup de code pour des opérations simples. Malgré ces défauts, sa large adoption en fait une référence incontournable.\nPrincipaux concepts # Le Document Object Model (DOM) représente une page XML ou HTML comme un arbre de nœuds. Chaque élément, attribut, texte ou commentaire est vu comme un nœud que l\u0026rsquo;on peut interroger et manipuler. Cette vision arborescente permet de naviguer facilement entre les différentes parties d\u0026rsquo;un document et de modifier sa structure de façon programmatique.\nLes nœuds ont différents types : Element pour les balises, Attr pour les attributs, Text pour les contenus textuels, Comment pour les commentaires et Document pour la racine. En Java, ces types sont représentés par les interfaces du package org.w3c.dom (par exemple Element, Node, Document), et chaque objet fournit des méthodes adaptées pour accéder à son contenu et à ses relations (parent, enfants, frères/sœurs).\nUn élément (Element) contient un nom (le nom de la balise), éventuellement des attributs (paires nom/valeur) et des nœuds enfants. Les attributs sont accessibles via getAttribute / setAttribute et les sous-éléments via getElementsByTagName ou en parcourant la liste childNodes. Il est important de distinguer la valeur d\u0026rsquo;un attribut (string) du texte contenu dans un nœud Text enfant.\nLes nœuds de texte (Text) représentent le texte brut entre balises. Ils peuvent contenir des espaces ou des retours à la ligne significatifs selon le contexte. L\u0026rsquo;accès au contenu textuel se fait généralement avec getTextContent() ou getNodeValue(). En pratique, on veillera à normaliser ou filtrer les nœuds de texte inutiles (espaces blancs) selon les besoins de l\u0026rsquo;application.\nPour modifier un document on crée ou clone des nœuds (createElement, createTextNode, cloneNode) puis on les insère (appendChild, insertBefore) ou retire (removeChild). Une fois la modification effectuée, on peut sérialiser le DOM vers un flux ou un fichier avec les classes de transformation (Transformer, DOMSource, StreamResult) pour obtenir le XML/HTML final.\nPrésentation sommaire de l\u0026rsquo;API # Les points d\u0026rsquo;entrée les plus courants sont DocumentBuilderFactory et DocumentBuilder : on obtient une instance de DocumentBuilderFactory via DocumentBuilderFactory.newInstance(), on configure ses options (par exemple setNamespaceAware(true) ou setValidating(false)) puis on crée un DocumentBuilder pour parser des fichiers ou construire des documents en mémoire.\nLe parsing s\u0026rsquo;effectue avec DocumentBuilder.parse(...) qui accepte un File, un InputStream ou un InputSource. En cas d\u0026rsquo;erreur de syntaxe le parseur lève une SAXException ou une IOException — il est donc courant d\u0026rsquo;entourer l\u0026rsquo;appel d\u0026rsquo;un bloc try/catch et de fournir des messages d\u0026rsquo;erreur clairs. Pour des environnements sensibles, activez les fonctionnalités de sécurité (par ex. factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)) afin de réduire les risques liés aux entités externes.\nPour créer ou modifier un document on utilise les méthodes du Document : createElement, createTextNode, setAttribute, appendChild, insertBefore, removeChild, etc. importNode/adoptNode sont utiles pour déplacer des nœuds entre documents. Après de nombreuses modifications, appelez normalizeDocument() ou normalize() sur un nœud pour fusionner les nœuds de texte adjacents et avoir un arbre propre.\nLa sérialisation du DOM se fait généralement via TransformerFactory et Transformer. On construit un DOMSource à partir du Document et un StreamResult vers un fichier ou System.out. On peut régler des propriétés de sortie (encodage, indentation) avec transformer.setOutputProperty(OutputKeys.ENCODING, \u0026quot;UTF-8\u0026quot;) ou OutputKeys.INDENT pour obtenir un XML lisible.\nPour interroger le document il est fréquent d\u0026rsquo;utiliser XPath (XPathFactory.newInstance() → XPath) ; evaluate permet d\u0026rsquo;extraire un Node, une NodeList ou une chaîne. Pour des besoins plus avancés on peut combiner DOM avec des bibliothèques comme Xerces, XPath 2.0/XQuery (Saxon), ou utiliser DocumentBuilderFactory configuré pour la validation (DTD/Schema) si l\u0026rsquo;application doit vérifier la conformité du document.\nUn document XML # Créons d’abord un document XML nommé « test.xml » :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;jojo\u0026#34;\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;32\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;Ma\u0026#34;\u0026gt;Marie\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;54\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;/liste\u0026gt; Charger un document XML en Java # import org.w3c.dom.*; import javax.xml.parsers.*; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); } } Accès à l’élément-racine # import org.w3c.dom.*; import javax.xml.parsers.*; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); Element racine = doc.getDocumentElement(); System.out.println(racine.getTagName()); // affiche : liste } } L’interface Node # Type de nœud getNodeName() getNodeValue() Attribut nom de l’attribut valeur de l’attribut Élément nom de l’élément null Texte #text le texte Parcourir les enfants # Prenez quelques secondes pour exécuter le programme suivant dans votre navigateur.\nTest.java import org.w3c.dom.*; import javax.xml.parsers.*; import java.io.StringReader; import org.xml.sax.InputSource; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); String xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;jojo\u0026#34;\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;32\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;Ma\u0026#34;\u0026gt;Marie\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;54\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;/liste\u0026gt; \u0026#34;\u0026#34;\u0026#34;; Document doc = parser.parse(new InputSource(new StringReader(xml))); Element racine = doc.getDocumentElement(); NodeList joueurs = racine.getElementsByTagName(\u0026#34;joueur\u0026#34;); for (int i = 0; i \u0026lt; joueurs.getLength(); i\u0026#43;\u0026#43;) { Element joueur = (Element) joueurs.item(i); Element nom = (Element) joueur.getElementsByTagName(\u0026#34;nom\u0026#34;).item(0); Element buts = (Element) joueur.getElementsByTagName(\u0026#34;buts\u0026#34;).item(0); String nomJoueur = nom.getFirstChild().getNodeValue(); String surnom = nom.getAttribute(\u0026#34;surnom\u0026#34;); String nbButs = buts.getFirstChild().getNodeValue(); System.out.println(nomJoueur \u0026#43; \u0026#34; (\u0026#34; \u0026#43; surnom \u0026#43; \u0026#34;) : \u0026#34; \u0026#43; nbButs \u0026#43; \u0026#34; buts\u0026#34;); } } } Exécuter Création d’un document XML depuis zéro # CreationDOM.java import org.w3c.dom.*; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.FileWriter; public class CreationDOM { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.newDocument(); Element liste = doc.createElement(\u0026#34;liste\u0026#34;); doc.appendChild(liste); Element joueur1 = doc.createElement(\u0026#34;joueur\u0026#34;); Element nom1 = doc.createElement(\u0026#34;nom\u0026#34;); nom1.appendChild(doc.createTextNode(\u0026#34;Jean\u0026#34;)); nom1.setAttribute(\u0026#34;surnom\u0026#34;, \u0026#34;jojo\u0026#34;); Element buts1 = doc.createElement(\u0026#34;buts\u0026#34;); buts1.appendChild(doc.createTextNode(\u0026#34;32\u0026#34;)); joueur1.appendChild(nom1); joueur1.appendChild(buts1); liste.appendChild(joueur1); TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); t.setOutputProperty(OutputKeys.ENCODING, \u0026#34;ISO-8859-1\u0026#34;); t.setOutputProperty(OutputKeys.INDENT, \u0026#34;yes\u0026#34;); DOMSource source = new DOMSource(doc); StreamResult result = new StreamResult(new FileWriter(\u0026#34;nouveau.xml\u0026#34;)); t.transform(source, result); StreamResult consoleResult = new StreamResult(System.out); t.transform(source, consoleResult); } } Exécuter DOM et autres langages # L\u0026rsquo;API DOM est supportée en C++ (voir Xerces-C), en Python (paquetage xml.dom), en Perl (voir Xerces-P), en JavaScript, etc. C\u0026rsquo;est d\u0026rsquo;ailleurs la principale force de cette API : peu importe le contexte, il y a fort à parier que vous aurez accès à l\u0026rsquo;API DOM. Ce n\u0026rsquo;est sans doute pas la meilleure API possible, mais son ubiquité fait en sorte qu\u0026rsquo;il vaut la peine d\u0026rsquo;apprendre à la connaître.\n"},{"id":9,"href":"/orientee_donnees/legacy/semaine_12/dom/","title":"DOM","section":"Semaine 12","content":" DOM # Introduction # Nous supposons que vous disposez d’un environnement de développement Java et que vous ferez les exemples de ce tutoriel afin de mieux comprendre. Notre objectif est avant tout de vous rendre suffisamment à l’aise avec DOM pour pouvoir l’utiliser ; nous vous invitons toutefois à naviguer sur le web pour en apprendre davantage sur le sujet, au besoin.\nL’API Java elle-même est disponible sur le site d’Oracle. Pour pouvoir faire vos propres programmes, consultez l’API Java qui comprend tous les objets et fonctions du tutoriel.\nNotions de base # On dit qu’un modèle DOM est une structure en arbre. En informatique, un arbre est un graphe ou une structure constituée de nœuds, de façon telle que chaque nœud a un et un seul parent — ou aucun —, lequel a un seul ou plusieurs enfants. Un seul nœud est autorisé à ne pas avoir de parent : c’est le nœud-racine.\nPoint de vue critique # L’API DOM est très utilisée et supportée dans de nombreux langages (Java, JavaScript, C#, C++, etc.). Cependant, elle consomme beaucoup de mémoire et nécessite souvent beaucoup de code pour des opérations simples. Malgré ces défauts, sa large adoption en fait une référence incontournable.\nPrincipaux concepts # Le Document Object Model (DOM) représente une page XML ou HTML comme un arbre de nœuds. Chaque élément, attribut, texte ou commentaire est vu comme un nœud que l\u0026rsquo;on peut interroger et manipuler. Cette vision arborescente permet de naviguer facilement entre les différentes parties d\u0026rsquo;un document et de modifier sa structure de façon programmatique.\nLes nœuds ont différents types : Element pour les balises, Attr pour les attributs, Text pour les contenus textuels, Comment pour les commentaires et Document pour la racine. En Java, ces types sont représentés par les interfaces du package org.w3c.dom (par exemple Element, Node, Document), et chaque objet fournit des méthodes adaptées pour accéder à son contenu et à ses relations (parent, enfants, frères/sœurs).\nUn élément (Element) contient un nom (le nom de la balise), éventuellement des attributs (paires nom/valeur) et des nœuds enfants. Les attributs sont accessibles via getAttribute / setAttribute et les sous-éléments via getElementsByTagName ou en parcourant la liste childNodes. Il est important de distinguer la valeur d\u0026rsquo;un attribut (string) du texte contenu dans un nœud Text enfant.\nLes nœuds de texte (Text) représentent le texte brut entre balises. Ils peuvent contenir des espaces ou des retours à la ligne significatifs selon le contexte. L\u0026rsquo;accès au contenu textuel se fait généralement avec getTextContent() ou getNodeValue(). En pratique, on veillera à normaliser ou filtrer les nœuds de texte inutiles (espaces blancs) selon les besoins de l\u0026rsquo;application.\nPour modifier un document on crée ou clone des nœuds (createElement, createTextNode, cloneNode) puis on les insère (appendChild, insertBefore) ou retire (removeChild). Une fois la modification effectuée, on peut sérialiser le DOM vers un flux ou un fichier avec les classes de transformation (Transformer, DOMSource, StreamResult) pour obtenir le XML/HTML final.\nPrésentation sommaire de l\u0026rsquo;API # Les points d\u0026rsquo;entrée les plus courants sont DocumentBuilderFactory et DocumentBuilder : on obtient une instance de DocumentBuilderFactory via DocumentBuilderFactory.newInstance(), on configure ses options (par exemple setNamespaceAware(true) ou setValidating(false)) puis on crée un DocumentBuilder pour parser des fichiers ou construire des documents en mémoire.\nLe parsing s\u0026rsquo;effectue avec DocumentBuilder.parse(...) qui accepte un File, un InputStream ou un InputSource. En cas d\u0026rsquo;erreur de syntaxe le parseur lève une SAXException ou une IOException — il est donc courant d\u0026rsquo;entourer l\u0026rsquo;appel d\u0026rsquo;un bloc try/catch et de fournir des messages d\u0026rsquo;erreur clairs. Pour des environnements sensibles, activez les fonctionnalités de sécurité (par ex. factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)) afin de réduire les risques liés aux entités externes.\nPour créer ou modifier un document on utilise les méthodes du Document : createElement, createTextNode, setAttribute, appendChild, insertBefore, removeChild, etc. importNode/adoptNode sont utiles pour déplacer des nœuds entre documents. Après de nombreuses modifications, appelez normalizeDocument() ou normalize() sur un nœud pour fusionner les nœuds de texte adjacents et avoir un arbre propre.\nLa sérialisation du DOM se fait généralement via TransformerFactory et Transformer. On construit un DOMSource à partir du Document et un StreamResult vers un fichier ou System.out. On peut régler des propriétés de sortie (encodage, indentation) avec transformer.setOutputProperty(OutputKeys.ENCODING, \u0026quot;UTF-8\u0026quot;) ou OutputKeys.INDENT pour obtenir un XML lisible.\nPour interroger le document il est fréquent d\u0026rsquo;utiliser XPath (XPathFactory.newInstance() → XPath) ; evaluate permet d\u0026rsquo;extraire un Node, une NodeList ou une chaîne. Pour des besoins plus avancés on peut combiner DOM avec des bibliothèques comme Xerces, XPath 2.0/XQuery (Saxon), ou utiliser DocumentBuilderFactory configuré pour la validation (DTD/Schema) si l\u0026rsquo;application doit vérifier la conformité du document.\nUn document XML # Créons d’abord un document XML nommé « test.xml » :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;jojo\u0026#34;\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;32\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;Ma\u0026#34;\u0026gt;Marie\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;54\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;/liste\u0026gt; Charger un document XML en Java # import org.w3c.dom.*; import javax.xml.parsers.*; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); } } Accès à l’élément-racine # import org.w3c.dom.*; import javax.xml.parsers.*; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); Element racine = doc.getDocumentElement(); System.out.println(racine.getTagName()); // affiche : liste } } L’interface Node # Type de nœud getNodeName() getNodeValue() Attribut nom de l’attribut valeur de l’attribut Élément nom de l’élément null Texte #text le texte Parcourir les enfants # Prenez quelques secondes pour exécuter le programme suivant dans votre navigateur.\nTest.java import org.w3c.dom.*; import javax.xml.parsers.*; import java.io.StringReader; import org.xml.sax.InputSource; public class Test { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); String xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;jojo\u0026#34;\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;32\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom surnom=\u0026#34;Ma\u0026#34;\u0026gt;Marie\u0026lt;/nom\u0026gt; \u0026lt;buts\u0026gt;54\u0026lt;/buts\u0026gt; \u0026lt;/joueur\u0026gt; \u0026lt;/liste\u0026gt; \u0026#34;\u0026#34;\u0026#34;; Document doc = parser.parse(new InputSource(new StringReader(xml))); Element racine = doc.getDocumentElement(); NodeList joueurs = racine.getElementsByTagName(\u0026#34;joueur\u0026#34;); for (int i = 0; i \u0026lt; joueurs.getLength(); i\u0026#43;\u0026#43;) { Element joueur = (Element) joueurs.item(i); Element nom = (Element) joueur.getElementsByTagName(\u0026#34;nom\u0026#34;).item(0); Element buts = (Element) joueur.getElementsByTagName(\u0026#34;buts\u0026#34;).item(0); String nomJoueur = nom.getFirstChild().getNodeValue(); String surnom = nom.getAttribute(\u0026#34;surnom\u0026#34;); String nbButs = buts.getFirstChild().getNodeValue(); System.out.println(nomJoueur \u0026#43; \u0026#34; (\u0026#34; \u0026#43; surnom \u0026#43; \u0026#34;) : \u0026#34; \u0026#43; nbButs \u0026#43; \u0026#34; buts\u0026#34;); } } } Exécuter Création d’un document XML depuis zéro # CreationDOM.java import org.w3c.dom.*; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.FileWriter; public class CreationDOM { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.newDocument(); Element liste = doc.createElement(\u0026#34;liste\u0026#34;); doc.appendChild(liste); Element joueur1 = doc.createElement(\u0026#34;joueur\u0026#34;); Element nom1 = doc.createElement(\u0026#34;nom\u0026#34;); nom1.appendChild(doc.createTextNode(\u0026#34;Jean\u0026#34;)); nom1.setAttribute(\u0026#34;surnom\u0026#34;, \u0026#34;jojo\u0026#34;); Element buts1 = doc.createElement(\u0026#34;buts\u0026#34;); buts1.appendChild(doc.createTextNode(\u0026#34;32\u0026#34;)); joueur1.appendChild(nom1); joueur1.appendChild(buts1); liste.appendChild(joueur1); TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); t.setOutputProperty(OutputKeys.ENCODING, \u0026#34;ISO-8859-1\u0026#34;); t.setOutputProperty(OutputKeys.INDENT, \u0026#34;yes\u0026#34;); DOMSource source = new DOMSource(doc); StreamResult result = new StreamResult(new FileWriter(\u0026#34;nouveau.xml\u0026#34;)); t.transform(source, result); StreamResult consoleResult = new StreamResult(System.out); t.transform(source, consoleResult); } } Exécuter "},{"id":10,"href":"/orientee_donnees/legacy/semaine_15/examen_preparatoire/","title":"Examen préparatoire","section":"Semaine 15","content":" Examen préparatoire # Afin de bien vous préparer à l’examen final de ce cours, voici un examen préparatoire.\nExamen factice # Question 1 # Écrire un programme en Java utilisant l\u0026rsquo;API DOM modifiant un fichier XML de manière à ce que le préfixe « foo » soit ajouté aux noms de tous les éléments. Le fichier\n\u0026lt;element\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/element\u0026gt; deviendra donc\n\u0026lt;fooelement\u0026gt;\u0026lt;fooa\u0026gt;\u0026lt;/fooa\u0026gt;\u0026lt;/fooelement\u0026gt;. Vous pouvez supposer que le document ne contient que des éléments, sans attributs, sans espaces de noms.\nQuestion 2 # Même question, mais cette fois-ci, utilisez XSLT pour faire la transformation (indice: pensez à xsl:element).\nQuestion 3 # Dessinez l\u0026rsquo;arbre DOM de ce fichier XML :\n\u0026lt;a xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt;\u0026lt;b type=\u0026#34;x\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; Pour chaque élément et attribut, donner son nom et son espace de noms. (Indice: attention à l\u0026rsquo;espace de noms de l\u0026rsquo;attribut.)\nQuestion 4 # Donnez une DTD équivalente à ce fichier Relax NG :\nelement p { (element c {text}, element d{text}*)? } Question 5 # Écrivez en RDF/XML les triplets suivants :\nsujet : http://www.com.com/jeanne\nprédicat : http://www.w3.org/1999/02/22-rdf-syntax-ns#type\nobjet : http://www.com.com/maman\nsujet : http://www.com.com/maman\nprédicat : http://action.com/etre\nobjet : http://www.com.com/femme\nsujet : http://www.com.com/enfant\nprédicat : http://action.com/avoir\nobjet : http://www.com.com/maman\nQuestion 6 # Définissez et expliquez les différences entre XPath, XLink, XQuery et XSLT.\nQuestion 7 # Que signifie cette expression XPath :\n//table[@border=\u0026ldquo;0\u0026rdquo; and @cellspacing=\u0026ldquo;0\u0026rdquo;] | //table[@border=\u0026ldquo;1\u0026rdquo; and @cellspacing=\u0026ldquo;1\u0026rdquo;]\nQuestion 8 # Que va retourner cette expression XPath :\n//table[@border]\nQuestion 9 # Que va retourner cette expression XPath :\n//table[@border]/@cellspacing\nQuestion 10 # Que va retourner cette expression XPath :\n//table[@border]//[@style]\nQuestion 11 # Que va retourner cette expression XPath :\n//table[@border]//[not(@style)]\nQuestion 12 # Écrivez un programme Java qui applique l\u0026rsquo;expression XPath de la question précédente à un fichier chargé à partir du disque.\nQuestion 13 # Expliquez ce que fera ce fichier XSLT :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns:dc=\u0026#34;http://purl.org/dc/elements/1.1/\u0026#34; \u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; - \u0026lt;xsl:for-each select=\u0026#34;@type\u0026#34; \u0026gt; \u0026lt;li\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt;\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Question 14 # Écrivez une expression XPath qui compte le nombre d\u0026rsquo;éléments ayant été déclarés comme contenant du texte en langue française.\nQuestion 15 # Nommez au moins 3 modèles de programmation XML utilisés en Java.\nQuestion 16 # Définissez AJAX et expliquez pourquoi il s\u0026rsquo;agit d\u0026rsquo;une technique importante en développement web. Quel est le lien entre AJAX et DOM ?\nQuestion 17 # Selon ce fichier CSS, de quelle couleur sera un élément p ?\n* {color: black;} p {color: olive;} body p {color: blue;} body \u0026gt; p {color: red;} body \u0026gt; p {color: green;} * {color: yellow;} Question 18 # Selon le modèle de boîte CSS du W3C, quelle est la hauteur (height) minimale d\u0026rsquo;un objet ayant les propriétés CSS « padding: 10px; » et « margin: 12px; » ?\nQuestion 19 # Donner un exemple de document XML contenant des attributs ID et des attributs IDREF.\nQuestion 20 # Selon ce fragment de DTD, qu\u0026rsquo;est-ce qu\u0026rsquo;il est permis de mettre dans un élément p ? Comment nomme-t-on le concept utilisé ici ?\n\u0026lt;!ENTITY % fontstyle \u0026#34;big | small\u0026#34;\u0026gt; \u0026lt;!ENTITY % phrase \u0026#34;em | cite\u0026#34;\u0026gt; \u0026lt;!ENTITY % in \u0026#34;%fontstyle; | %phrase;\u0026#34;\u0026gt; \u0026lt;!ENTITY % In \u0026#34;(#PCDATA | %in;)*\u0026#34;\u0026gt; \u0026lt;!ELEMENT p %In;\u0026gt; Question 21 # Expliquez les expressions XPath suivantes et décrivez le résultat selon la théorie des ensembles (union, intersection et complément) :\n//*[@s=\u0026#34;1\u0026#34;]//*[@t=\u0026#34;1\u0026#34;] //*[@s=\u0026#34;1\u0026#34;]/[count(//*[@t=\u0026#34;1\u0026#34;])=count(//*[@t=\u0026#34;1\u0026#34;])] //*[@s=\u0026#34;1\u0026#34;]/[count(//*[@t=\u0026#34;1\u0026#34;])=count(//*[@t=\u0026#34;1\u0026#34;])] Question 22 # Comment passe-t-on des paramètres à une feuille de style XSLT à partir d\u0026rsquo;un document XML ?\nQuestion 23 # Quelles sont les principales différences entre JSON et XML en termes de structure et d\u0026rsquo;utilisation ?\nQuestion 24 # Écrivez un exemple de code JavaScript qui parse une chaîne JSON et accède à une propriété imbriquée.\nQuestion 25 # Qu\u0026rsquo;est-ce qu\u0026rsquo;un schéma JSON et pourquoi est-il utile ?\nQuestion 26 # Expliquez la syntaxe de base de YAML et donnez un exemple simple.\nQuestion 27 # Comment YAML se compare-t-il à XML pour la configuration d\u0026rsquo;applications ?\nQuestion 28 # Écrivez un exemple de document YAML qui représente une liste d\u0026rsquo;objets avec des propriétés imbriquées.\nVous avez aimé le cours ? # Si vous avez aimé le cours, voici quelques façons de le montrer :\nParlez du cours autour de vous et partagez vos commentaires positifs en ligne. Visitez la page du professeur pour découvrir les autres cours qu’il a conçus. Si vous avez un compte GitHub, suivez le professeur en cliquant sur le bouton « follow ». Si vous lisez l’anglais, abonnez-vous au blog du professeur. Suivez le professeur sur X. Découvrez les livres écrits par le professeur. Un problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l’amélioration du cours.\n"},{"id":11,"href":"/orientee_donnees/legacy/semaine_5/format_de_document/","title":"Format de document","section":"Semaine 5","content":" Format de document # Le SGML (Standardized General Markup Language) # En 1969, Charles Goldfarb, Edward Mosher et Raymond Lorie ont inventé le GML (Generalized Markup Language). Chercheurs chez IBM, ils voulaient faciliter l\u0026rsquo;échange d\u0026rsquo;informations entre les outils d\u0026rsquo;édition, de formatage et de recherche de documents. Le GML possédait déjà un concept de « type de documents » similaire aux documents DTD modernes. Chez IBM, le GML a été utilisé pour la production d\u0026rsquo;environ 90 % des documents électroniques.\nEn 1978, l\u0026rsquo;American National Standards Institute (ANSI) a travaillé sur un projet de langage de description de textes, basé sur le GML; le projet s\u0026rsquo;est terminé en 1985 par la normalisation du SGML. Le centre de recherche CERN a été l\u0026rsquo;une des premières institutions, outre IBM, à mettre au point des outils pour le SGML.\nOn dit souvent que le SGML est l\u0026rsquo;ancêtre du XML, dans la mesure où les créateurs du XML connaissaient le SGML et voulaient faire mieux. Le HTML est aussi fortement inspiré du SGML et existait au moment où le XML a été proposé. Il n\u0026rsquo;est donc pas surprenant que le XML et le HTML se ressemblent et puissent même se retrouver dans un seul format, le XHTML. La principale difficulté avec le SGML est sa complexité. On considère généralement que partout où le SGML était utilisé, il est maintenant préférable d\u0026rsquo;utiliser le XML. Comme les deux normes sont similaires, on migre souvent du SGML au XML. Quoiqu\u0026rsquo;il y ait de petits ennuis de conversion, le passage au XML permet de traiter les nouveaux documents avec les nombreux outils XML et de suivre la tendance.\nLe SGML n\u0026rsquo;est pas très différent du XHTML. Par exemple, les paragraphes sont spécifiés avec des éléments « para » de la même façon qu\u0026rsquo;ils sont spécifiés avec des éléments « p » en XHTML.\nLe XML comme format de documents # Notons que le SGML, le HTML et le XML sont avant tout des formats de documents. On utilise maintenant le XML comme outil de programmation pour stocker et pour échanger des informations entre les logiciels; toutefois, l\u0026rsquo;objectif des créateurs du XML n\u0026rsquo;était que de créer un format de documents simple et pratique.\nPour les documents, un des avantages des nombreux formats basés sur le XML ou le SGML est qu\u0026rsquo;ils « décrivent l\u0026rsquo;information » au lieu de la présenter. Par la suite, il est facile de publier ou transformer un document XML en document PDF, HTML ou autre, selon les besoins. La séparation du contenu et de sa présentation est un facteur de productivité important parce qu\u0026rsquo;on simplifie la tâche de l\u0026rsquo;écriture, la ramenant au contenu seulement.\nLa séparation du contenu et de sa présentation existe, en partie, dans le XHTML. Par exemple, quand on ajoute un élément de paragraphe « p », on fait un choix qui s\u0026rsquo;appuie sur la logique du texte, non sur son apparence. Quant aux choix des polices, de l\u0026rsquo;espace entre les lignes, de l\u0026rsquo;espace entre les paragraphes ou des couleurs, ils ne sont généralement pas pris en compte par le XHTML. Mais tout n\u0026rsquo;est pas parfait; l\u0026rsquo;utilisation de balises pour appeler de l\u0026rsquo;italique, soit « i » en XHTML, ne nous assure pas une séparation complète entre la présentation et le contenu. Par exemple, il serait plus « logique » d\u0026rsquo;indiquer qu\u0026rsquo;un mot appartient à une langue étrangère et qu\u0026rsquo;il apparaisse dès lors en italique. Ainsi, au lieu d\u0026rsquo;écrire « La vie est \u0026lt;i\u0026gt;cool\u0026lt;/i\u0026gt;. », on aimerait écrire « La vie est \u0026lt;anglais\u0026gt;cool\u0026lt;/anglais\u0026gt;. » ou quelque chose de similaire. Le XHTML constitue donc un compromis entre une séparation complète du contenu et de sa présentation, et l\u0026rsquo;absence de séparation.\nComme nous le verrons dans le troisième module, la façon la plus naturelle de dicter la présentation d\u0026rsquo;un document XHTML est d\u0026rsquo;utiliser un ou plusieurs fichiers CSS. En plaçant les instructions de formatage dans des fichiers CSS, distincts des fichiers XHTML, on obtient une bonne séparation du contenu et de sa présentation. Cette approche a un grand avantage : si on doit changer l\u0026rsquo;apparence d\u0026rsquo;un site web, on peut se contenter d\u0026rsquo;éditer quelques fichiers CSS au lieu de modifier le contenu lui-même qui se trouve dans plusieurs fichiers XHTML. Par exemple, si on veut que le texte contenu dans les tableaux soit en caractères gras et que le texte des listes apparaisse en rouge, on utilisera les instructions CSS suivantes :\ntd {font-weight:bold;} li {color:red;} Le XML est aussi très utile pour aider à l\u0026rsquo;autodescription des informations. Par exemple, si dans un texte vous mettez tous les termes techniques en italique, il est possible que vous puissiez plus tard faire une recherche dans votre document pour tous les termes techniques. Toutefois, quelqu\u0026rsquo;un qui ne connaîtrait pas votre convention pourrait avoir beaucoup de mal à faire la même recherche. Par contre, si vous utilisez un élément particulier pour les termes techniques comme les balises \u0026lt;technique\u0026gt;\u0026lt;/technique\u0026gt;, il devient beaucoup plus facile à quelqu\u0026rsquo;un d\u0026rsquo;autre de s\u0026rsquo;y retrouver dans votre document. On pourrait objecter que l\u0026rsquo;ajout de nombreuses balises alourdira le texte qui occupera alors trop de place sur le disque; l\u0026rsquo;expérience montre que la pérennité des documents doit presque toujours être privilégiée par rapport à l\u0026rsquo;utilisation de l\u0026rsquo;espace disque.\nEn outre, le XML est un format ouvert : on peut utiliser une multitude d\u0026rsquo;outils différents pour manipuler les documents XML; nous ne sommes pas limités à des produits spécifiques à une compagnie ou institution donnée. Le XML a donc l\u0026rsquo;avantage sur plusieurs autres formats quant à sa pérennité.\nLe format DocBook # Développé à partir de 1991, le format DocBook est un format de documents souvent utilisé pour la documentation technique. Le format DocBook est une application SGML qui devient une application XML. Il existe de nombreux outils permettant de transformer un document DocBook en document HTML ou PDF.\nLe format DocBook possède de nombreux avantages pour la rédaction de documents techniques parce qu\u0026rsquo;il assure une grande séparation entre le contenu et sa présentation : il ne permet que des balises ayant trait à la logique du texte; par exemple, il n\u0026rsquo;est pas possible de spécifier une police de caractères en DocBook. L\u0026rsquo;auteur peut alors concentrer son attention sur le contenu du document, sans perdre de temps avec le formatage, qui est une étape ultérieure. La séparation du contenu et de sa présentation permet aussi que plusieurs personnes puissent travailler sur un même projet de documentation tout en assurant une présentation uniforme, parce que DocBook ne comprend pas d\u0026rsquo;instructions de formatage.\nMalheureusement, comme les autres formats hérités du SGML, plusieurs documents en format DocBook sont du SGML et non du XML; on ne peut donc pas utiliser les outils XML pour tous les documents DocBook. Par contre, la situation est en train de changer; il devient plus facile de déterminer si un document est bel et bien un document XML : la déclaration XML placée au début d\u0026rsquo;un document DocBook nous l\u0026rsquo;indique.\nLe format DocBook est fréquemment utilisé dans les projets de logiciels libres et « open source », ainsi que par certaines grandes sociétés, comme IBM. En général, les avantages du format DocBook sont plus visibles dans un contexte de travail d\u0026rsquo;équipe.\nLa création d\u0026rsquo;un document DocBook simple n\u0026rsquo;est pas très difficile. Tout d\u0026rsquo;abord, bien qu\u0026rsquo;elle puisse varier selon les versions, la déclaration de type de document d\u0026rsquo;un document DocBook ressemble à ceci :\n\u0026lt;!DOCTYPE book PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; Dans ce cas, on voit que le document DTD se trouve à l\u0026rsquo;adresse :\nhttp://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd Il faut cependant noter qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un document DTD qui dépend d\u0026rsquo;autres documents DTD et que la lecture d\u0026rsquo;un tel type de document DTD n\u0026rsquo;est pas très facile.\nL\u0026rsquo;élément-racine d\u0026rsquo;un document DocBook peut varier, mais les deux principales structures sont « book » (livre) et « article »; notez que l\u0026rsquo;on peut commencer par l\u0026rsquo;une ou l\u0026rsquo;autre :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;book\u0026gt; (...) \u0026lt;/book\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE article PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;article\u0026gt; (...) \u0026lt;/article\u0026gt; Ensuite, on doit ajouter un élément « bookinfo » ou « articleinfo », selon que le document est un livre ou un article. Le plus souvent, les éléments en question contiennent un élément « title » contenant le titre, ainsi qu\u0026rsquo;un élément « author » qui contiendra les éléments « firstname » (prénom) et « surname » (nom de famille). On peut aussi ajouter un élément « copyright » (droit d\u0026rsquo;auteur) qui contiendra un élément « year » (année) et un élément « holder » (titulaire). Voici quelques structures courantes de documents DocBook :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Alexis\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Letrotteur\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;Bell Canada\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; (...) \u0026lt;/book\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE article PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;article\u0026gt; \u0026lt;articleinfo\u0026gt; \u0026lt;title\u0026gt;Le sens de la vie\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Gilles\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Proulx\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt; \u0026lt;holder\u0026gt;Gouvernement du Canada\u0026lt;/holder\u0026gt; \u0026lt;/copyright\u0026gt; \u0026lt;/articleinfo\u0026gt; (...) \u0026lt;/article\u0026gt; L\u0026rsquo;élément de base d\u0026rsquo;un document DocBook est l\u0026rsquo;élément « para » qui note la présence d\u0026rsquo;un paragraphe. Dans le cas d\u0026rsquo;un livre, on va le plus souvent faire suivre l\u0026rsquo;élément « bookinfo » d\u0026rsquo;éléments « chapter » (chapitre), qui eux-mêmes peuvent contenir des éléments « section », comme dans l\u0026rsquo;exemple qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Alexis\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Letrotteur\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;Bell Canada\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Premier chapitre\u0026lt;/title\u0026gt; \u0026lt;section\u0026gt; \u0026lt;title\u0026gt;Première section du premier chapitre\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Mettre ici le premier paragraphe de la première section.\u0026lt;/para\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Observe que tous les éléments « chapter », ainsi que tous les éléments « section » débutent par un élément « title » : c\u0026rsquo;est souvent suffisant. Il n\u0026rsquo;est pas permis de commencer un élément « section » ou « chapter » directement par un élément « para ». Par contre, on pourrait omettre d\u0026rsquo;avoir des sections dans nos chapitres, comme dans l\u0026rsquo;exemple qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Alexis\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Letrotteur\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;Bell Canada\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Premier chapitre\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Mettre ici le premier paragraphe du premier chapitre.\u0026lt;/para\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Dans le cas d\u0026rsquo;un simple article, nous n\u0026rsquo;utiliserons pas les éléments « chapitre » et il suffit, le plus souvent, d\u0026rsquo;utiliser des éléments « section », comme dans l\u0026rsquo;exemple qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#39;ISO-8859-1\u0026#39; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE article PUBLIC \u0026#34;-//OASIS//DTD DocBook XML V4.4CR2//EN\u0026#34; \u0026#34;http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\u0026#34;\u0026gt; \u0026lt;article\u0026gt; \u0026lt;articleinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Alexis\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Letrotteur\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;Bell Canada\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/articleinfo\u0026gt; \u0026lt;section\u0026gt; \u0026lt;title\u0026gt;Première section de l\u0026#39;article\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Mettre ici le premier paragraphe de la première section.\u0026lt;/para\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;title\u0026gt;Deuxième section de l\u0026#39;article\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Mettre ici le premier paragraphe de la seconde section.\u0026lt;/para\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/article\u0026gt; On pourrait aussi utiliser les éléments « sect1 », « sect2 », « sect3 » et ainsi de suite, pour obtenir les notions de section, sous-section, sous-sous-section et ainsi de suite.\nComme le format DocBook est destiné à la documentation technique, il existe plusieurs balises pour décrire le code informatique. L\u0026rsquo;élément le plus simple est l\u0026rsquo;élément « programlisting ». Ainsi, pour ajouter un petit programme Java dans un document DocBook, on utilisera l\u0026rsquo;élément suivant :\n\u0026lt;programlisting\u0026gt; public static void main(String[] arg) { System.out.println(\u0026#34;Allo!\u0026#34;); } \u0026lt;/programlisting\u0026gt; On peut également placer un élément « programlisting » dans les éléments « section », « chapter », « para », etc.\nTout comme en HTML, on peut créer des listes avec les éléments « itemizedlist » (liste non ordonnée, équivalent de « ul » en HTML) et « orderedlist » (liste ordonnée, équivalent de « ol » en HTML). Une liste est constituée d\u0026rsquo;éléments « listitem » qui ne peuvent contenir directement du texte : on met généralement des éléments « para » dans les éléments « listitem ». Par contre, les éléments « listitem » ne peuvent apparaître hors des éléments « itemizedlist » et « orderedlist ». En outre, on place les listes dans les éléments « chapter », « section », etc. Voici quelques exemples :\n\u0026lt;itemizedlist\u0026gt; \u0026lt;listitem\u0026gt; \u0026lt;para\u0026gt;un triangle\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;listitem\u0026gt; \u0026lt;para\u0026gt;un losange\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;/itemizedlist\u0026gt; \u0026lt;orderedlist\u0026gt; \u0026lt;listitem\u0026gt; \u0026lt;para\u0026gt;Premier élément (numéro 1)\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;listitem\u0026gt; \u0026lt;para\u0026gt;Second élément (numéro 2)\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;/orderedlist\u0026gt; Le format DocBook est supporté par certains traitement de textes comme OpenOffice qui est disponible gratuitement.\nL\u0026rsquo;ODF (Open Document Format) # Historiquement, les formats de bureautiques ont été propriétaires, que ce soit le format WordPerfect ou le format Microsoft Word. Pour une institution, cela pose le problème de la pérennité des documents : qu\u0026rsquo;est-ce qui se produit si la compagnie qui propose un format décide de ne plus supporter un ancien format, parce qu\u0026rsquo;elle fait faillite ou change sa stratégie commerciale ? Qu\u0026rsquo;est-ce qui se produit si elle décide d\u0026rsquo;augmenter le coût de ses produits ? L\u0026rsquo;Open Document Format (ODF) est une norme XML adoptée en mai 2005 par OASIS et est devenu une norme ISO (ISO 26300.2006) le 30 novembre 2006. Le format ODF est un format XML que tout le monde peut utiliser librement. Nous allons voir différentes techniques dans ce cours qui permettent de manipuler des documents XML et elles s\u0026rsquo;appliquent au format ODF.\nLe format ODF n\u0026rsquo;est pas très différent des nouveaux formats Open XML utilisés par Microsoft Office, mais au lieu de n\u0026rsquo;être soutenu que par une seule compagnie, ODF provient d\u0026rsquo;une entente entre plusieurs grandes sociétés : Adobe Systems, IBM, Intel, Novell et Sun Microsystems. Dans les deux cas (ODF et Open XML), les fichiers XML sont mis dans une archive compressée et nous avons accès à la sémantique des balises XML. Le logiciel OpenOffice utilise le format ODF et a les avantages d\u0026rsquo;être gratuit et disponible pour une variété de systèmes (Apple, Linux, Microsoft, etc.). Il est aussi possible de créer des documents ODF à partir de Microsoft Office 2007 à l\u0026rsquo;aide d\u0026rsquo;une composante logicielle supplémentaire (Open XML Translator).\n"},{"id":12,"href":"/orientee_donnees/legacy/semaine_1/installation_dun_navigateur_moderne/","title":"Installation d’un navigateur moderne","section":"Legacies","content":" Installation d’un navigateur moderne # Si le système d’exploitation de votre ordinateur est Windows et que vous n’avez pas mis à jour votre système depuis très, très longtemps, vous utilisez peut-être Internet Explorer (IE). Malheureusement, ce navigateur ne supporte pas pleinement le XML. Nous vous demandons de télécharger un autre navigateur moderne : par exemple Google Chrome, Brave, Firefox, Safari ou Microsoft Edge.\nPour installer Google Chrome, rendez-vous à l’adresse https://www.google.ca/chrome/ ; lisez les informations, sélectionnez le fichier correspondant à votre système d’exploitation et téléchargez-le ; lancez ensuite la procédure d’installation et suivez bien les directives données. Sous Windows, il est possible que vous deviez faire redémarrer votre ordinateur après l’installation.\nPour installer Microsoft Edge, rendez-vous à l’adresse https://www.microsoft.com/en-us/edge ; lisez les informations, sélectionnez le fichier correspondant à votre système d’exploitation et téléchargez-le ; lancez ensuite la procédure d’installation et suivez bien les directives données.\nPour installer Brave, rendez-vous à l’adresse https://brave.com/ ; lisez les informations, sélectionnez le fichier correspondant à votre système d’exploitation et téléchargez-le ; lancez ensuite la procédure d’installation et suivez bien les directives données.\nSi vous utilisez un environnement Apple, le navigateur Safari fait bien l\u0026rsquo;affaire.\n"},{"id":13,"href":"/orientee_donnees/legacy/semaine_6/les_documents_epub/","title":"Les documents EPUB","section":"Semaine 6","content":" Les documents EPUB # Le livre électronique émerge comme norme dans l’édition. Bien qu’il existe plusieurs formats possibles, nous allons nous concentrer plus particulièrement dans ce cours sur le format EPUB qui est souvent utilisé. Il est notamment supporté par les plateformes iBooks d’Apple, Kobo, etc. Amazon utilise un format similaire pour le Kindle, mais comme il est propre à Amazon, nous ne nous y attarderons pas.1\nLe format EPUB peut être décrit sommairement comme du XHTML que l’on place dans une archive compressée zip. On peut se demander pourquoi les éditeurs préfèrent un tel format à quelque chose d’autre, comme le format PDF. Le format PDF est malheureusement mal adapté aux livres électroniques parce qu’il suppose que le document sera imprimé sur papier. Il comporte donc une notion fixée d’avance de page. Dans une liseuse électronique, la taille de la page dépend de la taille de l’écran et des goûts du lecteur.\nUn outil gratuit, Calibre, permet de convertir les livres électroniques entre différents formats.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":14,"href":"/orientee_donnees/legacy/semaine_11/modeles_de_programmation/","title":"Modèles de programmation","section":"Semaine 11","content":" Modèles de programmation XML # Il y a plusieurs façons de traiter du XML. Chaque méthode a ses avantages et ses inconvénients. Bien que ce module s\u0026rsquo;intéresse surtout à l\u0026rsquo;approche DOM, il est important de connaître l\u0026rsquo;ensemble des méthodologies possibles et d\u0026rsquo;avoir une idée des forces et faiblesses relatives de chacune.\nTraitement du XML comme du texte # Le traitement du XML comme du texte consiste à manipuler les fichiers XML en utilisant les fonctions de traitement de chaînes de caractères disponibles dans les langages de programmation. Cette approche est simple à implémenter mais peut être source d\u0026rsquo;erreurs si le XML n\u0026rsquo;est pas correctement formé.\nint montant = 10; String nom = \u0026#34;Gérard Beauford\u0026#34;; System.out.println(\u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; ?\u0026gt;\\n\u0026lt;facture\u0026gt;\u0026lt;montant\u0026gt;\u0026#34; + montant + \u0026#34;\u0026lt;/montant\u0026gt;\u0026lt;nom\u0026gt;\u0026#34; + nom + \u0026#34;\u0026lt;/nom\u0026gt;\u0026lt;/facture\u0026gt;\u0026#34;); Cependant, comment savoir si le XML produit est bien formé ? Dans l\u0026rsquo;exemple précédent, le document affiché ne sera pas du XML bien formé à cause de l\u0026rsquo;accent dans « Gérard » si l\u0026rsquo;environnement n\u0026rsquo;utilise pas UTF-8. Il est donc préférable d\u0026rsquo;utiliser des librairies dédiées au XML.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;432\u0026lt;/montant\u0026gt; \u0026lt;nom\u0026gt;Gérard Beauford\u0026lt;/nom\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE facture [ \u0026lt;!ELEMENT facture (montant, nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST nom surnom CDATA \u0026#34;Joe\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;facture\u0026gt;\u0026lt;montant\u0026gt;432\u0026lt;/montant\u0026gt;\u0026lt;nom\u0026gt;Gérard Beauford\u0026lt;/nom\u0026gt;\u0026lt;/facture\u0026gt; Traitement événementiel # Le traitement événementiel, comme SAX, lit le document XML de manière séquentielle et génère des événements à chaque élément rencontré. Cette méthode est efficace pour les gros fichiers mais nécessite une gestion manuelle de l\u0026rsquo;état.\nPour le document suivant :\n\u0026lt;facture\u0026gt;\u0026lt;montant\u0026gt;432\u0026lt;/montant\u0026gt;\u0026lt;nom\u0026gt;Maman\u0026lt;/nom\u0026gt;\u0026lt;/facture\u0026gt; Événements SAX générés :\nDébut du document Début d\u0026rsquo;un élément « facture » Début d\u0026rsquo;un élément « montant » Texte « 432 » Fin d\u0026rsquo;un élément « montant » Début d\u0026rsquo;un élément « nom » Texte « Maman » Fin d\u0026rsquo;un élément « nom » Fin d\u0026rsquo;un élément « facture » Fin du document import java.io.*; import org.xml.sax.*; import org.xml.sax.helpers.*; public class MonApplicationSAX extends DefaultHandler { public void startElement(String uri, String name, String qName, Attributes atts) { if (uri.length() \u0026gt; 0) System.out.println(\u0026#34;Début de l\u0026#39;élément \u0026#34; + uri + \u0026#34;:\u0026#34; + qName); else System.out.println(\u0026#34;Début de l\u0026#39;élément \u0026#34; + name); } public void endElement(String uri, String name, String qName) { if (uri.length() \u0026gt; 0) System.out.println(\u0026#34;Fin de l\u0026#39;élément \u0026#34; + uri + \u0026#34;:\u0026#34; + qName); else System.out.println(\u0026#34;Fin de l\u0026#39;élément \u0026#34; + name); } public void characters(char[] ch, int start, int length) { System.out.print(new String(ch, start, length)); } public static void main(String[] args) throws Exception { XMLReader xr = XMLReaderFactory.createXMLReader(); xr.setContentHandler(new MonApplicationSAX()); xr.parse(new InputSource(new FileReader(args[0]))); } } Traitement avec itérateurs (StAX) # StAX (Streaming API for XML) offre une approche \u0026ldquo;pull\u0026rdquo; plus intuitive que SAX, permettant au programmeur de contrôler la lecture du document XML de manière itérative.\nimport javax.xml.stream.*; import java.net.*; import java.io.*; public class staxex { public static void main(String[] args) { String input = args[0]; try { URL u = new URL(input); InputStream in = u.openStream(); XMLInputFactory factory = XMLInputFactory.newInstance(); XMLStreamReader parser = factory.createXMLStreamReader(in); for (int event = parser.next(); event != XMLStreamConstants.END_DOCUMENT; event = parser.next()) { switch (event) { case XMLStreamConstants.START_ELEMENT: System.out.println(parser.getLocalName()); break; case XMLStreamConstants.END_ELEMENT: System.out.println(parser.getLocalName()); break; case XMLStreamConstants.CDATA: System.out.print(parser.getText()); break; } } parser.close(); } catch (Exception ex) { System.out.println(ex); } } } Traitement avec modèle en arbre (DOM) # Le modèle DOM (Document Object Model) charge l\u0026rsquo;intégralité du document XML en mémoire sous forme d\u0026rsquo;arbre d\u0026rsquo;objets, permettant une navigation et une manipulation faciles mais consommatrice de ressources. Un document XML peut être vu comme un arbre. Le DOM charge tout le document en mémoire sous forme d\u0026rsquo;objets. Le DOM sera vu en détail la semaine prochaine.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE facture [...]\u0026gt; \u0026lt;facture\u0026gt;\u0026lt;montant\u0026gt;432\u0026lt;/montant\u0026gt; \u0026lt;nom\u0026gt;Gérard Beauford\u0026lt;/nom\u0026gt;\u0026lt;/facture\u0026gt; Représentation en arbre :\nDocument └─ facture ├─ montant → \u0026#34;432\u0026#34; └─ nom (surnom=\u0026#34;Joe\u0026#34;) → \u0026#34;Gérard Beauford\u0026#34; Transformations (XSLT) # XSLT (eXtensible Stylesheet Language Transformations) est un langage de transformation XML qui permet de convertir des documents XML vers d\u0026rsquo;autres formats comme HTML ou texte de manière déclarative. XSLT est idéal pour les transformations simples (XML → HTML, XML → texte…). Pour des traitements complexes avec bases de données, il est insuffisant.\nXPath # XPath est un langage d\u0026rsquo;expression qui permet de naviguer et d\u0026rsquo;extraire des données spécifiques dans un document XML de manière concise et puissante. XPath permet d\u0026rsquo;extraire très simplement des données depuis Java.\nimport javax.xml.parsers.*; import javax.xml.xpath.*; DocumentBuilder builder = DocumentBuilderFactory.newInstance() .newDocumentBuilder(); Document doc = builder.parse(\u0026#34;http://www.mondomaine.com/monfichier.xml\u0026#34;); XPath xpath = XPathFactory.newInstance().newXPath(); String title = xpath.evaluate(\u0026#34;//nom/text()\u0026#34;, doc); Sérialization Java # La sérialisation en Java permet de convertir l\u0026rsquo;état d\u0026rsquo;un objet en un flux d\u0026rsquo;octets, afin de le stocker (par exemple dans un fichier) ou de le transmettre sur un réseau. Le processus inverse, la désérialisation, recrée l\u0026rsquo;objet à partir de ce flux. Ce mécanisme est particulièrement utile pour persister des données ou échanger des objets entre applications.\nL\u0026rsquo;interface centrale est java.io.Serializable, située dans le package java.io. Il s\u0026rsquo;agit d\u0026rsquo;une interface marqueur : elle ne contient aucune méthode ni champ à implémenter. Une classe devient sérialisable simplement en l\u0026rsquo;implémentant. Toutes ses sous-classes héritent automatiquement de cette propriété. Si un objet référencé n\u0026rsquo;implémente pas Serializable, une exception NotSerializableException est levée lors de la sérialisation.\nPour effectuer la sérialisation, on utilise ObjectOutputStream avec sa méthode writeObject(). Pour la désérialisation, ObjectInputStream et readObject(). Les champs statiques ne sont pas sérialisés, car ils appartiennent à la classe, pas à l\u0026rsquo;instance. Les champs marqués transient sont exclus du processus ; ils reprennent leur valeur par défaut lors de la désérialisation.\nUn aspect important est la gestion des versions avec serialVersionUID. Il s\u0026rsquo;agit d\u0026rsquo;un champ private static final long que l\u0026rsquo;on déclare explicitement dans la classe. Sans cela, la JVM calcule une valeur par défaut basée sur la structure de la classe (méthodes, champs, etc.). Toute modification de la classe peut changer cette valeur, provoquant une InvalidClassException lors de la désérialisation d\u0026rsquo;un ancien flux. Il est recommandé de toujours définir un serialVersionUID explicite pour assurer la compatibilité.\nPour un contrôle plus fin, on peut implémenter des méthodes privées comme writeObject() et readObject() pour personnaliser le processus, ou utiliser Externalizable pour une implémentation complète (avec writeExternal() et readExternal()).\nVoici un exemple complet et fonctionnel de sérialisation/désérialisation en Java utilisant l\u0026rsquo;interface Serializable. Le programme crée un objet, le sérialise dans un fichier, puis le désérialise et l\u0026rsquo;affiche.\nExempleSerializable.java import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; class Personne implements Serializable { private static final long serialVersionUID = 1L; private String nom; private int age; private transient String motDePasse; // ne sera pas sérialisé public Personne(String nom, int age, String motDePasse) { this.nom = nom; this.age = age; this.motDePasse = motDePasse; } @Override public String toString() { return \u0026#34;Personne{nom=\u0026#39;\u0026#34; \u0026#43; nom \u0026#43; \u0026#34;\u0026#39;, age=\u0026#34; \u0026#43; age \u0026#43; \u0026#34;, motDePasse=\u0026#39;\u0026#34; \u0026#43; motDePasse \u0026#43; \u0026#34;\u0026#39;}\u0026#34;; } } public class ExempleSerializable { private static final String FICHIER = \u0026#34;personne.ser\u0026#34;; public static void main(String[] args) { // Sérialisation Personne originale = new Personne(\u0026#34;Alice\u0026#34;, 30, \u0026#34;secret123\u0026#34;); System.out.println(\u0026#34;Objet original : \u0026#34; \u0026#43; originale); try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FICHIER))) { oos.writeObject(originale); System.out.println(\u0026#34;Sérialisation réussie dans \u0026#34; \u0026#43; FICHIER); } catch (Exception e) { e.printStackTrace(); } // Désérialisation try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FICHIER))) { Personne recuperee = (Personne) ois.readObject(); System.out.println(\u0026#34;Objet désérialisé : \u0026#34; \u0026#43; recuperee); // Note : motDePasse vaut null car il était transient } catch (Exception e) { e.printStackTrace(); } } } Exécuter Réflexion # La réflexion joue un rôle crucial dans les mécanismes de sérialisation et de désérialisation en Java, permettant un traitement générique et dynamique des objets sans nécessiter de code spécifique pour chaque classe. Par exemple, la sérialisation native de Java (via java.io.Serializable) utilise la réflexion pour inspecter automatiquement les champs d\u0026rsquo;une classe, y compris les champs privés, et les écrire dans un flux binaire. Lors de la désérialisation, elle crée une instance vide de la classe (sans appeler de constructeur) et remplit les champs via la réflexion, en ignorant les validations potentielles des constructeurs.\nCette approche rend la sérialisation transparente.Des bibliothèques tierces comme Gson ou Jackson exploitent également la réflexion pour des formats comme JSON ou XML. Elles inspectent les champs (via getDeclaredFields()) ou les méthodes getter/setter, lisent ou écrivent leurs valeurs dynamiquement, et gèrent récursivement les objets imbriqués, les collections ou les types génériques.\nVoici un exemple simple illustrant comment implémenter une sérialisation basique vers JSON en utilisant la réflexion. Considérons à nouveau la classe Personne :\npublic class Personne { private String nom; private int age; public Personne(String nom, int age) { this.nom = nom; this.age = age; } // Getters pour l\u0026#39;exemple public String getNom() { return nom; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Personne{nom=\u0026#39;\u0026#34; + nom + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } Une méthode de sérialisation personnalisée en JSON via réflexion pourrait ressembler à ceci (simplifiée, sans gestion des cycles ou des types complexes).\nSimpleJsonSerializer.java import java.lang.reflect.Field; import java.util.StringJoiner; class Personne { private String nom; private int age; public Personne(String nom, int age) { this.nom = nom; this.age = age; } // Getters pour l\u0026#39;exemple public String getNom() { return nom; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Personne{nom=\u0026#39;\u0026#34; \u0026#43; nom \u0026#43; \u0026#34;\u0026#39;, age=\u0026#34; \u0026#43; age \u0026#43; \u0026#34;}\u0026#34;; } } public class SimpleJsonSerializer { public static String serialize(Object obj) throws IllegalAccessException { Class\u0026lt;?\u0026gt; classe = obj.getClass(); StringJoiner json = new StringJoiner(\u0026#34;, \u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;); for (Field field : classe.getDeclaredFields()) { field.setAccessible(true); // Accès aux champs privés Object value = field.get(obj); String valueStr = value instanceof String ? \u0026#34;\\\u0026#34;\u0026#34; \u0026#43; value \u0026#43; \u0026#34;\\\u0026#34;\u0026#34; : String.valueOf(value); json.add(\u0026#34;\\\u0026#34;\u0026#34; \u0026#43; field.getName() \u0026#43; \u0026#34;\\\u0026#34;: \u0026#34; \u0026#43; valueStr); } return json.toString(); } public static void main(String[] args) throws Exception { Personne p = new Personne(\u0026#34;Alice\u0026#34;, 30); String json = serialize(p); System.out.println(json); // Affiche : {\u0026#34;nom\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} } } Exécuter Pour la désérialisation, on pourrait instancier la classe via réflexion (classe.getDeclaredConstructor().newInstance()), puis setter les valeurs des champs de la même manière. Des bibliothèques comme Jackson font cela de façon beaucoup plus robuste, en gérant les annotations (comme @JsonProperty) pour personnaliser le mapping. (Les annotations en Java sont des métadonnées prenant la forme @... que l\u0026rsquo;on peut ajouter au code source pour fournir des informations supplémentaires au compilateur, aux outils de développement ou aux programmes exécutés à l\u0026rsquo;exécution. Vous pouvez même définir vos propres annotations.)\nTraitement par abstraction # Le traitement par abstraction utilise des bibliothèques de haut niveau qui masquent la complexité du XML, permettant de travailler avec des objets métier sans se soucier du format de sérialisation. De nombreuses bibliothèques (JAXB, bases de données, frameworks) manipulent du XML sans jamais vous forcer à écrire du XML à la main. Ils utilisent souvent la réflexion.\nSérialisation XML Java Beans # La sérialisation XML d\u0026rsquo;objet Java avec Bean permet de convertir des objets Java en XML et vice-versa, facilitant la persistance et l\u0026rsquo;échange de données. Prenez quelques secondes pour exécuter le programme suivant.\nSerialization.java import java.beans.*; import java.io.*; public class Serialization { public static void main(String[] args) { try { String o = new String(\u0026#34;Un objet java\u0026#34;); File f = new File(\u0026#34;test.xml\u0026#34;); // Sérialisation en XML XMLEncoder e = new XMLEncoder( new BufferedOutputStream(new FileOutputStream(f))); e.writeObject(o); e.close(); // Désérialisation XMLDecoder d = new XMLDecoder( new BufferedInputStream(new FileInputStream(f))); Object lu = d.readObject(); d.close(); // Affichage clair du résultat System.out.println(\u0026#34;Objet original : \u0026#34; \u0026#43; o); System.out.println(\u0026#34;Objet lu depuis le fichier XML : \u0026#34; \u0026#43; lu); System.out.println(\u0026#34;Les deux objets sont égaux : \u0026#34; \u0026#43; lu.equals(o)); System.out.println(\u0026#34;Type de l\u0026#39;objet lu : \u0026#34; \u0026#43; lu.getClass().getName()); } catch (Exception ex) { System.err.println(\u0026#34;Erreur lors de la sérialisation/désérialisation :\u0026#34;); ex.printStackTrace(); } } } Exécuter Ce programme montre un exemple simple de sérialisation et de désérialisation d’un objet Java en format XML à l’aide des classes XMLEncoder et XMLDecoder du package java.beans. Contrairement à la sérialisation binaire classique avec ObjectOutputStream, ces deux classes permettent de transformer des objets Java en un fichier XML lisible par un humain, puis de reconstruire l’objet à partir de ce fichier. Elles sont particulièrement pratiques pour sauvegarder l’état d’objets simples (String, collections, beans Java standards) de façon portable et modifiable manuellement.\nDans la méthode main, on commence par créer un objet simple : une instance de String contenant le texte \u0026ldquo;Un objet java\u0026rdquo;. Ensuite, on crée un fichier nommé \u0026ldquo;test.xml\u0026rdquo;. C’est dans ce fichier que l’objet sera sauvegardé au format XML. On utilise un XMLEncoder enveloppé dans un BufferedOutputStream et un FileOutputStream pour écrire efficacement les données. La méthode writeObject(o) déclenche la conversion de l’objet String en une représentation XML complète, puis e.close() ferme proprement le flux et écrit effectivement le contenu dans le fichier.\nImmédiatement après la sérialisation, le programme passe à la désérialisation. On ouvre le même fichier \u0026ldquo;test.xml\u0026rdquo; en lecture avec un XMLDecoder, également entouré d’un BufferedInputStream pour optimiser les performances. L’appel à d.readObject() lit le premier (et ici unique) objet présent dans le XML et le reconstruit en mémoire sous forme d’objet Java. Comme le fichier a été généré par XMLEncoder, la reconstruction est parfaitement fidèle : on retrouve exactement le même String d’origine.\nPour vérifier que tout a fonctionné correctement, le programme affiche plusieurs informations : l’objet original, l’objet reconstitué, le résultat du test d’égalité avec equals() (qui renvoie true), et enfin le type réel de l’objet lu (java.lang.String). Cela prouve que non seulement la valeur est identique, mais que l’objet a bien été recréé avec son vrai type et non comme un type générique Object ou autre.\nEnfin, tout le code est placé dans un bloc try-catch qui attrape n’importe quelle Exception (problème d’accès au fichier, erreur de parsing XML, etc.) et affiche la stack trace complète sur la sortie d’erreur. Cela rend le programme robuste et facile à déboguer. En exécutant ce code, vous obtiendrez un fichier test.xml contenant une représentation XML claire de la String, et vous verrez dans la console que l’objet a été parfaitement sauvegardé et restauré sans aucune perte d’information.\nCette approche ne fonctionne pas avec tout objet Java, et c’est une limitation importante de XMLEncoder/XMLDecoder. Ces classes ne gèrent correctement que les objets dits « Java Beans » ou les types primitifs et leurs wrappers, les String, les collections standards (List, Map, Set…), les arrays, les Date, et quelques autres classes courantes du JDK. Pour qu’un objet soit sérialisable en XML avec ce mécanisme, il doit respecter les propriétés suivantes : il doit avoir un constructeur sans argument (constructor par défaut), ses propriétés doivent être accessibles via des getters et setters respectant la convention JavaBeans (getNom() / setNom() ou isNom() pour les boolean), et il ne doit pas contenir de références circulaires complexes ni de champs transient qui seraient ignorés.\nEn Java, les getters et setters sont des méthodes conventionnelles utilisées pour accéder et modifier les attributs privés d\u0026rsquo;une classe, dans le cadre de l\u0026rsquo;encapsulation, un principe fondamental de la programmation orientée objet. Un getter, souvent préfixé par \u0026ldquo;get\u0026rdquo;, permet de récupérer la valeur d\u0026rsquo;un attribut sans exposer directement celui-ci, tandis qu\u0026rsquo;un setter, préfixé par \u0026ldquo;set\u0026rdquo;, autorise la modification de cette valeur tout en pouvant inclure des validations ou des contrôles pour garantir l\u0026rsquo;intégrité des données. Par exemple, considérons une classe simple représentant une personne.\npublic class Personne { private String nom; private int age; // Getter pour nom public String getNom() { return nom; } // Setter pour nom public void setNom(String nom) { this.nom = nom; } // Getter pour age public int getAge() { return age; } // Setter pour age avec validation public void setAge(int age) { if (age \u0026gt;= 0 \u0026amp;\u0026amp; age \u0026lt;= 150) { this.age = age; } else { throw new IllegalArgumentException(\u0026#34;L\u0026#39;âge doit être entre 0 et 150\u0026#34;); } } } Si vous essayez de sérialiser un objet personnalisé qui ne respecte pas ces règles (par exemple une classe sans constructeur vide, avec des champs private sans getters/setters, ou contenant des objets tiers comme une connexion JDBC, un Thread, un Socket, ou une classe du type java.awt.Component), XMLEncoder lèvera généralement une exception ou produira un XML incomplet, voire ignorera silencieusement certaines parties de l’objet.\nDe plus, XMLEncoder ne conserve pas l’identité des objets en cas de références partagées : chaque occurrence d’un même objet sera dupliquée lors de la désérialisation, contrairement à la sérialisation binaire classique qui préserve les références. Cela peut poser problème pour des structures de données complexes avec des graphes d’objets.\nServices web # Les services web REST utilisent les méthodes HTTP standard pour exposer des ressources XML via des API web, permettant l\u0026rsquo;interopérabilité entre différentes plateformes.\nLes services web REST utilisent simplement HTTP (GET, POST, PUT, DELETE).\nMéthode Description GET Récupérer une ressource (sûre et idempotente) POST Créer ou modifier (non idempotente) PUT Créer/remplacer une ressource à l\u0026rsquo;URI donnée DELETE Supprimer une ressource Le programme Java suivant interroge le service de recherche SRU (Search/Retrieve via URL) de la Bibliothèque du Congrès américain pour récupérer l’enregistrement bibliographique MARC21 correspondant au titre exact « First Impressions of the New World ». Il construit une requête HTTP contenant les paramètres nécessaires (opération de recherche, version du protocole, critère de recherche sur le titre Dublin Core, limitation à un seul résultat et demande du format MARCXML), ouvre la connexion réseau, télécharge la réponse XML directement depuis l’URL, la parse en tenant compte des espaces de noms, puis utilise une expression XPath pour extraire précisément la chaîne du « leader » (les 24 premiers caractères de l’enregistrement MARC qui décrivent le type de document, son statut, sa longueur, etc.) et l’affiche dans la console. En résumé, il effectue une recherche catalographique distante et récupère un élément technique clé de la notice MARC correspondante.\nExemple.java import org.w3c.dom.Document; import javax.xml.parsers.*; import javax.xml.xpath.*; import javax.xml.namespace.NamespaceContext; import java.net.URL; import java.util.Iterator; public class Exemple { public static void main(String[] args) throws Exception { String base = \u0026#34;http://z3950.loc.gov:7090/voyager?\u0026#34;; String requete = \u0026#34;operation=searchRetrieve\u0026version=1.1\u0026#34; \u0026#43; \u0026#34;\u0026query=(dc.title=%22First%20Impressions%20of%20the%20New%20World%22)\u0026#34; \u0026#43; \u0026#34;\u0026maximumRecords=1\u0026recordSchema=marcxml\u0026#34;; String urlComplete = base \u0026#43; requete; // Création du parseur XML avec prise en charge des espaces de noms DocumentBuilderFactory fabrique = DocumentBuilderFactory.newInstance(); fabrique.setNamespaceAware(true); // Indispensable pour les réponses MARCXML/SRU Document document = fabrique.newDocumentBuilder().parse(new URL(urlComplete).openStream()); XPath xpath = XPathFactory.newInstance().newXPath(); // Définition de l\u0026#39;espace de noms MARC21 xpath.setNamespaceContext(new NamespaceContext() { @Override public String getNamespaceURI(String prefixe) { return \u0026#34;marc\u0026#34;.equals(prefixe) ? \u0026#34;http://www.loc.gov/MARC21/slim\u0026#34; : null; } @Override public String getPrefix(String uri) { return null; } @Override public Iterator\u0026lt;String\u0026gt; getPrefixes(String uri) { return null; } }); // Extraction du leader MARC String leader = xpath.evaluate(\u0026#34;//marc:leader/text()\u0026#34;, document); System.out.println(\u0026#34;Leader MARC : \u0026#34; \u0026#43; leader); } } Exécuter "},{"id":15,"href":"/orientee_donnees/docs/modules/b_module_xml/","title":"Module XML","section":"Modules","content":" Module XML # Ce module approfondit le langage XML (eXtensible Markup Language) et ses écosystèmes. Il commence par les bases : structure arborescente, création de documents, principes fondamentaux, et mise en forme avec CSS. Le module couvre ensuite les espaces de noms pour éviter les conflits, des exemples pratiques d\u0026rsquo;utilisation du XML dans des formats réels (AndroidManifest.xml, pom.xml, sitemaps, RSS), et la programmation avec DOM pour le traitement XML en Java et en JavaScript. La librairie Jackson pour le traitement de JSON et du XML est présentée. Une section est dédiée au RDF (Resource Description Framework) et SPARQL pour le web sémantique. Enfin, la validation des documents XML avec DTD et schémas est abordée. Le module inclut également une introduction à Open XML, le format ouvert utilisé par Microsoft Office pour les documents Word, Excel et PowerPoint.\nUn problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l\u0026rsquo;amélioration du cours.\n"},{"id":16,"href":"/orientee_donnees/docs/modules/b_module_xml/base/principes_du_xml/","title":"Principes du XML","section":"Les fondements","content":" Principes du XML # Quelques principes et notions importantes du XML # Rappelons qu\u0026rsquo;une balise est un segment de texte commençant par \u0026lt; et se terminant par \u0026gt;. Par exemple, est une balise qui marque le début de l\u0026rsquo;élément lavie. Une balise commençant par \u0026lt;/, comme , est une balise de fin; dans cet exemple, elle termine l\u0026rsquo;élément lavie.\nLe nom XML de la balise est le texte suivant le symbole \u0026lt; (ou \u0026lt;/ pour une balise de fin) et pouvant contenir n\u0026rsquo;importe quelle lettre ou chiffre (a, b,\u0026hellip; 0, 1, 2,\u0026hellip;) ou les quatre symboles de ponctuation, soit la marque de soulignement ( _ ), le trait d\u0026rsquo;union ( - ), les deux-points (:) ou le point (.); un nom XML ne peut contenir d\u0026rsquo;autres caractères spéciaux, ni un espace\u0026quot;. En outre, il ne peut pas commencer par un chiffre, un trait d\u0026rsquo;union ou un point. Par exemple, le nom XML de la balise est « lavie », alors que la balise \u0026lt;7lavie\u0026gt; ne serait pas autorisée. On réserve les noms débutant par xml, Xml, xMl, xmL, XMl, xML,Xml et XML pour les spécifications XML. Ainsi, la balise est à éviter.\nPour les balises de début, aussi dites d\u0026rsquo;ouverture, on peut ajouter un attribut au nom XML de la balise. Un attribut porte un nom XML qui doit respecter les mêmes règles que les noms XML des balises; il est suivi du symbole « = » et d\u0026rsquo;une valeur placée entre guillemets ou apostrophes. Par exemple, la balise indique que l\u0026rsquo;élément lavie a un attribut (age=\u0026ldquo;5\u0026rdquo;) qui a comme nom XML « age » et comme valeur « 5 ». Une balise peut avoir plusieurs attributs, comme , mais ils doivent tous porter des noms XML différents : n\u0026rsquo;est pas autorisée.\nPar convention, on réserve l\u0026rsquo;attribut « xml:lang » à la spécification de la langue dans laquelle le texte est écrit. Cette spécification est optionnelle et assez rarement utilisée. Si on veut indiquer que le contenu d\u0026rsquo;un élément est en français, on fera comme dans cet exemple : « J\u0026rsquo;avais besoin d\u0026rsquo;une voiture. ». On peut ajouter au code de la langue, un code de région comme dans « fr-CA » ou « en-US ». Le code de la langue et le code de la région doivent être séparés par un tiret. Les codes de langue ou de région qui peuvent être utilisées sont disponibles à l\u0026rsquo;URL http://www.iana.org/assignments/language-subtag-registry.\nUn élément est l\u0026rsquo;ensemble du texte borné par deux balises ayant le même nom XML, comme et . On dit que l\u0026rsquo;élément a pour nom XML « lavie ». L\u0026rsquo;élément hérite des attributs de sa balise de départ : l\u0026rsquo;élément a l\u0026rsquo;attribut « age=\u0026ldquo;5\u0026rdquo; ». Il est à noter que la casse est significative en XML : les balises et n\u0026rsquo;ont pas le même nom XML. Dans le cas particulier où l\u0026rsquo;élément est vide (sans contenu), on peut remplacer par pour abréger. Un élément peut contenir d\u0026rsquo;autres éléments, comme dans , ou du texte, ou du texte et des éléments comme\n\u0026lt;lavie\u0026gt;fd\u0026lt;a\u0026gt;fsd\u0026lt;/a\u0026gt;fd\u0026lt;/lavie\u0026gt;. Si un élément contient d\u0026rsquo;autres éléments, il doit aussi contenir, entre ses balises de début et de fin, les balises de début et de fin de chaque élément. Notez, de plus, que deux éléments ne peuvent se chevaucher, comme ; avant de passer à un autre élément, il faut terminer le premier avec sa balise de fin. L\u0026rsquo;exemple précédent est du XML mal formé!\nPour bien comprendre, illustrons notre propos par un exemple. Un document XML prend la forme suivante :\n\u0026lt;racine\u0026gt; \u0026lt;element1\u0026gt;http://www.google.com\u0026lt;/element1\u0026gt; \u0026lt;element2\u0026gt;Un moteur de recherche\u0026lt;/element2\u0026gt; \u0026lt;/racine\u0026gt; Dans ce document, il y a trois éléments. Tout d\u0026rsquo;abord, il y a l\u0026rsquo;élément-racine qui comprend tout ce qui est entre les balises et . La première balise marque le début de l\u0026rsquo;élément-racine. Tout document XML bien formé doit avoir un élément-racine et un seul élément-racine. Tous les autres éléments doivent être contenus dans cet élément-racine. Dans notre exemple, cet élément a deux sous-éléments :\n\u0026lt;element1\u0026gt;http://www.google.com\u0026lt;/element1\u0026gt; et\n\u0026lt;element2\u0026gt;Un moteur de recherche\u0026lt;/element2\u0026gt; On peut ajouter un attribut à un des éléments de la façon suivante :\n\u0026lt;racine date=\u0026#34;aujourd\u0026#39;hui\u0026#34;\u0026gt; \u0026lt;element1\u0026gt;http://www.google.com\u0026lt;/element1\u0026gt; \u0026lt;element2\u0026gt;Un moteur de recherche\u0026lt;/element2\u0026gt; \u0026lt;/racine\u0026gt; Le texte date=\u0026ldquo;aujourd\u0026rsquo;hui\u0026rdquo; est un attribut de l\u0026rsquo;élément-racine avec pour nom « date » et comme valeur d\u0026rsquo;attribut « aujourd\u0026rsquo;hui ».\nTout le texte qui ne se trouve pas dans une balise, mais qui se trouve dans l\u0026rsquo;élément-racine se décompose en nœuds de texte. Par exemple, le document suivant contient un élément contenant un nœud de texte.\n\u0026lt;racine\u0026gt;mon texte\u0026lt;/racine\u0026gt; Points importants dans la syntaxe de base # Un document XML ne doit avoir qu\u0026rsquo;un et un seul élément appelé « élément-racine », qui doit contenir tous les autres éléments.\nIl faut correctement ouvrir et fermer les éléments en séquence, ainsi n\u0026rsquo;a aucun sens en XML, il faut plutôt écrire ou alors .\nLes éléments peuvent eux aussi avoir des attributs, par exemple , mais il faut obligatoirement mettre la valeur de l\u0026rsquo;attribut entre guillemets (\u0026quot;) ou apostrophes (\u0026rsquo;).\nDans l\u0026rsquo;ordre ou dans le désordre # Dans un document XML, l\u0026rsquo;ordre dans lequel les éléments sont présentés importe. Par exemple, les deux documents XML suivants ne sont pas équivalents.\n\u0026lt;racine\u0026gt; \u0026lt;element1\u0026gt;http://www.google.com\u0026lt;/element1\u0026gt; \u0026lt;element2\u0026gt;Un moteur de recherche\u0026lt;/element2\u0026gt; \u0026lt;/racine\u0026gt; \u0026lt;racine\u0026gt; \u0026lt;element2\u0026gt;Un moteur de recherche\u0026lt;/element2\u0026gt; \u0026lt;element1\u0026gt;http://www.google.com\u0026lt;/element1\u0026gt; \u0026lt;/racine\u0026gt; Par contre, l\u0026rsquo;ordre dans lequel les attributs sont présentés est sans importance. Les deux documents XML suivants sont donc équivalents.\n\u0026lt;racine attr1=\u0026#34;test\u0026#34; attr2=\u0026#34;retest\u0026#34;\u0026gt;\u0026lt;/racine\u0026gt; \u0026lt;racine attr2=\u0026#34;retest\u0026#34; attr1=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;/racine\u0026gt; Appels d\u0026rsquo;entités # Un élément peut contenir du texte, mais ne peut contenir le symbole \u0026lt;, comme dans l\u0026rsquo;exemple \u0026lt;a\u0026gt;\u0026lt;\u0026lt;/a\u0026gt;, parce que cela mène à de la confusion. On ne peut non plus y trouver le symbole \u0026amp; ou la séquence « ]]\u0026gt; ». Que faire alors s\u0026rsquo;il faut utiliser le caractère \u0026lt; dans un texte mathématique, par exemple? Il faut utiliser un appel d\u0026rsquo;entité. Un appel d\u0026rsquo;entité est un bout de texte qui commence par une esperluette ( \u0026amp;) et se termine par un point-virgule ( ; ). Nous verrons plus tard que nous pouvons définir nos propres appels d\u0026rsquo;entités; les appels d\u0026rsquo;entités suivants font partie de la définition du XML :\nappel d\u0026rsquo;entité résultat \u0026lt; \u0026lt; \u0026amp; \u0026amp; \u0026gt; \u0026gt; \u0026quot; \u0026quot; ' ' Ainsi, si le nom de votre compagnie est John\u0026amp;Smith, vous ne devrez pas utiliser un élément comme ceci John\u0026amp;Smith; il vous faudra plutôt utiliser\n\u0026lt;nom\u0026gt;John\u0026amp;amp;Smith\u0026lt;/nom\u0026gt;. Le texte « ]]\u0026gt; » s\u0026rsquo;écrit « ]]\u0026gt; ».\nOn utilise aussi les appels d\u0026rsquo;entités pour noter les valeurs des attributs. Supposons que la valeur d\u0026rsquo;un attribut est une apostrophe suivi d\u0026rsquo;un guillemet (\u0026rsquo;\u0026quot;). Les deux choix possibles \u0026lt;nom att=\u0026quot;\u0026rsquo;\u0026quot;\u0026quot;\u0026gt; et \u0026lt;nom att=\u0026rsquo;\u0026rsquo;\u0026quot;\u0026rsquo;\u0026gt; ne sont pas valables. Dans ce cas, il faudra écrire \u0026lt;nom att=\u0026quot;\u0026rsquo;\u0026quot;\u0026quot;\u0026gt;, \u0026lt;nom att=\u0026rsquo;'\u0026quot;\u0026rsquo;\u0026gt;, \u0026lt;nom att=\u0026quot;'\u0026quot;\u0026quot;\u0026gt; ou \u0026lt;nom att=\u0026rsquo;'\u0026quot;\u0026rsquo;\u0026gt;.\nPrenez le temps de mémoriser ces appels d\u0026rsquo;entités et retenez bien dans quel cas on peut être obligé de les utiliser.\nIl arrive parfois qu\u0026rsquo;il soit trop lourd d\u0026rsquo;utiliser des appels d\u0026rsquo;entités, et on peut alors utiliser un segment « CDATA ». Un tel segment débute par « \u0026lt;![CDATA[ » et se termine par « ]]\u0026gt; ». Tout le texte au sein du segment est rendu verbatim. Ainsi, le texte « \u0026lt;![CDATA[]]\u0026gt; » est équivalent à « ».\nLes commentaires # Dans un document XML, on peut ajouter un commentaire qui est normalement destiné à être lu par un humain. Par exemple, dans un fichier de configuration XML, les commentaires pourraient être utilisés pour expliquer la signification des différents éléments pour qu\u0026rsquo;un humain puisse faire des modifications au besoin.\nUn commentaire commence par et ne doit pas contenir deux tirets de suite (\u0026ndash;) entre ces deux bornes, il ne doit pas se terminer par un tiret, mais peut contenir n\u0026rsquo;importe quel autre texte. Un commentaire peut apparaître avant ou après l\u0026rsquo;élément-racine, dans un élément, entre deux éléments, etc. Cependant, un commentaire ne peut pas apparaître au sein d\u0026rsquo;une balise, comme \u0026lt;a \u0026gt;. C\u0026rsquo;est du XML mal formé!\nLes instructions de traitement # En pratique, il serait parfois utile d\u0026rsquo;appeler des fonctions externes (ou programmes) à partir du XML. Par exemple, vous pourriez avoir un programme « cout » qui donne le prix d\u0026rsquo;un produit à partir de son numéro de série : pourquoi ne pas appeler ce programme directement du XML?\nLe XML ne permet pas de le faire : le XML n\u0026rsquo;est qu\u0026rsquo;un métalangage pour produire des documents.\nPar contre, en XML, on peut utiliser des instructions de traitement. L\u0026rsquo;instruction de traitement ne fait rien en soi, mais peut indiquer à vos programmes comment trouver un certain résultat. L\u0026rsquo;exemple suivant décrit un produit portant le numéro de série 423890 et dont le prix pourrait être déterminé par une application appelée « cout ».\n\u0026lt;?cout 423890?\u0026gt; La syntaxe d\u0026rsquo;une telle instruction de traitement est simple. L\u0026rsquo;instruction débute par \u0026lt;? et se termine par ?\u0026gt;; immédiatement après \u0026lt;?, un nom XML valable doit apparaître (tous les noms XML valables sont autorisés à l\u0026rsquo;exception de xml, Xml, XMl, XML, XmL, xMl, xML et xmL). Rappelons que, comme pour n\u0026rsquo;importe quel contenu textuel XML, il faut faire des appels d\u0026rsquo;entités pour \u0026lt; et \u0026amp;. Une instruction de traitement n\u0026rsquo;est pas une balise ou un élément.\nNotez que le langage informatique PHP utilise les instructions de traitement avec comme nom « php ». Voyons l\u0026rsquo;exemple suivant :\n\u0026lt;?php echo \u0026#34;Hello World\u0026#34;; ?\u0026gt; Tout comme les commentaires, on peut mettre les instructions de traitement partout dans un document XML, sauf à l\u0026rsquo;intérieur d\u0026rsquo;une balise.\nJeux de caractères # Historiquement, on a longtemps représenté les caractères en utilisant des octets (8 bits). Aux États-Unis, on utilisait la norme ASCII qui utilisait les sept premiers bits de chaque octet. Avec le temps, les normes ISO se sont imposées. En français, on utilise souvent le jeu de caractères « ISO-8859-1 ». Historiquement, l\u0026rsquo;outil Bloc-note de Microsoft utilise par défaut un jeu de caractères qui est très similaire à ISO-8859-1 (qu\u0026rsquo;ils nomment parfois ANSI) sur les PC vendus en Amérique du Nord. Malheureusement, n\u0026rsquo;utiliser que 8 bits pour représenter les caractères signifie qu\u0026rsquo;il est impossible de tenir compte des langues asiatiques, par exemple, et qu\u0026rsquo;on ne peut mélanger un texte français avec de l\u0026rsquo;arabe. Pour cette raison, en 1991, la norme Unicode fut proposée.\nLa norme Unicode est de plus en plus utilisée et elle est popularisée en partie par son utilisation dans le XML. En effet, par défaut, un document XML utilise Unicode (spécifiquement UTF-8 ou UTF-16) et ce sont les seuls jeux de caractères qu\u0026rsquo;un processeur XML est requis de connaître. L\u0026rsquo;avantage principal d\u0026rsquo;Unicode est sa richesse : la version 5.0 du format Unicode permet de représenter 99 000 caractères différents incluant les caractères Klingon de Star Trek. En comparaison, le jeu de caractères ISO-8859-1 permet de représenter moins de 255 caractères (8 bits).\nUTF-8 et UTF-16 sont les deux encodages Unicode les plus utilisés en XML. UTF-8 est un encodage à longueur variable qui représente les caractères ASCII (les 128 premiers) sur un seul octet, exactement comme l\u0026rsquo;ancien ASCII, ce qui le rend totalement rétrocompatible avec les innombrables fichiers et outils qui supposent cet encodage ; les caractères accentués latins occupent deux octets, et les caractères plus rares (asiatiques, émojis, etc.) jusqu\u0026rsquo;à quatre octets. Cette économie fait d\u0026rsquo;UTF-8 l\u0026rsquo;encodage par défaut sur le web, dans les bases de données modernes et dans la majorité des fichiers XML actuels. UTF-16, quant à lui, utilise des unités de deux octets (16 bits) pour chaque caractère de base ; les caractères du plan multilangue supplémentaire nécessitent alors une paire de substituts (surrogate pairs) et occupent donc quatre octets. Il est plus compact que UTF-8 pour les textes majoritairement asiatiques, mais consomme davantage d\u0026rsquo;espace pour les textes latins et pose des problèmes de compatibilité avec les outils qui s\u0026rsquo;attendent à un octet = un caractère. En XML, un parseur doit obligatoirement comprendre les deux, mais UTF-8 reste très largement dominant grâce à sa compatibilité et à sa robustesse.\nLes caractères de la langue anglaise (ASCII) sont toujours stockés de la même façon, qu\u0026rsquo;on utilise UTF-8 ou ISO-8859-1, en utilisant 7 bits. C\u0026rsquo;est donc dire que les programmeurs anglophones travaillant pour des utilisateurs anglophones peuvent, jusqu\u0026rsquo;à un certain point, ignorer les questions d\u0026rsquo;encodage des caractères.\nLa plupart des logiciels récents supportent la norme Unicode. D\u0026rsquo;ailleurs, depuis le tout début, une chaîne de caractères en Java est représentée en utilisant la norme Unicode. Par contre, il restera toujours des logiciels utilisant d\u0026rsquo;autres jeux de caractères.\nLa déclaration XML # La déclaration XML ressemble à s\u0026rsquo;y méprendre à une instruction de traitement et prend la forme \u0026lt;?xml \u0026hellip; ?\u0026gt;. Une déclaration XML n\u0026rsquo;est pas une balise ou un élément. Le contenu d\u0026rsquo;une déclaration XML comporte généralement au maximum trois attributs : version=\u0026quot;\u0026hellip;\u0026quot;, encoding=\u0026quot;\u0026hellip;\u0026quot; et standalone=\u0026quot;\u0026hellip;\u0026quot;. La version 1.0 du XML est la plus utilisée; bien que la version 1.1 existe, elle est fort peu utilisée. Selon l\u0026rsquo;un des inventeurs du XML, Tim Bray, il est peu probable qu\u0026rsquo;il y ait une version 2.0 du XML .\nJe ne pense pas qu\u0026rsquo;il y aura de XML 2.0. Les obstacles politiques seraient effrayants - tout le monde voudra sa part du gâteau -, et la base installée de logiciels qui reconnaissent XML comprend aujourd\u0026rsquo;hui à peu près tous les ordinateurs liés à Internet, donc une transition me semblerait trop onéreuse. (Interview de Tim Bray, JDN Développeurs, 29 janvier 2007)\nSur un disque ou dans un réseau, un document XML n\u0026rsquo;est rien donc qu\u0026rsquo;une chaîne d\u0026rsquo;octets. Pour interpréter cette chaîne comme du texte, il faut spécifier l\u0026rsquo;encodage des caractères. Par défaut, le XML suppose que nous avons un encodage des caractères de type Unicode. On utilise souvent une déclaration XML avec « encoding=\u0026ldquo;ISO-8859-1\u0026rdquo; » pour pouvoir utiliser les accents dans le document en conjonction des outils logiciels n\u0026rsquo;ayant pas été mis à jour au vingt-et-unième siècle. Seuls les caractères de la langue anglaise (ASCII) ne changent pas entre ISO-8859-1 et unicode. L\u0026rsquo;utilisation des accents en français sans la déclaration « encoding=\u0026ldquo;ISO-8859-1\u0026rdquo; » peut alors entraîner des problèmes si le document a été enregistré avec l\u0026rsquo;encodage ISO-8859-1.\nUn même document XML peut être enregistré sous plusieurs jeux de caractères. Cependant, il faut que la déclaration correspondent au format utilisé lors de l\u0026rsquo;enregistrement du fichier, sinon les caractères accentués (par exemple) seront pervertis.\nL\u0026rsquo;attribut « standalone » prend la valeur yes ou no, selon que l\u0026rsquo;on veut que la DTD externe soit lue ou non. Nous traiterons des DTD, plus tard.\nIl est important de prendre en compte l\u0026rsquo;encodage des caractères. Le document XML suivant, si on l\u0026rsquo;enregistre en ISO-8859-1, ne serait pas bien formé, car il utilise des accents :\n\u0026lt;étudiant\u0026gt; Jean \u0026lt;/étudiant\u0026gt; Par contre, le document XML qui suit est bien formé lorsqu\u0026rsquo;on l\u0026rsquo;enregistre en ISO-8859-1 :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;étudiant\u0026gt; Jean \u0026lt;/étudiant\u0026gt; La déclaration XML doit obligatoirement être au tout début du document ou être carrément absente : même un espace n\u0026rsquo;est pas permis.\nLes espaces # En XML, les espaces entre les balises comptent, qu\u0026rsquo;il s\u0026rsquo;agisse d\u0026rsquo;un retour de charriot, d\u0026rsquo;une tabulation ou d\u0026rsquo;un simple espace. Ainsi, le document suivant se décompose en 7 parties ou nœuds : un élément-racine nommé html qui contient d\u0026rsquo;abord un nœud de texte (le retour de charriot) suivi d\u0026rsquo;un élément produit contenant le nœud de texte «1», suivi d\u0026rsquo;un autre nœud de texte (le retour de charriot), suivi d\u0026rsquo;un élément serie (vide), suivi d\u0026rsquo;un quatrième nœud de texte (le retour de charriot).\n\u0026lt;html\u0026gt; \u0026lt;produit\u0026gt;1\u0026lt;/produit\u0026gt; \u0026lt;serie /\u0026gt; \u0026lt;/html\u0026gt; Par contre ce document ne contient que 4 nœuds (3 éléments et 1 nœud de texte) :\n\u0026lt;html\u0026gt;\u0026lt;produit\u0026gt;1\u0026lt;/produit\u0026gt;\u0026lt;serie /\u0026gt;\u0026lt;/html\u0026gt; En effet, comme il n\u0026rsquo;y a pas d\u0026rsquo;espace ou de retour de charriot entre les balises, il n\u0026rsquo;y a qu\u0026rsquo;un seul nœud de texte. Si on omet les attributs, les nœuds débutent et se terminent généralement avec les balises.\nOn peut indiquer que les espaces entre les éléments sont significatifs avec l\u0026rsquo;attribut xml:space qui peut prendre la valeur default ou la valeur preserve. Dans cet exemple, on souhaite indiquer que les espaces sont significatifs :\n\u0026lt;html xml:space=\u0026#34;preserve\u0026#34;\u0026gt; \u0026lt;produit\u0026gt;1\u0026lt;/produit\u0026gt; \u0026lt;serie /\u0026gt; \u0026lt;/html\u0026gt; Les fins de ligne # Les fichiers de texte sont souvent organisés en lignes. Selon le système d\u0026rsquo;exploitation, il y a plusieurs façon de représenter une fin de ligne. Les systèmes d\u0026rsquo;exploitation Microsoft utilisent deux caractères (« retour de charriot » et « nouvelle ligne ») à la fin de chaque ligne. Les autres système utilisent généralement un seul caractère (« nouvelle ligne »). Les processeurs XML sont requis de normaliser la situation et de remplacer les deux caractères utilisés par les systèmes Microsoft par un seul caractère lors de la lecture du fichier. Ainsi, peu importe comment l\u0026rsquo;on note les fins de ligne, un processeur XML ne vera qu\u0026rsquo;un caractère « nouvelle ligne ».\nLes hyperliens # Il arrive fréquemment qu\u0026rsquo;on utilise des hyperliens dans les documents XML. On distingue deux types d\u0026rsquo;hyperliens : les hyperliens contenant une adresse absolue (telle que http://domaine.ca/pong.png) et les hyperliens contenant des adresses relatives (pong.png). On reconnaît les adresses relatives parce qu\u0026rsquo;elles ne débutent pas par un protocole tel que http ou ftp. Pour compléter les adresses relatives et les transformer en adresses absolues, on utilise fréquemment l\u0026rsquo;adresse du document. Ainsi, si le document suivant se trouve à l\u0026rsquo;adresse http://domaine.ca/fichier.xml, alors un logiciel pourra charger une image située à l\u0026rsquo;adresse http://domaine.ca/pong.png :\n\u0026lt;racine\u0026gt; adresse relative: \u0026lt;image lien=\u0026#34;pong.png\u0026#34; /\u0026gt; \u0026lt;/racine\u0026gt; Le XML permet de spécifier un attribut xml:base qui sert à interpréter les adresses relatives remplaçant l\u0026rsquo;adresse du document. Le document suivant pointe vers une image à l\u0026rsquo;adresse http://domaine.ca/image/pong.png :\n\u0026lt;racine xml:base=\u0026#34;http://domaine.ca/\u0026#34;\u0026gt; \u0026lt;p xml:base=\u0026#34;image/\u0026#34;\u0026gt; \u0026lt;image lien=\u0026#34;pong.png\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/racine\u0026gt; Documents bien formés # Un document XML qui respecte ces règles de base est dit « bien formé ». Pour éviter la confusion, il ne faut pas utiliser des synonymes comme « correct ».\nLa terminologie utilisée peut sembler très aride. Cependant, la rigueur qu\u0026rsquo;exige le XML est aussi garante de la cohérence. Comme tous les termes sont bien définis, il est plus facile de s\u0026rsquo;entendre entre experts. Comme le XML est surtout utilisé pour la communication entre les logiciels, la rigueur évitera plus tard les bogues et les incompréhensions.\nPouvoir reconnaître un document XML bien formé ou comprendre pourquoi un document n\u0026rsquo;est pas bien formé, permet de s\u0026rsquo;assurer qu\u0026rsquo;un logiciel pourra traiter les informations, et qu\u0026rsquo;on saura quoi faire en cas de problème.\n"},{"id":17,"href":"/orientee_donnees/docs/modules/d_module_html/xhtml/","title":"XHTML","section":"Module HTML, CSS, SVG, MathML","content":" XHTML Qu'est-ce que le XHTML? Le HTML a été inventé par Tim Berners-Lee, alors qu'il travaillait pour le centre de recherche CERN en Suisse. L'intention de Berners-Lee était de proposer un système révolutionnaire de gestion de l'information qu'il appela World Wide Web . Comme pièce maîtresse de son architecture, il avait besoin d'un format de documents qu'il appela HTML ( HyperText Markup Language ). La première page web, dont l'adresse était http://nxoc01.cern.ch/hypertext/WWW/TheProject.html, vit le jour en 1990. Le HTML est un langage à base de balises, un peu comme une application XML. En fait, il existe une application XML appelée XHTML, qui est à la fois du HTML et du XML. Le document que vous lisez en ce moment en est un exemple. En effet, le document que vous lisez est à la fois du XML bien formé et valable, mais aussi du HTML. Rappelons qu'une « application XML » est un ensemble de balises et d'attributs, c'est-à-dire un vocabulaire XML, avec des conventions d'usage dont certaines peuvent être représentées par un document DTD. La très grande majorité des documents sur le web sont écrits en HTML et, de plus en plus, en XHTML. Une des raisons principales de l'utilisation du XHTML, c'est que les outils qui traitent le XML peuvent aussi traiter du XHTML puisque ce dernier est aussi du XML. Il est donc possible, dans une organisation, de combiner le contenu web (HTML) avec le stockage des informations en XML. Si on dit « HTML » tout court, ce n'est pas nécessairement du XML et il se peut que les outils conçus pour le XML ne puissent être utilisés pour le traiter. Cependant, si on dit « XHTML », alors il s'agit à la fois de HTML et de XML et on peut utiliser les outils destinés au XML pour en traiter le contenu. Voici quelques différences entre le HTML et le XHTML : Les serveurs web distinguent le contenu en fournissant aux navigateurs différents codes MIME (Multipurpose Internet Mail Extensions), alors que le HTML a le code MIME « text/html », on utilise le code MIME « application/xml » ou « application/xhtml+xml » pour le XHTML. Avec le serveur web Apache, on obtient le résultat désiré en ajoutant un fichier « .htaccess », dans le même répertoire que nos fichiers XHTML, contenant la ligne « AddType application/xml .xhtml ». En HTML traditionnel, on n'a pas à fermer les éléments. Ainsi, le code suivant « \u0026lt; p \u0026gt; \u0026lt; i \u0026gt; texte \u0026lt; / p \u0026gt; » est acceptable en HTML, mais en XHTML, il faut écrire « \u0026lt;p\u0026gt;\u0026lt;i\u0026gt;texte\u0026lt;/i\u0026gt;\u0026lt;/p\u0026gt; ». Les valeurs d'attributs en HTML n'ont pas à être entre des guillemets ou apostrophes. Ainsi, le code « \u0026lt; table border = 0 \u0026gt; » est acceptable en HTML, mais en XHTML, il faut écrire « \u0026lt; table border = \" 0 \" \u0026gt; ». En HTML, la casse des noms est sans importance. Ainsi, on peut remplacer « \u0026lt;p\u0026gt; » par « \u0026lt;P\u0026gt; », alors que ce n'est pas permis en XHTML. Un document XHTML prend la forme suivante : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Voici mon document. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; On reconnaît d'abord la déclaration XML qui n'a rien de particulier : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt;. Comme pour tout document XML, on peut omettre la déclaration XML d'un document XHTML, mais si nous voulons écrire en français avec des lettres accentuées, il est nettement préférable d'avoir la déclaration XML de notre exemple. On reconnaît ensuite la déclaration de type de document : \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt;. Observez qu'elle apparaît sur deux lignes, que c'est souvent le cas, mais que c'est un choix purement esthétique. La déclaration de type de document est un peu particulière : il s'agit d'une déclaration utilisant un identifiant public. On doit utiliser un tel identifiant quand on veut signifier qu'il s'agit d'une application XML commune; on évite ainsi que des milliers de personnes aillent chercher des documents DTD à l'adresse « http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd ». On s'attend qu'un logiciel qui dépend d'une application XML commune n'ait pas besoin d'aller chercher les documents DTD, chaque fois que le document XML est lu. Un navigateur ne tient généralement pas compte de la DTD externe, on peut donc omettre la déclaration DOCTYPE sans problème. Le reste du document est simplement un élément-racine « html » contenant deux éléments : un élément head et un élément body . L'élément head doit contenir un élément title , alors que l'élément body peut être vide, mais peut aussi posséder du contenu XML mixte (texte et diverses balises XHTML). L'espace de nom ayant l'URI « http://www.w3.org/1999/xhtml » est utilisé. Si vous copiez le texte qui précède dans un éditeur de texte comme Bloc-notes et que vous enregistrez le fichier sous un nom comme « test.xhtml », vous devriez être capable d'ouvrir le fichier dans votre navigateur et de voir le texte « Voici mon document. » s'afficher à l'écran. Les documents HTML sont tous des documents en format texte et l'extension du fichier est arbitraire : on utilise tout aussi bien « .htm » que « .html », « .xhtml » ou même « .xml ». L'avantage de l'extension « .xhtml » est d'informer le navigateur qu'il s'agit d'un document XHTML, donc un document HTML et un document XML. La structure du document XHTML : head et body Comme nous le disions, l'élément-racine d'un document XHTML est nommé « html ». Cet élément contient deux et exactement deux sous-éléments : head et body . L'élément head n'est pas affiché directement dans le navigateur et contient des métadonnées, c'est-à-dire une description du contenu. Un élément head doit au minimum contenir un élément title qui donne le titre du document XHTML. Par la suite, l'élément body contient un ensemble de balises et du texte (contenu mixte) qui sera affiché directement dans le navigateur. Les paragraphes en HTML L'élément body contient des balises et du texte. Les retours de ligne sont traités comme des espaces normaux. Ainsi, les deux documents suivants seront affichés de la même manière par un navigateur. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Voici mon document. Voici ma vie. Voici mon chat. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Voici mon document. Voici ma vie.\nVoici mon chat. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; La question qui se pose alors est : Comment faire des paragraphes? En effet, dans les deux documents plus haut, le texte s'affichera sur une seule ligne (vous pouvez le tester!). La solution consiste à utiliser l'élément « p » pour « paragraphe ». Pour avoir trois paragraphes, on remplace le document HTML précédent par celui qui suit. Observez que chaque balise « p » ouverte doit être fermée. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Voici mon document.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Voici ma vie.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Voici mon chat.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Les listes en HTML Supposons que l'on veuille faire une liste, comme ceci : Premier point : le chat est noir. Second point : le chat est blanc. Dernier point : le chat est marron. On peut obtenir ce résultat avec un élément « ul » pour unordered list (liste sans ordre), contenant des éléments « li ». Observez que chaque balise « li » ouverte doit être fermée. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Premier point: le chat est noir.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Second point: le chat est blanc.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Dernier point: le chat est marron.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Supposons maintenant que nous voulions une liste avec un compteur : Le chat est noir. Le chat est blanc. Le chat est marron. Il suffit alors de remplacer l'élément « ul » par l'élément « ol » pour ordered list (liste ordonnée) : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Le chat est noir.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Le chat est blanc.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Le chat est marron.\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Les tableaux en HTML Supposons maintenant que nous voulions produire un tableau. On peut l'obtenir à l'aide d'un élément « table ». Cet élément contiendra plusieurs éléments « tr » (éléments correspondant à une ligne) qui eux-mêmes contiennent des éléments « td » (éléments correspondant à une cellule). Ainsi, pour obtenir un tableau comme celui-ci : Nom Valeur Mustang 50 $ Ferrari 500 $ On utilise le code suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Nom\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Valeur\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Mustang\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Ferrari\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;500 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Supposons maintenant que l'on veuille un tableau avec des lignes pour marquer et diviser les cellules. Il suffit alors d'utiliser l'attribut « border ». Sa valeur numérique représente l'épaisseur en pixels de la bordure. Ainsi, pour obtenir ce résultat : Nom Valeur Mustang 50 $ Ferrari 500 $ On utilisera le code XHTML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\"1\"\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Nom\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Valeur\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Mustang\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Ferrari\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;500 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tous les tableaux ne sont pas si simples. On peut faire en sorte qu'une même cellule occupe deux colonnes (\u0026lt;td colspan=\"2\"\u0026gt;) ou deux rangées (\u0026lt;td rowspan=\"2\"\u0026gt;). Aussi, souvent, on utilise l'élément « th » au lieu de l'élément « td » pour désigner la première rangée d'un tableau lorsque celle-ci forme l'entête descriptive du tableau. Il est aussi possible d'utiliser un élément « caption » au sein d'un tableau pour noter le titre du tableau : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\"1\"\u0026gt; \u0026lt;caption\u0026gt;Valeur de différents véhicule\u0026lt;/caption\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Nom\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Valeur\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Mustang\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;50 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Ferrari\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;500 $\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Les caractères italiques et gras On peut très facilement utiliser des effets de polices de caractères en HTML. Pour obtenir des caractères en italique, par exemple maman , il suffit d'utiliser un élément « i » comme ceci : \u0026lt;i\u0026gt;maman\u0026lt;/i\u0026gt;. Pour des caractères en gras, comme maman , il suffit d'utiliser un élément « b » comme ceci : \u0026lt;b\u0026gt;maman\u0026lt;/b\u0026gt;. On peut également combiner les deux, comme maman , en écrivant \u0026lt;i\u0026gt;\u0026lt;b\u0026gt;maman\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt; ou bien \u0026lt;b\u0026gt;\u0026lt;i\u0026gt;maman\u0026lt;/i\u0026gt;\u0026lt;/b\u0026gt;. Il est cependant préférable d'utiliser « em » (emphase) au lieu de « i » et « strong » (fort) au lieu de « b » : le navigateur choisira alors de rendre le texte dans un élément « em » avec un italique ou une autre technique appropriée, et de rendre le texte dans un élément « strong » en caractères gras ou une autre technique appropriée. On évite ainsi de confondre la présentation (italique ou gras) et la sémantique (emphase ou point fort). Dans le cas où un terme est défini, vous devriez utiliser un élément « dfn » (définition) comme dans cet exemple: « La \u0026lt;dfn\u0026gt;mort\u0026lt;/dfn\u0026gt; est la fin de la vie ». La plupart des navigateurs afficheront alors le mot « mort » en caratères italiques. Les listes de définitions Supposons que nous voulions une liste de définitions comme celle qui suit : Voiture Véhicule sur roues. Chat Bête sauvage qui se nourrit de lait. Éléphant Bête sauvage de couleur rose. On obtient ce résultat en XHTML avec un élément « dl » pour definition list contenant une série d'éléments « dt » et « dd » en paire, où l'élément « dt » fournit le terme à définir et l'élément « dd » sa définition. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;Voiture\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Véhicule sur roues. \u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;Chat\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Bête sauvage qui se nourrit de lait. \u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;Éléphant\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;Bête sauvage de couleur rose. \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Les lignes horizontales Pour obtenir une ligne horizontale, on utilise l'élément « hr » qui doit être vide. On doit donc écrire \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; ou plus simplement \u0026lt;hr /\u0026gt;. Voici une ligne horizontale : Les images Au moment d'écrire ces lignes, on trouve un logo de l'UQAM à l'URL https://upload.wikimedia.org/wikipedia/commons/2/24/Université_du_Québec_à_Montréal_Logo.svg. Pour insérer une image dans un document HTML, il suffit d'utiliser une balise « img » avec comme attribut « src » pour source, soit l'URL. Par exemple, le code \u0026lt;img src=\"https://upload.wikimedia.org/wikipedia/commons/2/24/Université_du_Québec_à_Montréal_Logo.svg\"\u0026gt; ou \u0026lt;img src=\"https://upload.wikimedia.org/wikipedia/commons/2/24/Université_du_Québec_à_Montréal_Logo.svg\" /\u0026gt; permettra d'insérer le logo de l'UQAM dans un document. Il est préférable de prévoir que l'image pourrait ne pas être trouvée ou affichée en ajoutant un attribut « alt » qui contient du texte décrivant le contenu de l'image; si l'image n'est pas disponible, le texte contenu dans l'attribut « alt » s'affichera. Le résultat final prend la forme \u0026lt;img src=\"https://upload.wikimedia.org/wikipedia/commons/2/24/Université_du_Québec_à_Montréal_Logo.svg\" alt=\"logo de l'UQAM\" /\u0026gt; ce qui donne : Les hyperliens Pour inclure un hyperlien, comme dans l'exemple de la page de l'UQAM [lien vers http://www.uqam.ca/], il suffit d'utiliser la syntaxe « \u0026lt;a href=\"http://www.uqam.ca/\"\u0026gt;page de l'UQAM ». On peut également ajouter des marqueurs dans une page web en utilisant la syntaxe « \u0026lt;a name=\"point1\"\u0026gt;Premier point de mon document\u0026lt;/a\u0026gt; ». Contrairement à la syntaxe « \u0026lt;a href=\"...\"\u0026gt; », l'attribut « name » n'ajoute pas un hyperlien, mais un marqueur généralement invisible dans la page. Par exemple, si la page contient plusieurs sections, on peut ajouter un marqueur au début de chaque section. On pourra alors faire des liens non seulement vers le document, mais aussi vers la section marquée dans le document. Ainsi, l'hyperlien « \u0026lt;a href=\"pageweb.html#point1\"\u0026gt;aller vers le premier point du document pageweb.html\u0026lt;/a\u0026gt; » mènera l'utilisateur dans le document « pageweb.html », précisément au marqueur du « point 1 », s'il existe, évidemment. Les abbréviations On utilise parfois des abbréviations dans une page web tel que « etc. » ou « no ». On peut indiquer au navigateur qu'il s'agit d'une abbréviation avec un élément abbr comme ceci : « \u0026lt;abbr\u0026gt;no\u0026lt;/abbr\u0026gt; ». Il est parfois utile d'utiliser l'attribut « title » pour décrire l'abbréviation en question comme dans ceci : « \u0026lt;abbr title=\"numéro\"\u0026gt;no\u0026lt;/abbr\u0026gt; ». De la même façon, on peut noter les acronymes avec un élément « acronym » comme ceci : « \u0026lt;acronym title=\"Organisation du traité de l'Atlantique Nord\"\u0026gt;OTAN\u0026lt;/acronym\u0026gt; ». Les adresses Il est fréquent qu'une page web contienne un adresse. Le XHTML nous permet d'indiquer au navigateur qu'il s'agit bien d'une adresse avec l'élément « address », comme ceci : « \u0026lt;address\u0026gt; Daniel Lemire\u0026lt;br /\u0026gt; 100, rue Sherbrooke \u0026lt;/address\u0026gt; ». Ici, l'élément « br » sert à noter un retour de charriot. Les indices et exposants Dans un texte, il arrive qu'on veuille utiliser des exposants et des indices. Les éléments « sup » et « sub » servent à cette fonction. Par exemple, « premier » peut s'écrit « 1 er ». Il n'est malheureusement pas possible de noter automatiquement des notes en bas de page en HTML ou XHTML. Le code et les exemples Il y a plusieurs éléments permettant de traiter de la programmation informatique ou des mathématiques. Le code informatique peut s'écrire dans un élément « code ». Le texte saisi à l'écran par un utilisateur peut s'écrire dans un élément « kbd ». Les exemples de sortie à l'écran peuvent s'écrire dans un élément « samp » (pour sample) et les variables peuvent s'écrire dans un élément « var ». Voici un exemple : « \u0026lt; p \u0026gt; La valeur de la variable \u0026lt; var \u0026gt; i \u0026lt;/ var \u0026gt; est obtenue avec ce code: \u0026lt;/ p \u0026gt; \u0026lt; code \u0026gt; int i = 1; i+=1 \u0026lt;/ code \u0026gt; \u0026lt; p \u0026gt; On s'attend à ce que l'utilisateur tape \u0026lt; kbd \u0026gt; Yes \u0026lt;/ kbd \u0026gt; pour oui. Voici un exemple de résultat: \u0026lt; samp \u0026gt; Error! \u0026lt;/ samp \u0026gt; . \u0026lt;/ p \u0026gt; ». Les citations Pour citer quelqu'un, on peut utiliser un élément « q » lorsqu'il s'agit d'un courte citation au sein d'un paragraphe ou élément « blockquote » lorsque la citation doit former un court paragraphe. Plusieurs navigateur mettent automatiquement le contenu de l'élément « q » entre guillemets et le contenu de l'élément « blockquote » en retrait. Voici un exemple : « \u0026lt; p \u0026gt; Jean a dit: \u0026lt; q \u0026gt; mon cher! \u0026lt;/ q \u0026gt; . Par la suite, je lui ai lu ce texte fatidique. \u0026lt;/ p \u0026gt; \u0026lt; blockquote \u0026gt; \u0026lt; p \u0026gt; Oh! Comme la mer a merée! Oh! Comme j'ai jéjé! \u0026lt;/ p \u0026gt; \u0026lt;/ blockquote \u0026gt; ». Les révisions Les éléments del et ins permettent de noter un retrait et un ajout, respectivement, comme dans cet exemple: J'ai \u0026lt;del\u0026gt;marié\u0026lt;/del\u0026gt;\u0026lt;ins\u0026gt;épousé\u0026lt;/ins\u0026gt; ta mère Le navigateur se chargera d'afficher les retraits et les ajouts de manière compréhensible. La langue Le XHTML respecte la spécification XML voulant qu'on indique la langue dans laquelle est écrite un texte avec l'attribute « xml:lang ». Cet attribut est optionnel, mais peut s'avérer pratique. Dans le cas où un texte en langue étrangère est présent dans un paragraphe, on peut utiliser l'élément « span » pour en indiquer la langue. Voici un exemple : « \u0026lt; p xml : lang = \" fr-CA \" \u0026gt; Jean aime les \u0026lt; span xml : lang = \" en-US \" \u0026gt; computers \u0026lt;/ span \u0026gt; \u0026lt;/ p \u0026gt; ». L'élément « span » ne sert qu'à nous permettre de sélectionner un texte au sein d'un autre élément. Les commentaires Ajouter des commentaires en XHTML est facile. Les commentaires du XML s'appliquent: il suffit de débuter le commentaire par \u0026lt;!-- et de le terminer par --\u0026gt;. Il n'est pas permis d'inclure au sein d'un commentaire deux tirets (--) ni de terminer un commentaire par un tiret. Séparation du contenu et de la présentation Avec le XHTML, on peut contrôler en partie l'apparence du texte, en utilisant des italiques ou en plaçant des bordures dans nos tableaux. Ce contrôle est cependant limité : on ne peut pas ajuster l'indentation des paragraphes et on ne peut que difficilement ajuster les marges de la page. Nous verrons au module 3, dans la section sur le CSS, qu'il existe une façon élégante d'y arriver. Convertir du HTML mal formé Dans une organisation, il est fréquent d'avoir à composer avec des sites web qui ne respectent pas les normes les plus élémentaires. Réécrire le HTML en XHTML peut sembler une tâche très ardue. Heureusement, il existe des outils gratuits pour corriger du HTML mal formé et générer automatiquement un XHTML valable, comme par exemple HTMLTidy ( http://tidy.sourceforge.net/ ). Le W3C rend aussi disponible un outil de vérification en ligne des sites web pour s'assurer de leur conformité avec les normes ( http://validator.w3.org/ ). Spécification Relax NG Il existe des définitions de type de document officielle pour le XHML, mais elles sont longues et peu lisible. Sean B. Palmer a écrit une spécification Relax NG pour un sous-ensemble du XHTML que je reproduis ici avec permission. Je vous invite à vérifier que vous pouvez en comprendre l'essentiel. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;grammar xmlns=\u0026#34;http://relaxng.org/ns/structure/1.0\u0026#34; datatypeLibrary=\u0026#34;http://www.w3.org/2001/XMLSchema-datatypes\u0026#34; ns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;start\u0026gt; \u0026lt;ref name=\u0026#34;html\u0026#34;/\u0026gt; \u0026lt;/start\u0026gt; \u0026lt;!-- Common attribute groups --\u0026gt; \u0026lt;define name=\u0026#34;Core.attrs\u0026#34;\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;id\u0026#34;\u0026gt;\u0026lt;data type=\u0026#34;ID\u0026#34;/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;class\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;style\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;I18n.attrs\u0026#34;\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;xml:lang\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;dir\u0026#34;\u0026gt;\u0026lt;choice\u0026gt;\u0026lt;value\u0026gt;ltr\u0026lt;/value\u0026gt;\u0026lt;value\u0026gt;rtl\u0026lt;/value\u0026gt;\u0026lt;/choice\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;Main.attrs\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Core.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;onclick\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;!-- Content models --\u0026gt; \u0026lt;define name=\u0026#34;BlockMinusForm\u0026#34;\u0026gt; \u0026lt;zeroOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;address\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;blockquote\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;del\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;div.elem\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;dl\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;h1\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;h2\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;h3\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;hr\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;ins\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;ol\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;p\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;pre\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;script\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;table\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;ul\u0026#34;/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/zeroOrMore\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;Block\u0026#34;\u0026gt; \u0026lt;zeroOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;BlockMinusForm\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;form\u0026#34;/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/zeroOrMore\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;InlineMinusMedia\u0026#34;\u0026gt; \u0026lt;zeroOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;a\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;abbr\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;br\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;cite\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;code\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;del\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;em\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;input\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;ins\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;label\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;script\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;span\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;strong\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;sub\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;sup\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;textarea\u0026#34;/\u0026gt; \u0026lt;text/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/zeroOrMore\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;Inline\u0026#34;\u0026gt; \u0026lt;zeroOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;InlineMinusMedia\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;img\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;object\u0026#34;/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/zeroOrMore\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;Flow\u0026#34;\u0026gt; \u0026lt;zeroOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;Block\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/zeroOrMore\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;!-- Elements --\u0026gt; \u0026lt;define name=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;html\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;head\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;body\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;head\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;head\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;profile\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;title\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;ref name=\u0026#34;base\u0026#34;/\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;interleave\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;script\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;style\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;meta\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;link\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;/interleave\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;title\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;text/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;base\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;base\u0026#34;\u0026gt; \u0026lt;attribute name=\u0026#34;href\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;meta\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;meta\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;link\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;link\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;href\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;rel\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;style\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;style\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;I18n.attrs\u0026#34;/\u0026gt; \u0026lt;attribute name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;text/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;script\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;script\u0026#34;\u0026gt; \u0026lt;attribute name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;src\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;text/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;onload\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;Block\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;div.elem\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;div\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;p\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;h1\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;h1\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;h2\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;h2\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;h3\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;h3\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;oneOrMore\u0026gt;\u0026lt;ref name=\u0026#34;li\u0026#34;/\u0026gt;\u0026lt;/oneOrMore\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;ol\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;ol\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;oneOrMore\u0026gt;\u0026lt;ref name=\u0026#34;li\u0026#34;/\u0026gt;\u0026lt;/oneOrMore\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;li\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;li\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;dl\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;dl\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;oneOrMore\u0026gt; \u0026lt;group\u0026gt; \u0026lt;ref name=\u0026#34;dt\u0026#34;/\u0026gt; \u0026lt;oneOrMore\u0026gt;\u0026lt;ref name=\u0026#34;dd\u0026#34;/\u0026gt;\u0026lt;/oneOrMore\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/oneOrMore\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;dt\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;dt\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;dd\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;dd\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;hr\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;hr\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;pre\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;pre\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;InlineMinusMedia\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;blockquote\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;blockquote\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;cite\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;Block\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;ins\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;ins\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;cite\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;del\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;del\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;cite\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;href\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;rel\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;interleave\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;img\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;zeroOrMore\u0026gt;\u0026lt;ref name=\u0026#34;span\u0026#34;/\u0026gt;\u0026lt;/zeroOrMore\u0026gt; \u0026lt;/interleave\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;span\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;span\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;br\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;br\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Core.attrs\u0026#34;/\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;em\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;em\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;strong\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;code\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;code\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;cite\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;cite\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;abbr\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;abbr\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;sub\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;sup\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;sup\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;object\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;type\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;img\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;img\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;attribute name=\u0026#34;alt\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;attribute name=\u0026#34;src\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;height\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;width\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;attribute name=\u0026#34;action\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;method\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;ref name=\u0026#34;BlockMinusForm\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;label\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;label\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;input\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;attribute name=\u0026#34;type\u0026#34;\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;value\u0026gt;text\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;submit\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;hidden\u0026lt;/value\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;size\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;empty/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;textarea\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;textarea\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;attribute name=\u0026#34;cols\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;attribute name=\u0026#34;rows\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;attribute name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;text/\u0026gt;\u0026lt;/attribute\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;text/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;ref name=\u0026#34;caption\u0026#34;/\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;oneOrMore\u0026gt;\u0026lt;ref name=\u0026#34;tr\u0026#34;/\u0026gt;\u0026lt;/oneOrMore\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;caption\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;caption\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Inline\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;tr\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;tr\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;oneOrMore\u0026gt; \u0026lt;choice\u0026gt; \u0026lt;ref name=\u0026#34;th\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;td\u0026#34;/\u0026gt; \u0026lt;/choice\u0026gt; \u0026lt;/oneOrMore\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;th\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;th\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;define name=\u0026#34;td\u0026#34;\u0026gt; \u0026lt;element name=\u0026#34;td\u0026#34;\u0026gt; \u0026lt;ref name=\u0026#34;Main.attrs\u0026#34;/\u0026gt; \u0026lt;ref name=\u0026#34;Flow\u0026#34;/\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/define\u0026gt; \u0026lt;/grammar\u0026gt; Conclusion Le XHTML est un vocabulaire XML. Vous pouvez en consulter la DTD en ligne, à l'adresse http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd; il ne s'agit pas d'une DTD facile à lire, mais elle est néanmoins disponible. Notez qu'il existe de très bons livres de référence pour approfondir le XHTML, mais pour ce cours, il suffit de connaître les quelques balises présentées dans ce document. Un des avantages importants du XHTML sur des pages web traditionnelles (souvent mal formées) est qu'on peut facilement traiter des pages XHTML avec des outils destinés au XML. En somme, on peut plus facilement extraire et traiter l'information d'une page XHTML que l'on peut le faire d'une page HTML mal formée. Livres de référence Jennifer Robbins, HTML and XHTML Pocket Reference , O'Reilly Media, 2006, 97 pages. Jean Engels, XHTML et css : cours et exercices , Eyrolles, 2006. Activité d'autoévaluation Afin de vous assurez d'avoir bien compris les notions présentées dans cette leçon, vous devez créer un document XHTML valable, utilisant les différents éléments que nous avons étudiés. Afin que votre navigateur reconnaisse le document comme étant du XHTML, vous devriez utiliser l'extension « xhtml ». Si vous déposez le fichier sur un serveur web Apache, il peut être nécessaire de créer aussi un fichier « .htaccess » et de le déposer dans le même répertoire que votre fichier XHTML afin que le serveur puisse reconnaître les fichiers XHTML. Votre fichier « .htaccess » pourrait avoir le contenu suivant : DirectoryIndex index.xhtml index.html index.php index.pl index.cgi AddType application/xml .xhtml "},{"id":18,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/xpath_un_premier_laboratoire/","title":"XPath : un premier laboratoire","section":"XPath","content":" XPath : un premier laboratoire Étant donné un document XML, on peut sélectionner un noeud au sein du document avec une expression XPath. Plus généralement, étant donné un document XML et un noeud courant, on peut sélectionner, relativement à ce noeud, tout autre noeud ou ensemble de noeuds correspondant à un certain motif régulier. Dans cette première activité de familiarisation avec XPath, nous allons d’abord passer en revue rapidement les éléments de base et vous inviter à faire un petit laboratoire. Les expressions XPath les plus simples comprennent seulement un nom XML. Dans ce cas, on sélectionne l’élément ayant le nom correspondant. Par exemple, l’expression « chien » va sélectionner tout élément nommé « chien » et contenu dans le noeud courant. S’il y en a plus d’un, plusieurs éléments pourront être sélectionnés. On peut utiliser l’astérisque (*) pour sélectionner tous les éléments du context courant, peu importe leur nom. Les deux points (..) permettent de sélectionner le parent du noeud courant (indiqué par « . »), ainsi « ../chien » permet de sélectionner les éléments « chien » dans le noeud parent. Si on veut ignorer le noeud courant et sélectionner tous les éléments chien, on peut obtenir ce résultat avec l’expression « //chien ». On peut aussi sélectionner le noeud racine... avec l’expression XPath « / ». Ainsi donc, « /* » sélectionnera toujours l’élément-racine. L’instruction « //* » va sélectionner tous les noeuds du document. On peut sélectionner un attribut avec le symbole « @ ». Ainsi, on peut sélectionner le contenu de l’attribut race de tous les éléments chien avec l’expression « //chien/@race ». \u0026lt;animaux\u0026gt; \u0026lt;chien race=\"caniche\" /\u0026gt; \u0026lt;/animaux\u0026gt; Avant de continuer plus loin avec la syntaxe XPath, nous vous invitons à utiliser le petit script suivant pour vous familiariser davantage avec la syntaxe : XPath en ligne Instructions : il suffit de saisir un document XML source et une expression XPath et d'appuyer sur le bouton. Le contenu textuel de chaque résultat est retourné. L'expression XPath est toujours appliquée à partir du noeud-racine. Cette petite application est limitée: elle suppose que le résultat prend une certaine forme (un ensemble de noeuds ou node set). Fichier XML: \u0026lt;?xml version=\"1.0\" ?\u0026gt; \u0026lt;boite\u0026gt; \u0026lt;monmessage\u0026gt; \u0026lt;de\u0026gt;Jean\u0026lt;/de\u0026gt; \u0026lt;a\u0026gt;Pierre\u0026lt;/a\u0026gt; \u0026lt;titre type=\"émotion\"\u0026gt;Ouch!\u0026lt;/titre\u0026gt; \u0026lt;corps\u0026gt;Maman!\u0026lt;/corps\u0026gt; \u0026lt;/monmessage\u0026gt; \u0026lt;monmessage\u0026gt; \u0026lt;de\u0026gt;Marie\u0026lt;/de\u0026gt; \u0026lt;a\u0026gt;Jean\u0026lt;/a\u0026gt; \u0026lt;titre type=\"émotion\"\u0026gt;Bah!\u0026lt;/titre\u0026gt; \u0026lt;corps\u0026gt;Papa!\u0026lt;/corps\u0026gt; \u0026lt;/monmessage\u0026gt; \u0026lt;/boite\u0026gt; Sélection XPath: Résultat : "},{"id":19,"href":"/orientee_donnees/docs/modules/c_module_xslt/xquery/xquery/","title":"XQuery","section":"XQuery","content":" XQuery # XSLT peut servir pour extraire des informations d\u0026rsquo;un document XML. On peut trouver tous les noms des étudiants répondant à certains critères. Dans un sens, XSLT peut être utilisé comme langage dans le contexte des bases de données. Cependant, pour cette fin spécifique, un nouveau langage appelé XQuery a été proposé. La syntaxe du XQuery est un mélange de XPath et de SQL et ressemble davantage à ce que les spécialistes des bases de données connaissent bien.\nPour tester les requêtes XQuery, Saxon est un outil pratique écrit en java. Pour utiliser Saxon, suivez d\u0026rsquo;abord les consignes à l\u0026rsquo;adresse https://github.com/lemire/javasaxon.\nPour rendre nos exemples plus concrets, prenez le fichier etu.xml suivant.\n\u0026lt;liste\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Laroche\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;statut\u0026gt;inscrit\u0026lt;/statut\u0026gt; \u0026lt;cours\u0026gt; \u0026lt;sigle\u0026gt;INF 6460\u0026lt;/sigle\u0026gt; \u0026lt;note\u0026gt;54\u0026lt;/note\u0026gt; \u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt; \u0026lt;sigle\u0026gt;INF 6450\u0026lt;/sigle\u0026gt; \u0026lt;note\u0026gt;44\u0026lt;/note\u0026gt; \u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Aaron\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;statut\u0026gt;inscrit\u0026lt;/statut\u0026gt; \u0026lt;cours\u0026gt; \u0026lt;sigle\u0026gt;INF 6460\u0026lt;/sigle\u0026gt; \u0026lt;note\u0026gt;56\u0026lt;/note\u0026gt; \u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt; \u0026lt;sigle\u0026gt;INF 6450\u0026lt;/sigle\u0026gt; \u0026lt;note\u0026gt;46\u0026lt;/note\u0026gt; \u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Pouf\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;statut\u0026gt;non-inscrit\u0026lt;/statut\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;/liste\u0026gt; Vous pouvez créer un fichier etu.xml sur votre disque dans le même dossier que le fichier query, et remplacer partout l\u0026rsquo;URI par le nom du fichier (tel que « etu.xml »).\nParce que XQuery, tout comme XSLT 2.0, s\u0026rsquo;appuie sur XPath 2.0, il est facile de calculer la liste des cours :\nfor $s in distinct-values(doc(\u0026#34;etu.xml\u0026#34;)//sigle) return $s Cette requête donnera « INF 6460 INF 6450 ».\nVoici un exemple de requête XQuery pour extraire d\u0026rsquo;un document XML tous les étudiants inscrits en supposant que le fichier XML se trouve à l\u0026rsquo;adresse http://universite.com/etu.xml.\n\u0026lt;maliste\u0026gt; {let $inscription := \u0026#34;inscrit\u0026#34; for $b in doc(\u0026#34;http://universite.com/etu.xml\u0026#34;)/liste/etudiant where $b/statut = $inscription order by $b/nom ascending return \u0026lt;etudiant\u0026gt; { $b/prenom } { $b/nom } \u0026lt;/etudiant\u0026gt;} \u0026lt;/maliste\u0026gt; Cet exemple est une requête de type FLWOR parce qu\u0026rsquo;elle ne contient que des instructions « for », « let », « where », « order by », et « return ». L\u0026rsquo;instruction « for » sert à définir une boucle, l\u0026rsquo;instruction « where » sert à poser une condition, l\u0026rsquo;instruction « order by » permet de trier le résultat, alors que l\u0026rsquo;instruction « return » définit le résultat. L\u0026rsquo;instruction « let » permet de définir une constante. Notez que XQuery utilise les accolades pour distinguer les requêtes XQuery et XPath du texte. La requête considère tous les éléments etudiant contenus dans l\u0026rsquo;élément-racine liste, pour chacun d\u0026rsquo;entre eux, elle vérifie qu\u0026rsquo;il contient un élément statut contenant le texte « inscrit », puis elle donne la liste des noms et prénoms triée selon le nom. Voici quel sera le résultat :\n\u0026lt;maliste\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Aaron\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Laroche\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;/maliste\u0026gt; On peut attribuer un compteur aux nœuds :\n\u0026lt;maliste\u0026gt; { for $b at $pos in doc(\u0026#34;http://universite.com/etu.xml\u0026#34;)/liste/etudiant order by $b/nom descending return \u0026lt;etudiant\u0026gt; $pos - { $b/prenom } { $b/nom } \u0026lt;/etudiant\u0026gt; } \u0026lt;/maliste\u0026gt; Le résultat sera alors :\n\u0026lt;maliste\u0026gt; \u0026lt;etudiant\u0026gt;3- \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Pouf\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt;1- \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Laroche\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt;2- \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Aaron\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;/maliste\u0026gt; On peut combiner les requêtes FLWOR, comme dans cet exemple :\n\u0026lt;maliste\u0026gt; {for $e in doc(\u0026#34;http://universite.com/etu.xml\u0026#34;)//etudiant return \u0026lt;etudiant nom=\u0026#34;{$e/nom}\u0026#34;\u0026gt; { for $v in $e/cours return \u0026lt;note\u0026gt;{number($v/note)}\u0026lt;/note\u0026gt; } \u0026lt;/etudiant\u0026gt; } \u0026lt;/maliste\u0026gt; Cette requête va considérer chaque élément etudiant du document XML et créer une liste de notes obtenues pour cet étudiant, dans ce cas, le résultat sera :\n\u0026lt;maliste\u0026gt; \u0026lt;etudiant nom=\u0026#34;Laroche\u0026#34;\u0026gt; \u0026lt;note\u0026gt;54\u0026lt;/note\u0026gt; \u0026lt;note\u0026gt;44\u0026lt;/note\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant nom=\u0026#34;Aaron\u0026#34;\u0026gt; \u0026lt;note\u0026gt;56\u0026lt;/note\u0026gt; \u0026lt;note\u0026gt;46\u0026lt;/note\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant nom=\u0026#34;Pouf\u0026#34;/\u0026gt; \u0026lt;/maliste\u0026gt; L\u0026rsquo;expression suivante va calculer la moyenne de notes (50) :\n\u0026lt;maliste\u0026gt; {avg( for $n in doc(\u0026#34;http://universite.com/etu.xml\u0026#34;)//note return $n )} \u0026lt;/maliste\u0026gt; Par défaut, les documents XQuery utilisent le jeu de caractères Unicode UTF-8. On peut stipuler un jeu de caractères différent dans la déclaration XQuery optionnelle comme dans cet exemple :\nxquery version \u0026#34;1.0\u0026#34; encoding \u0026#34;utf-8\u0026#34;; for $s in distinct-values(doc(\u0026#34;etu.xml\u0026#34;)//sigle) return $s Elliotte Rusty Harold nous offre une excellente page sur XQuery qui résume bien les points essentiels avec des exemples.\nSaxon en ligne # Vous pouvez aussi tester Saxon en ligne pour exécuter des requêtes XQuery.\nMain.java import net.sf.saxon.s9api.*; import java.io.StringWriter; public class Main { public static void main(String[] args) { // XML intégré directement dans le code Java (chaîne multi-ligne) String xmlContent = \u0026#34;\u0026#34;\u0026#34; \u0026lt;bibliotheque\u0026gt; \u0026lt;livre\u0026gt; \u0026lt;titre\u0026gt;Le Petit Prince\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Antoine de Saint-Exupéry\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1943\u0026lt;/annee\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre\u0026gt; \u0026lt;titre\u0026gt;1984\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;George Orwell\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1949\u0026lt;/annee\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre\u0026gt; \u0026lt;titre\u0026gt;Le Seigneur des Anneaux\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;J.R.R. Tolkien\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1954\u0026lt;/annee\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;/bibliotheque\u0026gt; \u0026#34;\u0026#34;\u0026#34;; // Requête XQuery qui construit le document à partir de la chaîne String xquery = \u0026#34;\u0026#34;\u0026#34; declare variable $doc external; \u0026lt;resultats\u0026gt;{ for $livre in $doc//livre return \u0026lt;titre\u0026gt;{data($livre/titre)}\u0026lt;/titre\u0026gt; }\u0026lt;/resultats\u0026gt; \u0026#34;\u0026#34;\u0026#34;; try { Processor processor = new Processor(false); // Saxon-HE DocumentBuilder builder = processor.newDocumentBuilder(); // Construction du document XML à partir de la chaîne XdmNode document = builder.build( new javax.xml.transform.stream.StreamSource( new java.io.StringReader(xmlContent) ) ); XQueryCompiler compiler = processor.newXQueryCompiler(); // Déclaration de la variable externe $doc compiler.declareNamespace(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;); // namespace par défaut si nécessaire XQueryExecutable executable = compiler.compile(xquery); XQueryEvaluator evaluator = executable.load(); // Passage de la variable externe $doc evaluator.setExternalVariable( new QName(\u0026#34;doc\u0026#34;), document ); XdmValue result = evaluator.evaluate(); // Sérialisation du résultat StringWriter writer = new StringWriter(); Serializer serializer = processor.newSerializer(writer); serializer.serializeXdmValue(result); System.out.println(writer.toString()); } catch (SaxonApiException e) { System.err.println(\u0026#34;Erreur lors de l\u0026#39;exécution XQuery : \u0026#34; \u0026#43; e.getMessage()); e.printStackTrace(); } } } Exécuter "},{"id":20,"href":"/orientee_donnees/docs/modules/b_module_xml/programmation/javascript/","title":"JavaScript et DOM","section":"Modèles de programmation","content":" DOM et JavaScript # Les implémentations JavaScript supportent bien l\u0026rsquo;API DOM en général. La principale différence entre DOM en JavaScript et DOM en Java est que certaines méthodes en Java deviennent des attributs ou des propriétés en JavaScript (getNodeValue() devient nodeValue).\nJavaScript peut donc lire et traiter des documents XML avec l\u0026rsquo;API DOM. En particulier, si JavaScript est utilisé au sein d\u0026rsquo;une page XHTML, le script peut modifier la page dynamiquement en utilisant l\u0026rsquo;API DOM. La principale différence entre l\u0026rsquo;utilisation de DOM en Java et JavaScript est qu\u0026rsquo;à l\u0026rsquo;exception des méthodes getAttribute, setAttribute, getAttributeNS, setAttributeNS, getAttributeNode, setAttributeNode, getAttributeNodeNS, setAttributeNodeNS, getElementsByTagName et getElementById, toutes les méthodes dont le nom commence par « get » ou « set » sont remplacées par un attribut de l\u0026rsquo;objet (ou « property » en anglais). Au lieu d\u0026rsquo;écrire « e.getChildNodes(); », on écrit « e.childNodes; », au lieu d\u0026rsquo;écrire « e.setNodeValue(\u0026ldquo;texte\u0026rdquo;); », on écrit « e.nodeValue=\u0026ldquo;texte\u0026rdquo;; », et ainsi de suite.\nPar exemple, le script suivant va ajouter du texte lorsque la souris passera sur l\u0026rsquo;élément ayant un attribut « id=\u0026lsquo;javatest\u0026rsquo; ».\nmonele=document.getElementById(\u0026#39;javatest\u0026#39;); monele.childNodes.item(0).nodeValue+=\u0026#39; (passage de souris) \u0026#39;; Ce petit script illustre plusieurs points importants. D\u0026rsquo;abord, document.getElementById('javatest') recherche dans le document l\u0026rsquo;élément qui porte l\u0026rsquo;attribut id=\u0026quot;javatest\u0026quot; et retourne une référence à cet élément (ou null si aucun élément n\u0026rsquo;est trouvé). C\u0026rsquo;est l\u0026rsquo;un des moyens les plus rapides et les plus courants pour cibler un élément unique dans la page.\nEnsuite, monele.childNodes.item(0).nodeValue accède au premier nœud enfant de l\u0026rsquo;élément — souvent un nœud Text contenant le texte interne — et en modifie la valeur. Cette approche fonctionne si le premier nœud enfant est bien un nœud de texte ; dans le cas contraire (par exemple si l\u0026rsquo;élément contient d\u0026rsquo;autres éléments enfants), il faudra tester le type du nœud ou préférer textContent pour manipuler tout le texte intérieur.\nConcernant les événements, l\u0026rsquo;exemple suppose implicitement qu\u0026rsquo;une gestion d\u0026rsquo;événement a été définie ailleurs. En pratique on préfère attacher explicitement un écouteur d\u0026rsquo;événement moderne :\nconst el = document.getElementById(\u0026#39;javatest\u0026#39;); el.addEventListener(\u0026#39;mouseover\u0026#39;, () =\u0026gt; { el.textContent += \u0026#39; (passage de souris)\u0026#39;; }); L\u0026rsquo;objet document permet de modifier dynamiquement le contenu, la structure et le style de la page, ce qui est essentiel pour créer des applications web interactives. Il est automatiquement disponible dans tous les scripts exécutés dans le contexte d\u0026rsquo;une page web.\nExemple : Chargement et énumération d\u0026rsquo;un document XML # Voici un exemple complet de programme JavaScript qui charge un document XML (ici depuis une chaîne pour simplicité, mais on pourrait utiliser fetch pour charger depuis un fichier), puis énumère récursivement tous les éléments et leurs contenus.\nconst xmlString = `\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;catalogue\u0026gt; \u0026lt;livre id=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;JavaScript pour les nuls\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;John Doe\u0026lt;/auteur\u0026gt; \u0026lt;prix\u0026gt;29.99\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre id=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;XML en pratique\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Jane Smith\u0026lt;/auteur\u0026gt; \u0026lt;prix\u0026gt;34.50\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;/catalogue\u0026gt;`; // Parser le XML const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, \u0026#34;text/xml\u0026#34;); // Vérifier s\u0026#39;il y a des erreurs de parsing const parseError = xmlDoc.querySelector(\u0026#34;parsererror\u0026#34;); if (parseError) { document.getElementById(\u0026#39;resultat\u0026#39;).textContent = \u0026#34;Erreur de parsing XML: \u0026#34; + parseError.textContent; return; } // Fonction récursive pour énumérer les éléments function enumererElement(element, niveau = 0) { console.log(\u0026#34;element\u0026#34;); let resultat = \u0026#34;\u0026#34;; const indentation = \u0026#34; \u0026#34;.repeat(niveau); // Afficher le nom de l\u0026#39;élément et ses attributs resultat += indentation + \u0026#34;\u0026lt;\u0026#34; + element.tagName; for (let attr of element.attributes) { resultat += \u0026#34; \u0026#34; + attr.name + \u0026#34;=\\\u0026#34;\u0026#34; + attr.value + \u0026#34;\\\u0026#34;\u0026#34;; } resultat += \u0026#34;\u0026gt;\\n\u0026#34;; // Énumérer les nœuds enfants for (let child of element.childNodes) { if (child.nodeType === Node.ELEMENT_NODE) { // Élément enfant resultat += enumererElement(child, niveau + 1); } else if (child.nodeType === Node.TEXT_NODE \u0026amp;\u0026amp; child.textContent.trim()) { // Nœud de texte non vide resultat += indentation + \u0026#34; \u0026#34; + child.textContent.trim() + \u0026#34;\\n\u0026#34;; } } // Fermer l\u0026#39;élément resultat += indentation + \u0026#34;\u0026lt;/\u0026#34; + element.tagName + \u0026#34;\u0026gt;\\n\u0026#34;; return resultat; } // Commencer l\u0026#39;énumération depuis la racine const racine = xmlDoc.documentElement; console.log(enumererElement(racine)); Exemple : Génération d\u0026rsquo;un document XML en JavaScript # // Création d\u0026#39;un nouveau document XML vide (sans namespace par défaut) const doc = document.implementation.createDocument(null, \u0026#39;racine\u0026#39;, null); // Ajout d\u0026#39;attributs à l\u0026#39;élément racine doc.documentElement.setAttribute(\u0026#39;version\u0026#39;, \u0026#39;1.0\u0026#39;); doc.documentElement.setAttribute(\u0026#39;lang\u0026#39;, \u0026#39;fr\u0026#39;); // Création d\u0026#39;un élément \u0026lt;personne\u0026gt; avec un attribut id const personne1 = doc.createElement(\u0026#39;personne\u0026#39;); personne1.setAttribute(\u0026#39;id\u0026#39;, \u0026#39;1\u0026#39;); // Ajout de sous-éléments texte const nom = doc.createElement(\u0026#39;nom\u0026#39;); nom.textContent = \u0026#39;Dupont\u0026#39;; const prenom = doc.createElement(\u0026#39;prenom\u0026#39;); prenom.textContent = \u0026#39;Jean\u0026#39;; const age = doc.createElement(\u0026#39;age\u0026#39;); age.textContent = \u0026#39;35\u0026#39;; // Assemblage de la structure personne1.appendChild(nom); personne1.appendChild(prenom); personne1.appendChild(age); // Ajout d\u0026#39;une deuxième personne pour l\u0026#39;exemple const personne2 = doc.createElement(\u0026#39;personne\u0026#39;); personne2.setAttribute(\u0026#39;id\u0026#39;, \u0026#39;2\u0026#39;); const nom2 = doc.createElement(\u0026#39;nom\u0026#39;); nom2.textContent = \u0026#39;Martin\u0026#39;; const prenom2 = doc.createElement(\u0026#39;prenom\u0026#39;); prenom2.textContent = \u0026#39;Sophie\u0026#39;; const age2 = doc.createElement(\u0026#39;age\u0026#39;); age2.textContent = \u0026#39;28\u0026#39;; personne2.appendChild(nom2); personne2.appendChild(prenom2); personne2.appendChild(age2); // Ajout des deux personnes à la racine doc.documentElement.appendChild(personne1); doc.documentElement.appendChild(personne2); // Ajout d\u0026#39;un commentaire XML const commentaire = doc.createComment(\u0026#39;Exemple de génération XML avec l\\\u0026#39;API DOM\u0026#39;); doc.documentElement.insertBefore(commentaire, personne1); // Sérialisation du document XML en string const serializer = new XMLSerializer(); const xmlString = serializer.serializeToString(doc); // Ajout de la déclaration XML au début pour un rendu plus complet const xmlComplet = \u0026#39;\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\\n\u0026#39; + xmlString; // Affichage dans la console console.log(\u0026#39;XML généré :\\n\u0026#39;); console.log(xmlComplet); Mise à l\u0026rsquo;essai # Utilisez la console suivante pour tester vos programmes JavaScript.\nExécuter le code Console prête. Écrivez du code et cliquez sur \"Exécuter le code\". // Exemple de code JavaScript console.log(\"Bonjour le monde !\"); for (let i = 1; i Activités suggérées # Pour renforcer votre compréhension de l\u0026rsquo;interaction entre JavaScript et le DOM, voici des activités pratiques à réaliser.\nGénération d\u0026rsquo;une liste à partir d\u0026rsquo;un tableau : Définissez un tableau de chaînes en JavaScript (par exemple, des noms de villes). Utilisez une boucle pour créer dynamiquement des éléments \u0026lt;ville\u0026gt; dans une liste \u0026lt;liste\u0026gt;.\nParsing et affichage de données XML : Créez une chaîne XML représentant une liste de livres (titre, auteur, prix). Utilisez DOMParser pour analyser le XML, puis parcourez les éléments pour afficher les informations dans une liste HTML.\n"},{"id":21,"href":"/orientee_donnees/docs/modules/a_module_json/json/","title":"JSON","section":"Module JSON","content":" JSON # Le format JSON (JavaScript Object Notation) est un standard ouvert pour l\u0026rsquo;échange de données, largement adopté pour sa simplicité et sa lisibilité. Introduit en 2001 par Douglas Crockford, il est devenu essentiel dans le développement web, les API REST et les configurations d\u0026rsquo;applications modernes.\nLes types de données supportés par JSON sont limités mais suffisants pour la plupart des cas d\u0026rsquo;usage : chaînes de caractères entre guillemets doubles, nombres (entiers ou flottants), booléens (true/false), null, objets (paires clé-valeur) et tableaux (listes ordonnées). Cette simplicité facilite le parsing et la génération, avec des bibliothèques natives dans presque tous les langages de programmation.\nUn objet JSON est délimité par des accolades {} et contient des paires clé-valeur séparées par des virgules. Les clés sont toujours des chaînes, tandis que les valeurs peuvent être de n\u0026rsquo;importe quel type JSON valide. Par exemple : {\u0026quot;nom\u0026quot;: \u0026quot;Alice\u0026quot;, \u0026quot;âge\u0026quot;: 30, \u0026quot;actif\u0026quot;: true} représente un objet simple avec trois propriétés.\nLes tableaux JSON utilisent des crochets [] et contiennent des valeurs séparées par des virgules. Ils peuvent mélanger différents types : [1, \u0026quot;deux\u0026quot;, true, null, {\u0026quot;clé\u0026quot;: \u0026quot;valeur\u0026quot;}]. Cette flexibilité permet de représenter des structures complexes comme des listes d\u0026rsquo;objets ou des matrices multidimensionnelles.\nLa syntaxe JSON est stricte : pas de commentaires, pas de virgule finale, guillemets doubles obligatoires pour les chaînes, pas de fonctions ou d\u0026rsquo;expressions. Cette rigueur assure une interopérabilité parfaite entre systèmes, mais peut rendre l\u0026rsquo;écriture manuelle fastidieuse pour les fichiers de configuration complexes.\nPour les chaînes de caractères, JSON supporte les séquences d\u0026rsquo;échappement standard : \\\u0026quot; pour les guillemets, \\\\ pour la barre oblique inverse, \\/ pour la barre oblique, \\b, \\f, \\n, \\r, \\t, et \\uXXXX pour les caractères Unicode. Cela permet d\u0026rsquo;inclure n\u0026rsquo;importe quel caractère dans les chaînes.\nLes nombres en JSON suivent la notation décimale standard, sans distinction entre entiers et flottants. Ils peuvent être positifs ou négatifs, avec ou sans partie décimale : 42, -3.14, 1e10. Attention aux précisions flottantes qui peuvent varier selon les langages.\nLa valeur null représente l\u0026rsquo;absence de valeur, équivalente à undefined en JavaScript ou None en Python. Elle est souvent utilisée pour indiquer des champs optionnels non définis.\nL\u0026rsquo;imbrication est une force de JSON : objets dans des tableaux, tableaux dans des objets, permettant des structures hiérarchiques complexes. Par exemple, un catalogue de produits peut être représenté comme un objet contenant un tableau d\u0026rsquo;objets produit, chacun avec ses propriétés.\nMalgré ses limitations (pas de dates natives, pas de commentaires, pas de références circulaires), JSON excelle dans les échanges de données légères et structurées. Pour des besoins plus avancés, des extensions comme JSON Schema permettent de valider la structure des documents JSON.\nVoici un exemple plus élaboré montrant une structure JSON typique pour une API :\n{ \u0026#34;utilisateur\u0026#34;: { \u0026#34;id\u0026#34;: 12345, \u0026#34;nom\u0026#34;: \u0026#34;Dupont\u0026#34;, \u0026#34;prénom\u0026#34;: \u0026#34;Marie\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;marie.dupont@example.com\u0026#34;, \u0026#34;profil\u0026#34;: { \u0026#34;date_naissance\u0026#34;: \u0026#34;1990-05-15\u0026#34;, \u0026#34;ville\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;pays\u0026#34;: \u0026#34;France\u0026#34; }, \u0026#34;commandes\u0026#34;: [ { \u0026#34;id_commande\u0026#34;: \u0026#34;CMD-001\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;2023-12-01\u0026#34;, \u0026#34;montant\u0026#34;: 149.99, \u0026#34;articles\u0026#34;: [ {\u0026#34;nom\u0026#34;: \u0026#34;Livre JSON\u0026#34;, \u0026#34;quantité\u0026#34;: 1, \u0026#34;prix\u0026#34;: 29.99}, {\u0026#34;nom\u0026#34;: \u0026#34;Cours JavaScript\u0026#34;, \u0026#34;quantité\u0026#34;: 2, \u0026#34;prix\u0026#34;: 60.00} ] } ] } } Cet exemple illustre comment JSON peut représenter des données relationnelles complexes avec imbrication et tableaux. Chaque niveau ajoute de la structure sans complexité syntaxique excessive.\nApplication d'Arborescence JSON Entrez un contenu JSON dans le champ ci-dessous, puis cliquez sur \"Dessine\" pour afficher l'arborescence sous forme de liste hiérarchique. Exemple : { \"library\": { \"books\": [ { \"id\": 1, \"genre\": \"fiction\", \"title\": \"The Hobbit\", \"author\": \"J.R.R. Tolkien\" }, { \"id\": 2, \"genre\": \"non-fiction\", \"title\": \"Sapiens\", \"author\": \"Yuval Noah Harari\" } ] } } Contenu JSON : { \"library\": { \"books\": [ { \"id\": 1, \"genre\": \"fiction\", \"title\": \"The Hobbit\", \"author\": \"J.R.R. Tolkien\" }, { \"id\": 2, \"genre\": \"non-fiction\", \"title\": \"Sapiens\", \"author\": \"Yuval Noah Harari\" } ] } } Dessine À lire :\nprésentation de JSON sur json.org "},{"id":22,"href":"/orientee_donnees/docs/modules/b_module_xml/rdf/autoevaluation_rdf/","title":"Autoévaluation","section":"RDF","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Parmi les affirmations suivantes, lesquelles s'appliquent à la norme Dublin Core ? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». We've collated all the most relevant information on free spins - https://slots-online-canada.ca/casino-bonuses/free-spins/ no deposit offers. La première version de Dublin Core a été publiée en 2001. Non. C'est en juillet 1999. Dublin Core est une forme de RDF. Effectivement. Dublin Core est une forme de XML. Non. L'information Dublin Core est souvent écrite en XML, mais n'a pas à l'être. La norme Dublin Core peut être utilisée pour décrire des photographies ou objets multimédias. Oui. En fait, la norme Dublin Core s'applique à toute création humaine (livres, films, etc.). Question 2 . Choisissez l'affirmation qui décrit le mieux l'information contenue dans ce document Dublin Core : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/dc/elements/1.1/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"http://www.ledevoir.com/2004/09/30/65081.html\"\u0026gt; \u0026lt;creator\u0026gt;Alec Castonguay\u0026lt;/creator\u0026gt; \u0026lt;title\u0026gt;Harper est prêt pour de nouvelles élections\u0026lt;/title\u0026gt; \u0026lt;date\u0026gt;2004-09-30\u0026lt;/date\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il y a un article à l'URL « http://www.ledevoir.com/2004/09/30/65081.html » écrit par quelqu'un nommé Alec Castonguay; l'article a été écrit le 30 septembre 2004 et porte le titre « Harper est prêt pour de nouvelles élections ». (Réponse incorrecte!) Non. Le lien « http://www.ledevoir.com/2004/09/30/65081.html » est un URI, pas nécessairement un URL. Le document ayant l'URI « http://www.ledevoir.com/2004/09/30/65081.html », portant le titre « Harper est prêt pour de nouvelles élections » et daté du 30 septembre 2004, a été écrit par quelqu'un nommé Alec Castonguay. (Réponse correcte!) Effectivement. Alec Castonguay a écrit l'article ayant l'URI « http://www.ledevoir.com/2004/09/30/65081.html » et le titre « Harper est prêt pour de nouvelles élections », le 30 septembre 2004. (Réponse incorrecte!) Non. On ne sait pas quand l'article a été écrit : la date dans Dublin Core n'a pas une signification établie. La date pourrait plutôt être la date de publication. Question 3 . Parmi les affirmations suivantes, lesquelles s'appliquent à la norme Creative Commons ? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». La première version de Creative Common s a été publiée en 2001. Correct. Creative Commons est une forme de RDF. Effectivement. Creative Commons sert surtout à décrire le contenu des documents. Non. Creative Commons sert surtout à décrire les droits associés à des documents. Question 4 . Choisissez l'affirmation qui décrit le mieux l'information contenue dans ce document Creative Commons : \u0026lt;rdf:RDF xmlns=\"http://web.resource.org/cc/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\u0026gt; \u0026lt;Work rdf:about=\"http://www.mavieestbelle.com/index.html\"\u0026gt; \u0026lt;license rdf:resource=\"http://creativecommons.org/licenses/by-nd/2.0/\" /\u0026gt; \u0026lt;license rdf:resource=\"http://creativecommons.org/licenses/by-nc/2.0/\" /\u0026gt; \u0026lt;/Work\u0026gt; \u0026lt;License rdf:about=\"http://creativecommons.org/licenses/by-nd/2.0/\"\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Reproduction\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Distribution\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Notice\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Attribution\" /\u0026gt; \u0026lt;/License\u0026gt; \u0026lt;License rdf:about=\"http://creativecommons.org/licenses/by-nc/2.0/\"\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Reproduction\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/Distribution\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Notice\" /\u0026gt; \u0026lt;requires rdf:resource=\"http://web.resource.org/cc/Attribution\" /\u0026gt; \u0026lt;prohibits rdf:resource=\"http://web.resource.org/cc/CommercialUse\" /\u0026gt; \u0026lt;permits rdf:resource=\"http://web.resource.org/cc/DerivativeWorks\" /\u0026gt; \u0026lt;/License\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Choisissez la bonne réponse parmi les suivantes. Ce document n'est pas valable. (Réponse incorrecte!) Non. Il s'agit un document valable. Le document à l'URL « http://www.mavieestbelle.com/index.html » peut être modifié et reproduit dans un contexte non commercial ou reproduit sans modification dans un contexte commercial. (Réponse incorrecte!) L'adresse « http://www.mavieestbelle.com/index.html » doit être traitée comme un URI et non comme une URL; il pourrait ne pas y avoir de document à cette adresse. Le document représenté par l'URI « http://www.mavieestbelle.com/index.html » peut être modifié et reproduit dans un contexte non commercial ou reproduit sans modification dans un contexte commercial. (Réponse correcte!) Effectivement. Question 5 . Comment peut-on expliquer que le premier document FOAF en XML n'était pas du RDF valable? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Au départ, FOAF ne devait pas être du RDF. Non. Tout document FOAF doit être du RDF valable. FOAF est un projet informel qui ne respecte pas toujours les normes. Non. Le premier document FOAF était une forme de RDF, mais on n'écrit plus le RDF de cette façon. La première spécification du RDF date de 1999. Effectivement. En 1998, Daniel Brickley était un précurseur du RDF. Question 6 . Lesquelles de ces affirmations sont vraies? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Pour l'essentiel, les applications RDF présentées dans ce cours, telles que Dublin Core , datent de 1999. C'est vrai. Seul Creative Commons est plus récent. Un document FOAF doit être du RDF valable. C'est vrai, même si l'exemple original de Dan Brickley n'est pas du RDF/XML valable. RSS est une technologie émergente peu utilisée. Au contraire, des milliers de portails et des millions de sites web utilisent maintenant RSS . "},{"id":23,"href":"/orientee_donnees/legacy/semaine_5/autoevaluation/","title":"Autoévaluation","section":"Semaine 5","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Quel énoncé décrit le mieux l'intention des créateurs du XML? Choisissez la bonne réponse parmi les suivantes. Ils voulaient créer un format destiné aux programmeurs. (Réponse incorrecte!) Bien que cela soit vrai en partie, leur but premier était de créer un format de documents simple et efficace. Ils voulaient créer un format de documents similaire au SGML ou au HTML. (Réponse correcte!) Effectivement. Ils voulaient créer un format universel pour l'échange des données sur le web. (Réponse incorrecte!) Non. Leur but premier était de créer un format pour les documents. Question 2 . Parmi les affirmations suivantes, lesquelles s'appliquent au XML? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Le XML aide à séparer le contenu d'un document de sa présentation. Effectivement, dans le contexte des documents XML, le XML sert le plus souvent à décrire le contenu du document plutôt que la façon dont il sera présenté. On utilise d'autres technologies, comme les technologies CSS ou XSLT pour la présentation. Le XML encourage l'utilisation des formats propriétaires dans la création des documents comme Microsoft Word 97 ou PowerPoint 97. Non. Le XML n'encourage pas les formats propriétaires pour les documents; il encourage plutôt l'utilisation d'applications XML qui agissent comme des normes acceptées par des communautés. Le XML permet de publier un même document dans plusieurs formats. Généralement, la version XML originale n'est pas destinée à être lue par les humains; on s'attend plutôt à ce que le document XML soit transformé ou publié dans un format pratique pour la lecture. Question 3 . Voici un exemple de document DocBook XML valide. Parmi les énoncés qui suivent, quels sont ceux qui s'appliquent à ce document? \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\" [ \u0026lt;!ENTITY prenomduresponsable \"Jean\"\u0026gt; \u0026lt;!ENTITY nomduresponsable \"Lachat\"\u0026gt; ]\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;\u0026amp;prenomduresponsable;\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;\u0026amp;nomduresponsable;\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;\u0026amp;prenomduresponsable; \u0026amp;nomduresponsable;\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt;\n\u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt; En cas de problème avec ce document, veuillez vous adresser à \u0026amp;prenomduresponsable; \u0026amp;nomduresponsable;.\u0026lt;/para\u0026gt; \u0026lt;para\u0026gt;Pour l\u0026rsquo;instant, il n\u0026rsquo;y a rien d\u0026rsquo;autre dans le document.\u0026lt;/para\u0026gt; \u0026lt;!\u0026ndash; Il faudrait bien que je me dépêche de terminer ce document. \u0026ndash;\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt;\nChoisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Dans ce document, il suffit de modifier le nom du responsable à un seul endroit et les changements s'appliqueront automatiquement dans tout le document. Effectivement, la DTD interne contient deux déclarations d'entités qui nous permettent d'éviter de recopier partout le nom du responsable. On ne risque donc pas de commettre des erreurs si jamais on devait changer ce nom. Le document contient un chapitre et deux paragraphes. Effectivement, la structure du document est claire. Une fois publié dans un format comme HTML, PDF ou RTF, le lecteur verra un chapitre commençant par \"Ceci est le premier chapitre\" et se terminant avec \"terminer ce document\". Non, la phrase \"Il faudrait bien que je me dépêche à terminer ce document.\" est un commentaire XML et ne sera normalement pas incluse dans la version destinée à la consommation par des humains. Question 4 . Qu'est-ce qui ne va pas avec le document DocBook suivant? \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" \"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd\"\u0026gt; \u0026lt;para\u0026gt; Je suis \u0026lt;emphasis\u0026gt;certain\u0026lt;/emphasis\u0026gt; que ce document est du XML valide! \u0026lt;/para\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien. Il s'agit d'un document valide. (Réponse incorrecte!) Non. La déclaration de type déclare l'élément-racine « book », alors que l'élément-racine est « para ». Il y a une erreur dans la déclaration de type. (Réponse correcte!) Effectivement, il faudrait avoir \u0026lt;!DOCTYPE para PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" et non \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.1.2//EN\" comme première partie de la déclaration de type, puisque l'élément-racine est de type « para » et non « book ». Il y a une erreur dans l'élément « para ». (Réponse incorrecte!) Non. L'élément « para » est correct. Question 5 . Parmi les énoncés suivants, quels sont ceux qui s'appliquent au format DocBook? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». L'auteur d'un document DocBook se soucie uniquement du contenu et ne perd pas de temps à choisir des polices de caractères ou des couleurs pour son texte. Effectivement. Si plusieurs personnes produisent la documentation pour un projet, il n'y a aucun problème à faire en sorte que la présentation soit uniforme, puisque le format DocBook ne contient aucune information touchant la présentation du texte. Effectivement, puisqu'il n'y a pas d'information de formatage dans les documents DocBook, le formatage se fait dans une deuxième étape. Le format DocBook est du XML; on peut donc employer tous les outils XML sur tous les documents DocBook. Ce n'est malheureusement pas entièrement vrai. La plupart des nouveaux documents DocBook sont écrits en XML, mais il existe encore beaucoup de documents DocBook qui ne sont pas du XML, mais du SGML. Question 6 . Votre société décide d'utiliser le XML comme format d'échange pour ses listes de numéros de série; elle pourra ainsi utiliser les outils XML et assurer la pérennité des documents. L'ingénieur en charge propose deux formats possibles. Quel format choisissez-vous? Dites pourquoi. \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1'?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;numero_de_serie\u0026gt;232-434\u0026lt;/numero_de_serie\u0026gt; \u0026lt;numero_de_serie\u0026gt;333-434\u0026lt;/numero_de_serie\u0026gt; \u0026lt;numero_de_serie\u0026gt;111-434\u0026lt;/numero_de_serie\u0026gt; \u0026lt;numero_de_serie\u0026gt;444-555\u0026lt;/numero_de_serie\u0026gt; \u0026lt;/liste\u0026gt; \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1'?\u0026gt; \u0026lt;liste\u0026gt;232-434 333-434 111-434 444-555\u0026lt;/liste\u0026gt; Choisissez la bonne réponse parmi les suivantes. Le premier choix est préférable, car il n'y a qu'un seul numéro de série par ligne et le résultat est plus lisible. (Réponse incorrecte!) Non. On pourrait très bien récrire ce même document avec tous les numéros sur la même ligne, tout en produisant un document XML équivalent du point de vue des balises. Le second choix est préférable parce qu'il utilise moins d'espace. (Réponse incorrecte!) Il est vrai qu'il utilise moins d'espace, mais il est difficile de comprendre le contenu; dans 10 ou 20 ans, on ne saura plus ce qui signifie tous ces numéros. Le premier choix est préférable parce qu'on peut voir tout de suite les numéros de série. (Réponse correcte!) Effectivement. On dit qu'un tel document fourni une autodescription des données. Question 7 . Parmi les suivants, quels sont les documents DocBook valides? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.4CR2//EN\" \"http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\"\u0026gt; \u0026lt;?xml-stylesheet href=\"docbook.xslt\" type=\"application/xml\"?\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Jean\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Bergeron\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;UQ\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;orderedlist\u0026gt; \u0026lt;listitem\u0026gt; \u0026lt;para\u0026gt;Ceci est le premier point\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;listitem\u0026gt;\u0026lt;para\u0026gt;Ceci est le second point\u0026lt;/para\u0026gt; \u0026lt;para\u0026gt;Ceci est le troisième point\u0026lt;/para\u0026gt; \u0026lt;/listitem\u0026gt; \u0026lt;/orderedlist\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Il s'agit d'un document bien formé et valide. Les éléments « listitem » peuvent contenir plusieurs éléments « para ». \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.4CR2//EN\" \"http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\"\u0026gt; \u0026lt;?xml-stylesheet href=\"docbook.xslt\" type=\"application/xml\"?\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Jean\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Bergeron\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;UQ\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Voici un exemple de code Java:\u0026lt;/para\u0026gt; \u0026lt;para\u0026gt;\u0026lt;programlisting\u0026gt; public static void main(String[] arg) { System.out.println(\"Allo!\"); } \u0026lt;/programlisting\u0026gt;\u0026lt;/para\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Il s'agit d'un document bien formé et valide. Il est parfaitement permis de mettre un élément « programlisting » dans un élément « para ». \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.4CR2//EN\" \"http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\"\u0026gt; \u0026lt;?xml-stylesheet href=\"docbook.xslt\" type=\"application/xml\"?\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Jean\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Bergeron\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;UQ\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;programlisting\u0026gt; public static void main(String[] arg) { System.out.println(\"Allo!\"); } \u0026lt;/programlisting\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Le document est bien formé, mais n'est pas valide : l'élément « title » doit apparaître en premier dans un élément « chapter », et non pas en dernier. \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.4CR2//EN\" \"http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\"\u0026gt; \u0026lt;?xml-stylesheet href=\"docbook.xslt\" type=\"application/xml\"?\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Jean\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Bergeron\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;UQ\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Voici un exemple de code Java:\u0026lt;/para\u0026gt; \u0026lt;para\u0026gt;\u0026lt;programlisting\u0026gt; public static void main(String[] arg) { if(arg.length\u0026lt;1) System.out.println(\"Vous devez mettre un argument.\"); } \u0026lt;/programlisting\u0026gt;\u0026lt;/para\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Le document n'est pas bien formé : le code Java contient un symbole \u0026lt; : il aurait fallu utiliser l'entité « \u0026amp;lt; ». \u0026lt;?xml version=\"1.0\" encoding='ISO-8859-1' standalone=\"no\"?\u0026gt; \u0026lt;!DOCTYPE book PUBLIC \"-//OASIS//DTD DocBook XML V4.4CR2//EN\" \"http://www.oasis-open.org/docbook/xml/4.4CR2/docbookx.dtd\"\u0026gt; \u0026lt;?xml-stylesheet href=\"docbook.xslt\" type=\"application/xml\"?\u0026gt; \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Jean\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Bergeron\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;UQ\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Ceci est le premier chapitre de notre documentation.\u0026lt;/title\u0026gt; \u0026lt;orderedlist\u0026gt; \u0026lt;listitem\u0026gt;Ceci est le premier point\u0026lt;/listitem\u0026gt; \u0026lt;listitem\u0026gt;Ceci est le second point\u0026lt;/listitem\u0026gt; \u0026lt;/orderedlist\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Le document est bien formé, mais n'est pas valide : il n'est pas permis de mettre du texte directement dans un élément « listitem », il faut utiliser un élément « para ». "},{"id":24,"href":"/orientee_donnees/docs/modules/b_module_xml/programmation/autoevaluation/","title":"Autoévaluation DOM","section":"Modèles de programmation","content":" Autoévaluation DOM # Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Si j'ai une application DOM et que je charge 100 fichiers XML faisant un Mo chacun, je m'attends que mon programme utilise au moins 100 Mo. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse correcte!) Effectivement. Faux (Réponse incorrecte!) L'affirmation est correcte : DOM utilise beaucoup de mémoire. Question 2 . Un arbre DOM est constitué d'éléments contenant d'autres éléments. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) L'affirmation est techniquement incorrecte. C'est un arbre de nœuds et les nœuds ne sont pas tous des éléments. Par exemple, une instruction de traitement ou une déclaration de type de document est un nœud. Faux (Réponse correcte!) Effectivement. XML est une structure d'arbre en éléments, mais DOM utilise une structure plus générale d'arbre de nœuds, où les nœuds n'ont pas à être des éléments. En général, par contre, seuls les éléments (et le document) peuvent avoir des descendants. Question 3 . Dans un arbre DOM, que trouve-t-on à la racine? Choisissez la bonne réponse parmi les suivantes. L'élément-racine du document XML. (Réponse incorrecte!) Non. Si c'était le cas, on ne pourrait avoir accès à la déclaration de type de document, par exemple. Il n'y a pas de racine unique. (Réponse incorrecte!) Ce ne serait alors pas un arbre. Le document lui-même contenant, parmi d'autres choses, l'élément-racine du document XML. (Réponse correcte!) Effectivement. Question 4 . Parmi les types de nœuds DOM suivants, quels sont ceux qui ne peuvent pas avoir d'enfants? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». DocumentType (modèle pour une déclaration de type de document) La déclaration de type de document n'a pas d'enfants; elle ne peut pas contenir, par exemple, des éléments. Element (modèle pour un élément) Un élément peut avoir des enfants. Comment (modèle pour un commentaire) Les commentaires ne peuvent pas avoir d'enfants. Document (modèle pour le document lui-même) Le document peut avoir des enfants. Text (modèle pour du texte contenu dans un élément) Du texte ne peut pas avoir d'enfants. Question 5 . Un arbre DOM donne accès à tout le contenu en information pertinente d'un document XML. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse correcte!) DOM est complet : vous pouvez obtenir tout le contenu en information du document XML. Dans un logiciel normal, il ne devrait jamais être nécessaire d'utiliser autre chose que DOM pour extraire l'information contenue dans un document XML. Faux (Réponse incorrecte!) L'affirmation était correcte. Question 6 . Un arbre DOM correspond à un document XML unique. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Il peut y avoir plusieurs documents disposés différemment, mais contenant la même information. Faux (Réponse correcte!) C'est juste. Deux librairies DOM pourraient, avec le même arbre, générer des documents XML différents. "},{"id":25,"href":"/orientee_donnees/legacy/semaine_12/autoevaluation_dom/","title":"Autoévaluation DOM","section":"Semaine 12","content":" Autoévaluation DOM Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Si j'ai une application DOM et que je charge 100 fichiers XML faisant un Mo chacun, je m'attends que mon programme utilise au moins 100 Mo. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse correcte!) Effectivement. Faux (Réponse incorrecte!) L'affirmation est correcte : DOM utilise beaucoup de mémoire. Question 2 . Un arbre DOM est constitué d'éléments contenant d'autres éléments. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) L'affirmation est techniquement incorrecte. C'est un arbre de nœuds et les nœuds ne sont pas tous des éléments. Par exemple, une instruction de traitement ou une déclaration de type de document est un nœud. Faux (Réponse correcte!) Effectivement. XML est une structure d'arbre en éléments, mais DOM utilise une structure plus générale d'arbre de nœuds, où les nœuds n'ont pas à être des éléments. En général, par contre, seuls les éléments (et le document) peuvent avoir des descendants. Question 3 . Dans un arbre DOM, que trouve-t-on à la racine? Choisissez la bonne réponse parmi les suivantes. L'élément-racine du document XML. (Réponse incorrecte!) Non. Si c'était le cas, on ne pourrait avoir accès à la déclaration de type de document, par exemple. Il n'y a pas de racine unique. (Réponse incorrecte!) Ce ne serait alors pas un arbre. Le document lui-même contenant, parmi d'autres choses, l'élément-racine du document XML. (Réponse correcte!) Effectivement. Question 4 . Parmi les types de nœuds DOM suivants, quels sont ceux qui ne peuvent pas avoir d'enfants? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». DocumentType (modèle pour une déclaration de type de document) La déclaration de type de document n'a pas d'enfants; elle ne peut pas contenir, par exemple, des éléments. Element (modèle pour un élément) Un élément peut avoir des enfants. Comment (modèle pour un commentaire) Les commentaires ne peuvent pas avoir d'enfants. Document (modèle pour le document lui-même) Le document peut avoir des enfants. Text (modèle pour du texte contenu dans un élément) Du texte ne peut pas avoir d'enfants. Question 5 . Un arbre DOM donne accès à tout le contenu en information pertinente d'un document XML. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse correcte!) DOM est complet : vous pouvez obtenir tout le contenu en information du document XML. Dans un logiciel normal, il ne devrait jamais être nécessaire d'utiliser autre chose que DOM pour extraire l'information contenue dans un document XML. Faux (Réponse incorrecte!) L'affirmation était correcte. Question 6 . Un arbre DOM correspond à un document XML unique. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Il peut y avoir plusieurs documents disposés différemment, mais contenant la même information. Faux (Réponse correcte!) C'est juste. Deux librairies DOM pourraient, avec le même arbre, générer des documents XML différents. "},{"id":26,"href":"/orientee_donnees/docs/modules/b_module_xml/base/creer_un_fichier_xml/","title":"Créer un fichier XML","section":"Les fondements","content":" Créer un fichier XML Tous les systèmes d’exploitation fournissent un éditeur de texte. Windows a son Bloc-notes, macOS son TextEdit, et Linux propose de nombreux choix (vim, nano, gedit, etc.). Je vous recommande fortement d’utiliser Visual Studio Code : il est gratuit, multiplateforme (Windows, macOS, Linux), très léger, et il offre une excellente coloration syntaxique pour le XML, le HTML, etc. Votre premier fichier XML Comme premier exercice, créez un nouveau fichier et tapez le code suivant : \u0026lt;premier\u0026gt; Ceci est mon premier document XML. \u0026lt;/premier\u0026gt; Enregistrez-le sous le nom premier.xml . Attention sous Windows : le Bloc-notes ajoute automatiquement l’extension .txt . Pour éviter cela : → dans la boîte d’enregistrement, choisissez Tous les fichiers (*.*) dans le menu déroulant « Type » et tapez le nom premier.xml entre guillemets si nécessaire. Vous pouvez aussi choisir l’encodage : sous Windows XP et plus récents, sélectionnez UTF-8 (recommandé) ou ANSI (équivalent à ISO-8859-1). Ouvrez maintenant premier.xml dans votre navigateur (Firefox, Chrome, Edge…). Si tout est correct, vous verrez le texte s’afficher. En cas d’erreur de syntaxe, le navigateur vous indiquera précisément le problème. Un exemple de HTML bien formé (donc aussi du XML valide) \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; Bonjour le monde ! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Exercice facultatif : recopiez ce code dans un fichier nommé test.html , ouvrez-le avec votre navigateur → vous devez voir « Bonjour le monde ! » s’afficher. Vous savez maintenant créer, enregistrer et visualiser des fichiers XML. C’est la première étape essentielle avant de passer à des structures plus complexes ! "},{"id":27,"href":"/orientee_donnees/docs/modules/a_module_json/geojson/","title":"GeoJSON","section":"Module JSON","content":" GeoJSON # Le GeoJSON est un format ouvert conçu pour représenter des données géographiques simples à l\u0026rsquo;aide de la notation JSON (JavaScript Object Notation). Il permet de décrire des objets spatiaux tels que des points, des lignes, des polygones, ainsi que des collections de ces objets, en associant à chacun des propriétés descriptives. Ce format est largement utilisé dans les applications web cartographiques, les SIG (systèmes d\u0026rsquo;information géographique) et les échanges de données géospatiales, car il est lisible par les humains et facilement interprétable par les machines. GeoJSON repose sur la norme RFC 7946 et utilise des coordonnées en longitude et latitude selon le système de référence WGS 84.\nLa structure principale d\u0026rsquo;un fichier GeoJSON commence souvent par un objet de type \u0026ldquo;FeatureCollection\u0026rdquo;, qui contient une liste de \u0026ldquo;features\u0026rdquo;. Chaque \u0026ldquo;feature\u0026rdquo; représente un élément géographique individuel et se compose de trois parties essentielles : un type \u0026ldquo;Feature\u0026rdquo;, un objet \u0026ldquo;properties\u0026rdquo; pour stocker des métadonnées (comme un nom ou une description), et un objet \u0026ldquo;geometry\u0026rdquo; qui définit la forme spatiale. Cette organisation modulaire rend le format flexible et extensible, tout en restant simple à parser dans la plupart des langages de programmation.\nL\u0026rsquo;objet \u0026ldquo;geometry\u0026rdquo; spécifie le type de forme géométrique, par exemple \u0026ldquo;Point\u0026rdquo; pour un point unique, \u0026ldquo;LineString\u0026rdquo; pour une ligne, ou \u0026ldquo;Polygon\u0026rdquo; pour une surface fermée. Dans le cas d\u0026rsquo;un polygone, les coordonnées sont fournies sous forme d\u0026rsquo;un tableau de tableaux de points, où chaque point est une paire [longitude, latitude]. Le premier et le dernier point doivent être identiques pour fermer le polygone, et les coordonnées sont ordonnées dans le sens antihoraire pour respecter les conventions (règle de la main droite). Les polygones peuvent également contenir des \u0026ldquo;trous\u0026rdquo; en ajoutant des anneaux intérieurs.\nPrenons l\u0026rsquo;exemple fourni pour illustrer concrètement ces concepts. L\u0026rsquo;objet FeatureCollection ne contient qu\u0026rsquo;une seule feature, dont les propriétés indiquent le nom \u0026ldquo;Exemple de polygone à Québec\u0026rdquo;. La géométrie est un Polygon dont les coordonnées forment un petit rectangle autour de la ville de Québec : les points vont de la longitude -71.215 à -71.200 et de la latitude 46.810 à 46.820. Ce rectangle fermé représente une zone simplifiée, avec le premier point répété à la fin pour clore la forme. En visualisant ces coordonnées sur une carte, on obtiendrait un polygone rectangulaire couvrant une petite portion du territoire québécois.\n{ \"type\": \"FeatureCollection\", \"features\": [ { \"type\": \"Feature\", \"properties\": { \"name\": \"Exemple de polygone à Québec\" }, \"geometry\": { \"type\": \"Polygon\", \"coordinates\": [[ [-71.215, 46.810], [-71.200, 46.810], [-71.200, 46.820], [-71.215, 46.820], [-71.215, 46.810] ]] } } ] } GeoJSON valide Essayez de remplacer le GeoJSON dans l\u0026rsquo;application par l\u0026rsquo;un des exemples suivants.\nPosition de Paris # { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;: [2.3522, 48.8566] }, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Paris\u0026#34; } } Un trajet de Paris à Lyon puis à Marseille # { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;LineString\u0026#34;, \u0026#34;coordinates\u0026#34;: [ [2.3522, 48.8566], [4.8357, 45.7640], [5.3698, 43.2965] ] }, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Trajet Paris-Lyon-Marseille\u0026#34; } } Zone rectangulaire simple autour de la Tour Eiffel # { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Polygon\u0026#34;, \u0026#34;coordinates\u0026#34;: [ [ [2.28, 48.88], [2.40, 48.88], [2.40, 48.83], [2.28, 48.83], [2.28, 48.88] ] ] }, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Zone autour de la Tour Eiffel\u0026#34; } } Montréal (centre-ville) # { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;: [-73.5673, 45.5017] }, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Centre-ville de Montréal\u0026#34; } } Montréal (Vieux Port) # { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Polygon\u0026#34;, \u0026#34;coordinates\u0026#34;: [ [ [-73.56, 45.50], [-73.54, 45.50], [-73.54, 45.52], [-73.56, 45.52], [-73.56, 45.50] ] ] }, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Vieux-Port de Montréal\u0026#34; } } "},{"id":28,"href":"/orientee_donnees/docs/modules/d_module_html/html_5/","title":"HTML 5","section":"Module HTML, CSS, SVG, MathML","content":" HTML 5 Un document HTML 5 peut prendre la forme d'un document XML ou d'un document HTML. La déclaration doctype n'est utilisée que dans le cas où le document n'est pas un document XML et a été grandement simplifiée : il suffit d'inclure la ligne \u0026lt;!DOCTYPE html\u0026gt; au début du fichier. Voici un exemple de document HTML 5 : \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\"UTF-8\"\u0026gt; \u0026lt;title\u0026gt;Ceci est un exemple\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Voici un paragraphe.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Un document HTML 5 en XML ne nécessite pas de déclaration doctype : \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Ceci est un exemple\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Voici un paragraphe.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; En HTML 5, on n'utilise plus les éléments acronym et plusieurs autres éléments moins utiles (basefont, big, center, s, strike, tt, u, frame, frameset, noframe, applet, isindex, dir). Plusieurs nouveaux éléments ont été ajoutés notamment les éléments section et article. Ces éléments permettent d'organiser le contenu de manière logique. Élément section: permet de regrouper du contenu dans une section contenant peut-être plusieurs paragraphes ou articles ayant un thème commun. Élément article: permet d'indiquer que le contenu est un article. Un article peut disposer d'une entête (header) comprenant un titre. Élément aside: permet d'ajouter une note optionnelle au contenu. Élément footer: permet d'indiquer une section dédiée aux métadonnées du document. Chaque section peut avoir son élément footer. Voici un exemple de HTML 5 valable: \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Ceci est un exemple\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Un article sur le XML\u0026lt;/h1\u0026gt; \u0026lt;section\u0026gt; \u0026lt;article\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h2\u0026gt;La magie du XML\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;J'aime le XML\u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;p\u0026gt;Nous aimons tous le XML...\u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;h3\u0026gt;Une annexe\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Cet article a été écrit par Daniel...\u0026lt;/p\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;aside\u0026gt; En passant, ce n'est pas un vrai article... \u0026lt;/aside\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; On peut facilement créer des indicateurs de progression: 2 sur 10 66% \u0026lt;meter value=\"2\" min=\"0\" max=\"10\"\u0026gt;2 sur 10\u0026lt;/meter\u0026gt;\u0026lt;br /\u0026gt; \u0026lt;meter value=\"0.66\"\u0026gt;66%\u0026lt;/meter\u0026gt; On peut aussi ajouter une figure à un document avec une légende: Photo du professeur \u0026lt;figure\u0026gt; \u0026lt;img src=\"http://lemire.me/fr/images/JPG/profile2011B_152.jpg\" /\u0026gt; \u0026lt;legend\u0026gt;Photo du professeur\u0026lt;/legend\u0026gt; \u0026lt;/figure\u0026gt; On peut aussi créer rapidement des formulaires en ligne: Inscription au cours de XML Information personnelle Nom Date de naissance Courriel Site personnel Téléphone Nombre de cours suivis précédemment Aptitude en informatique 0 Adresse Pays S'inscrire \u0026lt;form id=\u0026#34;inscription\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Inscription au cours de XML\u0026lt;/h1\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;Information personnelle\u0026lt;/legend\u0026gt; \u0026lt;label\u0026gt;Nom \u0026lt;input id=\u0026#34;nom\u0026#34; name=\u0026#34;nom\u0026#34; type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Votre nom\u0026#34; required autofocus\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Date de naissance \u0026lt;input id=\u0026#34;courriel\u0026#34; name=\u0026#34;ddn\u0026#34; type=\u0026#34;date\u0026#34; required\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Courriel \u0026lt;input id=\u0026#34;courriel\u0026#34; name=\u0026#34;courriel\u0026#34; type=\u0026#34;email\u0026#34; placeholder=\u0026#34;lemire@jo.com\u0026#34; required\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Site personnel \u0026lt;input id=\u0026#34;url\u0026#34; name=\u0026#34;url\u0026#34; type=\u0026#34;url\u0026#34; placeholder=\u0026#34;http://monsite.com\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Téléphone \u0026lt;input id=\u0026#34;telephone\u0026#34; name=\u0026#34;telephone\u0026#34; type=\u0026#34;tel\u0026#34; placeholder=\u0026#34;Par ex. 450 111-4444\u0026#34; required\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Nombre de cours suivis précédemment \u0026lt;input id=\u0026#34;cours\u0026#34; name=\u0026#34;cours\u0026#34; type=\u0026#34;number\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;50\u0026#34; step=\u0026#34;0.5\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Aptitude en informatique \u0026lt;input id=\u0026#34;aptitude\u0026#34; name=\u0026#34;aptitude\u0026#34; type=\u0026#34;range\u0026#34; min=\u0026#34;1\u0026#34; max=\u0026#34;100\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;output name=\u0026#34;output\u0026#34; onforminput=\u0026#34;value=a.value\u0026#34;\u0026gt;0\u0026lt;/output\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Adresse \u0026lt;textarea id=\u0026#34;adresse\u0026#34; name=\u0026#34;address\u0026#34; rows=5 required\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;label\u0026gt;Pays \u0026lt;input id=\u0026#34;pays\u0026#34; name=\u0026#34;pays\u0026#34; list=\u0026#34;nomsdepays\u0026#34; type=\u0026#34;text\u0026#34; required\u0026gt; \u0026lt;datalist id=\u0026#34;nomsdepays\u0026#34;\u0026gt; \u0026lt;option label=\u0026#34;États-Unis\u0026#34; value=\u0026#34;us\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;option label=\u0026#34;Canada\u0026#34; value=\u0026#34;ca\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;option label=\u0026#34;France\u0026#34; value=\u0026#34;fr\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;/datalist\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;button type=submit\u0026gt;S\u0026#39;inscrire\u0026lt;/button\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; Les éléments canvas, video et audio sont aussi ajoutés : le HTML devient pleinement multimédia. L\u0026rsquo;exemple suivant illustre comment on peut combiner HTML et JavaScript pour dessiner.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Exemple simple Canvas\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; canvas { border: 2px solid #333; background: #f0f0f0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Exemple basique de Canvas\u0026lt;/h2\u0026gt; \u0026lt;canvas id=\u0026#34;monCanvas\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script\u0026gt; // 1. On récupère l\u0026#39;élément canvas const canvas = document.getElementById(\u0026#39;monCanvas\u0026#39;); const ctx = canvas.getContext(\u0026#39;2d\u0026#39;); // contexte 2d (le plus courant) // 2. Carré rouge ctx.fillStyle = \u0026#39;red\u0026#39;; ctx.fillRect(50, 50, 100, 100); // x, y, largeur, hauteur // 3. Cercle bleu ctx.fillStyle = \u0026#39;blue\u0026#39;; ctx.beginPath(); ctx.arc(280, 100, 50, 0, Math.PI * 2); // centre x, centre y, rayon, angle départ, angle fin ctx.fill(); // 4. Ligne verte ctx.strokeStyle = \u0026#39;green\u0026#39;; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(50, 200); // point de départ ctx.lineTo(350, 200); // point d\u0026#39;arrivée ctx.stroke(); // 5. Texte ctx.font = \u0026#39;30px Arial\u0026#39;; ctx.fillStyle = \u0026#39;black\u0026#39;; ctx.fillText(\u0026#39;Hello Canvas !\u0026#39;, 90, 260); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Pour en savoir plus, consulter le guide du HTML 5 chez Mozilla . "},{"id":29,"href":"/orientee_donnees/docs/modules/c_module_xslt/xquery/laboratoire_xquery_avec_python_optionnel/","title":"Laboratoire XQuery avec Python (optionnel)","section":"XQuery","content":" Laboratoire XQuery avec Python (optionnel) Rendez vous sur le site xquerypy qui comprend une petite application Python capable de traiter du XQuery et du XML. Suivez les consignes. "},{"id":30,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/le_fichier_pomxml_en_java/","title":"Le fichier pom.xml en Java","section":"Exemples","content":" Le fichier pom.xml en Java # Le fichier pom.xml (Project Object Model) est le cœur de tout projet Maven. C’est un fichier de configuration écrit en XML qui décrit complètement le projet : ses coordonnées, ses dépendances, les plugins utilisés, la version de Java ciblée, les profils d’exécution, etc. Il est utilisé par Maven et par la plupart des outils de build modernes (Gradle peut aussi le lire dans certains cas) ainsi que par les IDE comme IntelliJ IDEA ou Eclipse.\nParmi les informations principales qu’il contient, on trouve la version du projet, le groupId et l’artifactId qui forment son identité unique, le packaging (jar, war, pom…), la liste des dépendances gérées avec leurs versions, les repositories additionnels, les plugins de compilation, de test, d’empaquetage, etc.\nStructure XML # La racine du fichier est toujours l’élément \u0026lt;project\u0026gt; avec les namespaces Maven :\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; ... \u0026lt;/project\u0026gt; Les sections les plus courantes à l’intérieur sont : \u0026lt;groupId\u0026gt;, \u0026lt;artifactId\u0026gt;, \u0026lt;version\u0026gt;, \u0026lt;packaging\u0026gt; : les coordonnées Maven du projet.\n\u0026lt;properties\u0026gt; : permet de définir des variables réutilisables (version de Java, version des plugins, etc.).\n\u0026lt;dependencies\u0026gt; : liste toutes les bibliothèques nécessaires.\n\u0026lt;dependencyManagement\u0026gt; : centralise la gestion des versions (souvent utilisé dans un pom parent).\n\u0026lt;build\u0026gt; et \u0026lt;plugins\u0026gt; : configuration du processus de compilation et des plugins Maven.\nExemple de fichier pom.xml # Voici un exemple simple d’un projet Java console (application Spring Boot minimaliste) utilisant Java 17 et Maven :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo-app\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;Demo App\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Application de démonstration\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.3.0\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.13.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Cet exemple montre comment le XML organise toutes les informations nécessaires à Maven : coordonnées du projet, propriétés réutilisables, dépendances avec gestion de version centralisée, et configuration des plugins de compilation et d’exécution. Vous pouvez bien entendu l’étendre avec des profils, des modules enfants, des repositories personnalisés, etc.\n"},{"id":31,"href":"/orientee_donnees/docs/modules/c_module_xslt/","title":"Module XPath, XSLT, XQuery","section":"Modules","content":" Module XPath, XSLT, XQuery # Ce module se concentre sur les technologies de transformation et d\u0026rsquo;interrogation des documents XML : XPath pour la navigation et la sélection d\u0026rsquo;éléments, XSLT pour la transformation de XML vers d\u0026rsquo;autres formats (HTML, XML, texte), et XQuery pour l\u0026rsquo;interrogation et la construction de documents XML. Il inclut des laboratoires pratiques, des auto-évaluations, et explore des concepts avancés comme les axes, les boucles, les variables, les espaces de noms, et les versions 2.0/3.0. Des exemples d\u0026rsquo;intégration avec Java et Python sont fournis.\nUn problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l\u0026rsquo;amélioration du cours.\n"},{"id":32,"href":"/orientee_donnees/legacy/semaine_15/solutions_a_lexamen_preparatoire/","title":"Solutions à l’examen préparatoire","section":"Semaine 15","content":" Corrigé des questions préparatoires à l\u0026rsquo;examen # Question 1 # Écrivez un programme en Java qui utilise l’API DOM et modifie un fichier XML de manière à ce que le préfixe « foo » soit ajouté aux noms de tous les éléments.\nLe fichier\n\u0026lt;element\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/element\u0026gt; deviendra donc\n\u0026lt;fooelement\u0026gt;\u0026lt;fooa\u0026gt;\u0026lt;/fooa\u0026gt;\u0026lt;/fooelement\u0026gt;. Vous pouvez supposer que le document ne contient que des éléments, sans attributs, sans espaces de noms.\nRéponse # import org.w3c.dom.*; import java.io.*; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.*; import javax.xml.transform.stream.*; public class Question1 { /** * Cette méthode parcours récurssivement l\u0026#39;arbre DOM et ajoute * le préfixe à chauque élément noeud * @param node * @param i * @param prefix */ public static void traite(Node node, int i, String prefix) { if (node.getNodeType()==node.ELEMENT_NODE){ System.out.println(\u0026#34;Nom: \u0026#34;+ node.getNodeName()); Document doc = node.getOwnerDocument(); doc.renameNode(node, null, prefix+node.getNodeName()); System.out.println(\u0026#34;Nom après l\u0026#39;jout du prefix : \u0026#34;+ node.getNodeName()); } NodeList nl = node.getChildNodes(); if(nl != null) { for (int k = 0; k \u0026lt; nl.getLength(); ++k) { traite(nl.item(k),i+2,prefix); } } } public static void main(String[] args) throws Exception { if (args.length \u0026gt; 0 ){ String prefix=\u0026#34;foo\u0026#34;; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); traite(doc,0,prefix); TransformerFactory tfact = TransformerFactory.newInstance(); Transformer transformer = tfact.newTransformer(); transformer.setOutputProperty(\u0026#34;encoding\u0026#34;, \u0026#34;ISO-8859-1\u0026#34;); DOMSource source = new DOMSource(doc); FileWriter fw = new FileWriter(\u0026#34;foo.xml\u0026#34;); StreamResult result = new StreamResult(fw); transformer.transform(source, result); }else{ System.out.println(\u0026#34;Usage : java Question1 document.xml\u0026#34;); System.exit(0); } } } Question 2 # Utilisez XSLT pour faire la transformation. (Un indice : pensez à xsl:element.)\nRéponse # \u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:redirect=\u0026#34;org.apache.xalan.xslt.extensions.Redirect\u0026#34; extension-element-prefixes=\u0026#34;redirect\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:element name=\u0026#34;{concat(\u0026#39;foo\u0026#39;,name(.))}\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt; \u0026lt;/xsl:element\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Question 3 # Dessinez l\u0026rsquo;arbre DOM du fichier XML suivant.\n\u0026lt;a xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt;\u0026lt;b type=\u0026#34;x\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; Pour chaque élément et attribut, donnez son nom et son espace de noms. (Un indice : attention à l\u0026rsquo;espace de noms de l\u0026rsquo;attribut.)\nRéponse # L\u0026rsquo;arbre DOM peut être représenté comme suit :\n/ | a (namespace: http://www.w3.org/1999/xhtml) | b (namespace: http://www.w3.org/1999/xhtml) | type = \u0026#34;x\u0026#34; (pas d\u0026#39;espace de noms) Question 4 # Donnez une DTD équivalente au fichier Relax NG suivant.\nelement p { (element c {text}, element d(text)*)? }\nRéponse # \u0026lt;!ELEMENT p (c, d*)? \u0026gt; \u0026lt;!ELEMENT c (#PCDATA) \u0026gt; \u0026lt;!ELEMENT d (#PCDATA) \u0026gt; Question 5 # Écrivez en RDF/XML les triplets suivants.\nsujet : http://www.com.com/jeanne\nprédicat : http://www.w3.org/1999/02/22-rdf-syntax-ns#type\nobjet : http://www.com.com/maman\nsujet : http://www.com.com/maman\nprédicat : http://action.com/etre\nobjet : http://www.com.com/femme\nsujet : http://www.com.com/enfant\nprédicat : http://action.com/avoir\nobjet : http://www.com.com/maman\nRéponse # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns=\u0026#34;http://action.com/\u0026#34; \u0026gt; \u0026lt;rdf:Description rdf:about=\u0026#34;http://www.com.com/jeanne\u0026#34;\u0026gt; \u0026lt;rdf:type rdf:resource=\u0026#34;http://www.com.com/maman\u0026#34; /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;rdf:Description rdf:about=\u0026#34;http://www.com.com/maman\u0026#34;\u0026gt; \u0026lt;etre rdf:resource=\u0026#34;http://www.com.com/femme\u0026#34; /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;rdf:Description rdf:about=\u0026#34;http://www.com.com/enfant\u0026#34;\u0026gt; \u0026lt;avoir rdf:resource=\u0026#34;http://www.com.com/maman\u0026#34; /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Question 6 # Définissez et expliquez les différences entre XPath, XLink, XQuery et XSLT.\nRéponse # XPath est un langage W3C qui permet d’extraire des données à partir d’un document XML. Il est utilisé pour adresser les éléments dans un document XML à l’aide des expressions de chemins. Le résultat d\u0026rsquo;une expression XPath peut être : un ensemble d’éléments ou de nœuds, une chaîne de caractères, un nombre ou un booléen.\nXLink est une spécification du W3C (appelé parfois XLL pour XLink Language). Il permet de créer des liens entre des fichiers XML ou des fragments de fichiers XML (grâce à XPointer). Contrairement aux liens entre fichiers HTML, XLink permet de créer des liens liant plus de deux fichiers (liens plus sophistiqués).\nXQuery est un langage de W3C à la manière de SQL. Il sert à extraire des données à partir de bases de données XML. Il permet entre autres de joindre, d’extraire et d’interroger des documents XML.\nXSLT est un langage recommandé par W3C pour transformer des documents XML en d’autres documents XML, HTML, etc.\nLa différence principale entre ces langages réside dans leur rôle. XSLT est conçu comme une feuille de style qui transforme des documents XML afin qu’ils soient compréhensibles sur un écran, le web, le papier, etc. XQuery, quant à lui, interroge et manipule une collection de documents XML comme SQL. XSLT et XQuery incluent XPath pour accéder aux composants des documents XML. XPath sert donc comme un support pour XSLT et XQuery. Finalement, XLink ne permet ni d’extraire ou de transformer des données XML, mais plutôt d\u0026rsquo;insérer des liaisons entre ces données.\nQuestion 7 # Que signifie l’expression Xpath suivante?\n//table[@border=\u0026ldquo;0\u0026rdquo; and @cellspacing=\u0026ldquo;0\u0026rdquo;] | //table[@border=\u0026ldquo;1\u0026rdquo; and @cellspacing=\u0026ldquo;1\u0026rdquo;]\nRéponse # L’union des éléments table dont la valeur de l’attribut border est 0 et la valeur de l’attribut cellspacing est 0 ou la valeur de l’attribut border est 1 et la valeur de l’attribut cellspacing est 1.\nQuestion 8 # Que retourne l’expression XPath suivante : //table[@border]\nRéponse # Cette expression retourne les éléments table (descendants du nœud contexte) qui ont un attribut border.\nQuestion 9 # Que retourne l’expression XPath suivante : //table[@border]/@cellspacing\nRéponse # Cette expression retourne les valeurs de l’attribut cellspacing des éléments table (descendants du nœud contexte) qui ont un attribut border.\nQuestion 10 # Que retourne l’expression XPath suivante : //table[@border]//[@style]\nRéponse # Cette expression retourne les éléments qui ont un attribut style et qui sont à leur tour les petits-fils des éléments table (descendants du nœud contexte) ayant un attribut border.\nQuestion 11 # Que retourne l’expression XPath suivante : //table[@border]//[not(@style)]\nRéponse # Cette expression retourne les éléments qui n’ont pas un attribut style et qui sont, à leur tour, les fils des éléments table (descendants du nœud contexte) ayant un attribut border.\nQuestion 12 # Écrivez un programme Java qui applique l’expression XPath de la question précédente à un fichier chargé à partir du disque.\nRéponse # import javax.xml.xpath.*; import javax.xml.parsers.*; import org.w3c.dom.*; public class Question12 { public static void main(String[] args) throws Exception { if (args.length \u0026gt; 0 ){ try{ DocumentBuilderFactory dbfact = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dbfact.newDocumentBuilder(); Document document = builder.parse(args[0]); XPathFactory fact = XPathFactory.newInstance(); XPath xpath = fact.newXPath(); String results = xpath.evaluate(\u0026#34;//table[@border]/*/*[not(@style)]\u0026#34;, document); System.out.println(results); } catch (Exception e){ e.printStackTrace(); } } else{ System.out.println(\u0026#34;Usage : java Question12 document.xml\u0026#34;); System.exit(0); } } } Exemple de document.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;document\u0026gt; \u0026lt;table border=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;color:red;\u0026#34;\u0026gt;cet element ne doit pas etre retourne 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;cet element doit etre retourne 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;cet element doit etre retourne 2 ?\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td style=\u0026#34;color:red;\u0026#34;\u0026gt;cet element ne doit pas etre retourne 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;cet element ne doit pas etre retourne 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;cet element ne doit pas etre retourne 2 ?\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/document\u0026gt; L’exécution de la commande java Question12 document.xml retourne\ncet element doit etre retourne 1\nQuestion 13 # Expliquez ce que fera le fichier XSLT suivant.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns:dc=\u0026#34;http://purl.org/dc/elements/1.1/\u0026#34; \u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; - \u0026lt;xsl:for-each select=\u0026#34;@type\u0026#34; \u0026gt; \u0026lt;li\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt;\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Réponse # Le fichier XSLT met les valeurs de l’attribut type entre et Question 14 # Écrivez une expression XPath qui compte le nombre d\u0026rsquo;éléments ayant été déclarés comme contenant du texte en langue française.\nRéponse # Count(//*[xml:lang=’fr’]) (je n’ai pas encore vérifier ma réponse)\nQuestion 15 # Nommez au moins trois modèles de programmation XML utilisés en Java.\nRéponse # Voici quatre modèles avec leur notice explicative (Il suffit d’en citer trois).\nTraitement du XML comme du texte. Un fichier XML est traité comme un fichier texte. Les expressions régulières (voir le paquetage « java.util.regex » en Java) peuvent être utilisées pour parcourir le texte.\nTraitement événementiel. Le traitement événementiel est une approche très simple pour traiter un document XML, mais qui peut être difficile pour le programmeur. En fait, une API (par exemple, API SAX) est utilisée pour lire en séquence le document XML. Chaque fois qu\u0026rsquo;une nouvelle balise ou tout autre élément significatif (instruction XML, contenu XML, etc.) est rencontré, un « événement » est généré.\nTraitement avec itérateurs. Au lieu d’attendre passivement de recevoir des événements pour les traiter, le flux XML est traité itérativement dans une simple boucle. La Streaming API for XML (StAX) permet de réaliser ce type de traitement.\nTraitement avec modèle en arbre. Un document XML peut être vu comme un arbre avec un élément-racine contenant lui-même d’autres éléments qui, à leur tour, contiennent des éléments, et ainsi de suite. Ainsi, en utilisant le traitement événementiel par exemple, une librairie peut d\u0026rsquo;abord lire le document XML et créer un modèle en arbre. Le modèle en arbre XML le plus connu et qui sert de référence est le Document Object Model (DOM).\nQuestion 16 # Définissez AJAX et expliquez pourquoi il s\u0026rsquo;agit d\u0026rsquo;une technique importante en développement web. Quel est le lien entre AJAX et DOM?\nRéponse # AJAX, ou Asynchronous JavaScript And XML (« XML et Javascript asynchrones »), est un acronyme désignant une méthode informatique de développement d\u0026rsquo;applications web. Dans une application web classique, une requête envoyée à un serveur HTTP agit en fonction de l\u0026rsquo;action et des données reçues et renvoie une nouvelle page. Ce type de fonctionnement recharge systématiquement la totalité de la page même si qu’une partie de cette page est requise. Les applications utilisant les techniques AJAX, quant à elles, peuvent envoyer des requêtes au serveur HTTP pour récupérer uniquement les données nécessaires en utilisant la requête HTTP XMLHttpRequest, et en utilisant la puissance des feuilles de style (CSS) ainsi que le langage Javascript côté client pour interpréter la réponse du serveur HTTP. Les applications sont alors plus réactives.\nEn AJAX, on utilise des scripts JavaScript pour charger des informations à partir d’un serveur donné. Les implémentations JavaScript supportent bien l\u0026rsquo;API DOM en général. JavaScript fait donc le lien entre AJAX et l’API DOM.\nQuestion 17 # Selon le fichier CSS suivant, quelle sera la couleur d’un élément p?\n{color: black;}\np {color:olive;}\nbody p {color:blue;}\nbody \u0026gt; p {color: red; }\nbody \u0026gt; p {color: green; } {color: yellow;} Réponse # Emplacement de p Couleur de p Explication p contenu immédiatement dans body green Les deux règles : body \u0026gt; p {color: red; } et body \u0026gt; p {color: green; } s’appliquent mais c’est la dernière qui prévaut. p contenu dans body mais pas immédiatement blue La règle body p {color:blue;} s’applique. Autres emplacements olive Les trios règles : * {color: black;}, p {color:olive;} et * {color: yellow;} s’appliquent, mais c’est la plus spécifique qui prévaut. Question 18 # Selon le modèle de boîte CSS du W3C, quelle est la hauteur (height) minimale d\u0026rsquo;un objet ayant les propriétés CSS « padding: 10px; » et « margin: 12px; »?\nRéponse # La hauteur minimale est de zéro.\nQuestion 19 # Donnez un exemple de document XML contenant des attributs ID et des attributs IDREF.\nRéponse # Deux solutions.\nxml:idref=\u0026lsquo;identificateur\u0026rsquo; permet de faire référence à une clef. \u0026lt;section xml:id=\u0026#39;intro\u0026#39;\u0026gt; \u0026lt;titre\u0026gt;introduction à XML\u0026lt;/titre\u0026gt; ... \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;p\u0026gt; Après la section \u0026lt;xref xml:idref=\u0026#39;intro\u0026#39;\u0026gt;d\u0026#39;introduction\u0026lt;/xref\u0026gt; nous allons passer ... \u0026lt;/section\u0026gt; Soit le fichier DTD « exemple.dtd » : \u0026lt;!ELEMENT x (a+ , b+, c+,) \u0026gt; \u0026lt;!ELEMENT a (#PCDATA)\u0026gt; \u0026lt;!ELEMENT b (#PCDATA)\u0026gt; \u0026lt;!ELEMENT c (#PCDATA)\u0026gt; \u0026lt;!ATTLIST a mark ID #REQUIRED\u0026gt; \u0026lt;!ATTLIST b id ID #REQUIRED\u0026gt; \u0026lt;!ATTLIST c ref IDREF #REQUIRED\u0026gt; Ci-dessous un exemple d’un fichier XML avec ID et IDREF.\n\u0026lt;!DOCTYPE x SYSTEM \u0026#34;exemple.dtd\u0026#34;\u0026gt; \u0026lt;x\u0026gt; \u0026lt;a mark=\u0026#34;a1\u0026#34;/\u0026gt; \u0026lt;a mark=\u0026#34;a2\u0026#34;/\u0026gt; \u0026lt;a mark=\u0026#34;a3\u0026#34;/\u0026gt; \u0026lt;b id=\u0026#34;b001\u0026#34; /\u0026gt; \u0026lt;c ref=\u0026#34;a3\u0026#34; /\u0026gt; \u0026lt;/x\u0026gt; Question 20 # Selon le fragment de DTD suivant, qu\u0026rsquo;est-ce qu\u0026rsquo;il est permis de mettre dans un élément p? Comment nomme-t-on le concept utilisé ici?\n\u0026lt;!ENTITY % fontstyle \u0026#34;big | small\u0026#34; \u0026gt; \u0026lt;!ENTITY % phrase \u0026#34;em | cite\u0026#34; \u0026gt; \u0026lt;!ENTITY % in \u0026#34;%fontstyle; | %phrase;\u0026#34; \u0026gt; \u0026lt;!ENTITY % In \u0026#34;(#PCDATA |%in;)*\u0026#34; \u0026gt; \u0026lt;!ELEMENT p %In;\u0026gt; Réponse # \u0026lt;!ELEMENT p (#PCDATA | big | small | em | cite )*\u0026gt; Question 21 # Expliquez les expressions XPath suivantes et décrivez le résultat selon la théorie des ensembles (union, intersection et complément).\n//[@s=\u0026ldquo;1\u0026rdquo;]|//[@t=\u0026ldquo;1\u0026rdquo;]\n//[@s=\u0026ldquo;1\u0026rdquo;][count(.|//[@t=\u0026ldquo;1\u0026rdquo;])=count(//[@t=\u0026ldquo;1\u0026rdquo;])]\n//[@s=\u0026ldquo;1\u0026rdquo;][count(.|//[@t=\u0026ldquo;1\u0026rdquo;])!=count(//[@t=\u0026ldquo;1\u0026rdquo;])]\nRéponse # Expression Valeur retournée //[@s=\u0026ldquo;1\u0026rdquo;]| //[@t=\u0026ldquo;1\u0026rdquo;] L’union des éléments dont la valeur des attributs s et t est égale à 1. //[@s=\u0026ldquo;1\u0026rdquo;][count(.| //[@t=\u0026ldquo;1\u0026rdquo;])=count(//[@t=\u0026ldquo;1\u0026rdquo;])] L’intersection des éléments dont la valeur de s et de t est égale à 1. //[@s=\u0026ldquo;1\u0026rdquo;][count(.| //[@t=\u0026ldquo;1\u0026rdquo;])!=count(//[@t=\u0026ldquo;1\u0026rdquo;])] Le complément des éléments dont la valeur de s est égale à 1 et la valeur de t est différente de 1. Question 22 # Comment passe-t-on des paramètres à une feuille de style XSLT à partir d\u0026rsquo;un document XML?\nRéponse # On peut passer un paramètre à une feuille de style XSLT à l’aide de « xslt-param ». Ci-dessous, un exemple de fichier XML (tiré du cours) dans lequel on passe deux paramètres.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;?xslt-param name=\u0026#34;couleur\u0026#34; value=\u0026#34;blue\u0026#34;?\u0026gt; \u0026lt;?xslt-param name=\u0026#34;taille\u0026#34; select=\u0026#34;2\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;xslt.xml\u0026#34; type=\u0026#34;application/xml\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; (Optionnel)\nLa récupération des paramètres se fait à l’aide de « xsl:param ». Ci-dessous, un exemple d’un fichier XSLT récupérant ces deux paramètres (l’attribut select permet d’associer des valeurs par défaut).\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:param name=\u0026#34;couleur\u0026#34; select=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;xsl:param name=\u0026#34;taille\u0026#34; select=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p style=\u0026#34;color:{$couleur}; font-size:{$taille}em\u0026#34;\u0026gt;Ceci est une facture pour \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt; de \u0026lt;xsl:value-of select=\u0026#34;montant\u0026#34; /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\u0026#34;raison\u0026#34; /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Question 23 # Quelles sont les principales différences entre JSON et XML en termes de structure et d\u0026rsquo;utilisation ?\nRéponse # JSON (JavaScript Object Notation) et XML sont tous deux des formats de données structurées, mais ils diffèrent dans plusieurs aspects :\nStructure : JSON utilise des objets ({}), des tableaux ([]), et des paires clé-valeur. XML utilise des éléments avec des balises ouvrantes et fermantes, des attributs, et peut avoir une structure plus complexe avec espaces de noms.\nLisibilité : JSON est généralement plus concis et plus facile à lire pour les humains que XML, surtout pour les données simples.\nTypes de données : JSON supporte nativement les chaînes, nombres, booléens, null, objets et tableaux. XML traite tout comme du texte, nécessitant parfois des schémas pour typer les données.\nUtilisation : JSON est largement utilisé dans les APIs web et le développement JavaScript. XML est plus utilisé pour les documents complexes, les configurations, et les échanges de données entre systèmes hétérogènes.\nQuestion 24 # Écrivez un exemple de code JavaScript qui parse une chaîne JSON et accède à une propriété imbriquée.\nRéponse # const jsonString = \u0026#39;{\u0026#34;user\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;details\u0026#34;: {\u0026#34;age\u0026#34;: 30, \u0026#34;city\u0026#34;: \u0026#34;Paris\u0026#34;}}}\u0026#39;; const data = JSON.parse(jsonString); console.log(data.user.details.city); // Affiche \u0026#34;Paris\u0026#34; Question 25 # Qu\u0026rsquo;est-ce qu\u0026rsquo;un schéma JSON et pourquoi est-il utile ?\nRéponse # Un schéma JSON est une spécification qui définit la structure, les types de données, et les contraintes d\u0026rsquo;un document JSON. Il est basé sur le standard JSON Schema.\nIl est utile pour :\nValider que les données JSON respectent une structure attendue\nDocumenter la structure des données\nGénérer automatiquement du code ou des interfaces\nAméliorer l\u0026rsquo;interopérabilité entre systèmes\nQuestion 26 # Expliquez la syntaxe de base de YAML et donnez un exemple simple.\nRéponse # YAML (YAML Ain\u0026rsquo;t Markup Language) utilise l\u0026rsquo;indentation pour définir la structure, contrairement aux balises de XML.\nSyntaxe de base :\nObjets : paires clé-valeur séparées par :\nTableaux : éléments précédés de -\nCommentaires : #\nExemple :\npersonne: nom: Alice age: 30 hobbies: - lecture - vélo Question 27 # Comment YAML se compare-t-il à XML pour la configuration d\u0026rsquo;applications ?\nRéponse # YAML est souvent préféré à XML pour la configuration car :\nPlus lisible et concis\nMoins verbeux (pas de balises fermantes)\nSupporte nativement les types de données (chaînes, nombres, booléens)\nMeilleure gestion des structures imbriquées avec l\u0026rsquo;indentation\nCependant, XML offre une validation plus stricte via les schémas et est plus adapté pour les données très structurées ou les échanges complexes.\nQuestion 28 # Écrivez un exemple de document YAML qui représente une liste d\u0026rsquo;objets avec des propriétés imbriquées.\nRéponse # utilisateurs: - nom: Alice details: age: 30 ville: Paris - nom: Bob details: age: 25 ville: Lyon "},{"id":33,"href":"/orientee_donnees/legacy/semaine_6/utilisation_de_sigil_et_de_thorium/","title":"Utilisation de Sigil et de Thorium","section":"Semaine 6","content":" Utilisation de Sigil et de Thorium Sigil Créer un fichier EPUB manuellement est un peu lourd. Ce n’est pas une opération particulièrement difficile, mais il faut créer quelques fichiers et les placer au bon endroit. Il est facile de faire des erreurs. Au lieu de cela, nous allons utiliser un éditeur dédié nommé Sigil. Vous devez donc commencer par installer Sigil sur votre ordinateur : https://github.com/user-none/Sigil/releases Il suffit de télécharger et d’exécuter le fichier setup.exe correspondant à votre version de Windows. Choisissez une version \"release\" et non une version beta ou \"pre-release\". Pour nous amuser un peu, nous allons créer un livre électronique digne de ce nom. Commencer par écrire un paragraph que vous ajouterez au fichier XHTML déjà ouvert. Quelque chose comme ceci : \u0026lt;p\u0026gt;Mon premier livre.\u0026lt;/p\u0026gt; Trouvez le fichier content.opf qui se trouve à la racine de tout EPUB et modifiez-le afin de donner un titre et un auteur à votre livre. Quelque chose comme ceci au sein de l’élément metadata fera l’affaire : \u0026lt;dc:title\u0026gt;Mon premier livre\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator opf:role=\"aut\"\u0026gt;Daniel Lemire\u0026lt;/dc:creator\u0026gt; \u0026lt;dc:language\u0026gt;fr-CA\u0026lt;/dc:language\u0026gt; Notez bien l’espace de noms utilisé (\" http://purl.org/dc/elements/1.1/ \"). Il s’agit de l’espace de noms de Dublin Core. Nous y reviendrons plus tard dans le cours. Un lien vers un document HTML se trouve sans doute déjà dans le fichier content.opf. Vous trouverez ailleurs dans l’interface de Sigil un éditeur vous permettant de modifier le fichier HTML en question. Vous pourriez ainsi rédiger tout un livre dans un seul fichier HTML. Mais il peut être plus pratique de diviser votre livre en plusieurs fichiers HTML. En cliquant sur le bouton droit de la souris sur le dossier Text, ajoutez un nouveau fichier HTML (par exemple Section0002.xhtml). Vous pouvez remplir ce nouveau fichier de texte. Notez qu’il est permis d’utiliser des hyperliens offrant la possibilité au lecteur de passer directement d’un fichier à l’autre. Consultez à nouveau le fichier content.opf. Vous trouverez alors des liens vers vos deux fichiers HTML. Vous devriez voir quelque chose comme ceci : \u0026lt;itemref idref=\"Section0001.xhtml\" /\u0026gt; \u0026lt;itemref idref=\"Section0002.xhtml\" /\u0026gt; C’est de cette manière qu’une liseuse sait quels fichiers HTML offrir au lecteur. Enregistrez ensuite le résultat sur votre disque sous la forme d’un fichier avec l’extension .epub. Thorium Il n’est pas très drôle de créer un livre sans pouvoir le consulter. Heureusement, il existe une application qui s’installe partout et qui fait bien l’affaire : Thorium . Prenez la peine de l’installer et de la lancer. Vous pouvez ensuite charger un livre. Vérifiez que le livre correspond bien à ce que vous avez créé. Si ça ne fonctionne pas comme vous le pensez, pour une raison ou une autre, consultez de nouveau le document dans Sigil. Est-ce que vous voyez bien le contenu que vous y avez mis ? Si ça ne va toujours pas, vérifiez que vous utilisez bien une version de Sigil de qualité « release ». Essayez une autre version de Sigil au besoin. Vous pouvez aussi expérimenter avec d’autres lecteurs de EPUB. Dans tous les cas, nous vous invitons bien sûr à expérimenter avec d’autres lecteurs de livres électroniques. Si vous avez une tablette, vous trouverez sans doute une application pertinente. Votre PC a peut-être déjà des logiciels compatibles avec la norme EPUB. Le projet Gutenberg Le projet Gutenberg est une collection de livres électroniques gratuits, disponibles au format EPUB. Commencez par télécharger la version EPUB d’Eugénie Grandet (de Balzac). Ouvrez-le dans Sigil. Vous constaterez que le texte est composé de trois fichiers XHTML indiqué par le fichier content.opf : \u0026lt;item href=\"Styles/pgepub.css\" id=\"item1\" media-type=\"text/css\" /\u0026gt; \u0026lt;item href=\"Text/www.gutenberg.org%40files%4011049%4011049-8-0.html\" id=\"id00000\" media-type=\"application/xhtml+xml\" /\u0026gt; \u0026lt;item href=\"Text/www.gutenberg.org%40files%4011049%4011049-8-1.html\" id=\"id00639\" media-type=\"application/xhtml+xml\" /\u0026gt; \u0026lt;item href=\"Text/www.gutenberg.org%40files%4011049%4011049-8-2.html\" id=\"id01301\" media-type=\"application/xhtml+xml\" /\u0026gt; Si le coeur vous en dit, vous pouvez modifier les mots de Balzac, enregistrer le nouveau document EPUB et le lire en famille. Notez que l’on peut spécifier une feuille de style CSS associées avec les différents fichiers HTML. Nous reviendrons sur ce point plus tard dans le cours. "},{"id":34,"href":"/orientee_donnees/docs/modules/b_module_xml/valid/validation_de_documents_xml/","title":"Validation de documents XML","section":"Validation","content":" Validation de documents XML # La validation des documents XML est un processus essentiel pour s\u0026rsquo;assurer que les données respectent une structure définie, permettant ainsi d\u0026rsquo;éviter les erreurs et de garantir l\u0026rsquo;intégrité des informations échangées.\nActivité de validation # On peut facilement vérifier si un document XML est « bien formé ». Il suffit de lui donner l’extension « .xml » (ou « .xhtml ») et de l’ouvrir dans un navigateur, par exemple.\nCependant, il arrive qu’on veuille vérifier que le document est non seulement bien formé, mais aussi valable par rapport à des documents DTD locaux. Apprenons donc à valider des documents XML, en exécutant les directives qui suivent, car cela vous sera très utile dans vos travaux en XML.\nLa procédure que nous proposons suppose que vous connaissez bien les éléments de base d’un système d’exploitation, comme l’utilisation de la ligne de commande et l’exécution de programmes. Nous ne donnons la procédure que pour Windows, mais elle est très similaire sous macOS ou Linux.\nDemonstration en ligne # Vous pouvez valider le fichier XML en ligne, en appuyant sur le bouton exécuter.\nValidateur.javaimport org.xml.sax.*; import javax.xml.parsers.*; import java.io.IOException; public class Validateur { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setValidating(true); DocumentBuilder parser = factory.newDocumentBuilder(); parser.setErrorHandler(new org.xml.sax.ErrorHandler() { public void warning(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Avertissement : \u0026#34; \u0026#43; ex.getMessage()); } public void error(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Erreur : \u0026#34; \u0026#43; ex.getMessage()); } public void fatalError(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Erreur fatale : \u0026#34; \u0026#43; ex.getMessage()); throw ex; } }); parser.parse(\u0026#34;fichieravalider.xml\u0026#34;); System.out.println(\u0026#34;Le document est valide.\u0026#34;); } } fichieravalider.xml\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \u0026#34;monfichier.dtd\u0026#34;\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;numero\u0026gt;123456\u0026lt;/numero\u0026gt; \u0026lt;nom\u0026gt;Jean Dupont\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;20\u0026lt;/age\u0026gt; \u0026lt;/etudiant\u0026gt; monfichier.dtd\u0026lt;!ELEMENT etudiant (numero, nom, age)\u0026gt; \u0026lt;!ELEMENT numero (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; Exécuter Application de bureau (optionnelle) # Nous vous invitons à mettre à l\u0026rsquo;essai notre application de bureau Java pour la validation des documents XML. Il vous suffit de suivre nos consignes en ligne.\nProcédure pour valider des documents XML # Avant de procéder à la validation, préparons notre environnement. Allez dans un répertoire, par exemple « C:\\XML », et créez le fichier « monfichier.dtd » avec le contenu suivant, en utilisant le bloc-notes :\n\u0026lt;!ELEMENT etudiant (numero, nom, age)\u0026gt; \u0026lt;!ELEMENT numero (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; Puis, créez un document appelé « mauvais.xml » avec le contenu suivant, toujours à l’aide du bloc-notes :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \u0026#34;monfichier.dtd\u0026#34;\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;numero\u0026gt;123456\u0026lt;/numero\u0026gt; \u0026lt;nom\u0026gt;Jean Dupont\u0026lt;/nom\u0026gt; \u0026lt;/etudiant\u0026gt; Il est important que les deux fichiers soient dans le même répertoire. En effet, la ligne DOCTYPE etudiant SYSTEM \u0026ldquo;monfichier.dtd\u0026rdquo; dans le fichier « mauvais.xml » indique qu’il devrait y avoir un fichier « monfichier.dtd » dans le même répertoire.\nVérifions maintenant si le fichier « mauvais.xml » est valable.\nD’abord, vous devez disposer d’une machine virtuelle Java récente (Java 21 ou mieux) sur votre ordinateur, incluant le compilateur Java : « javac ». Si vous n’en avez pas, il faut effectuer un enregistrement et une installation (adoptium.net) d’une telle machine. En outre, vous devez avoir sur votre ordinateur le SDK (aussi appelé JDK), pas uniquement le JRE. Sur la page qui se trouve à l’adresse le téléchargement peut prendre plusieurs minutes. Il suffit ensuite de lancer le fichier exécutable que vous venez d’enregistrer sur votre ordinateur pour installer le SDK. Une fois le SDK installé, vous pouvez poursuivre l’activité de vérification. Si l’outil d’installation vous propose de modifier les variables PATH et JAVAHOME, vous devez l’y autoriser. Si vous êtes incapable d’installer un logiciel sur votre ordinateur, nous vous invitons à joindre un technicien et à obtenir de l’aide. Nous ne pouvons pas, au sein du cours, vous offrir un soutien technique spécifique à votre ordinateur. Placez le fichier Validateur.java dans le répertoire où se trouvent déjà vos fichiers « mauvais.xml » et « monfichier.dtd », soit dans « C:\\XML ». Votre fichier « Validateur.java » devrait avoir le contenu suivant : import org.xml.sax.*; import javax.xml.parsers.*; import java.io.IOException; public class Validateur { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setValidating(true); DocumentBuilder parser = factory.newDocumentBuilder(); parser.setErrorHandler(new org.xml.sax.ErrorHandler() { public void warning(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Avertissement : \u0026#34; + ex.getMessage()); } public void error(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Erreur : \u0026#34; + ex.getMessage()); } public void fatalError(SAXParseException ex) throws SAXException { System.err.println(\u0026#34;Erreur fatale : \u0026#34; + ex.getMessage()); throw ex; } }); parser.parse(args[0]); System.out.println(\u0026#34;Le document est valide.\u0026#34;); } } Ensuite, lancez la machine virtuelle Java avec une ligne de commande. Pour cela, il faut ouvrir une fenêtre de commande. Sous Windows 8 et versions ultérieures, cliquez en bas à gauche avec le bouton droit de la souris et sélectionnez « invite de commandes ». Sous les versions précédentes de Windows, dans le menu « Démarrer », cliquez sur « Exécuter » ; une fenêtre s’ouvre, tapez le nom de programme « cmd » pour ouvrir une fenêtre de commande. Notez qu’avec les versions plus anciennes de Windows, comme Windows 98, il faut taper « command.com ». Une fenêtre s’ouvre alors avec un fond noir, c’est la fenêtre de commande. Vous allez pouvoir y taper des lignes de commande pour vérifier si votre document XML est valable. Les commandes de base sont : « dir » (affiche le contenu d’un répertoire), « cd » (change de répertoire), « cd .. » (répertoire parent), « mkdir » (création d’un nouveau répertoire), « copy » (copie d’un fichier), « move » (déplacement d’un fichier), et « del » (supprime un fichier).\nTestez l’installation de votre machine virtuelle en tapant « java » suivi du retour de chariot. Vous devriez recevoir un message qui commence par quelque chose comme « Usage: java [-options] class [args\u0026hellip;] ». Testez aussi l’installation du compilateur en tapant « javac » ; vous devriez voir un message qui commence par quelque chose comme « Usage: javac \u0026lt;options\u0026gt; \u0026lt;source files\u0026gt; ». Si ce n’est pas le cas, nous vous conseillons de vérifier l’installation de votre machine virtuelle et de procéder à sa réinstallation au besoin. Si tout est bien installé et que ça ne fonctionne toujours pas, vous devrez indiquer le chemin pour trouver le compilateur en tapant la ligne de commande « set PATH=%PATH%;adresse_du_fichier_javac.exe ». Le fichier « javac.exe » se trouve dans le dossier « bin » du dossier où vous avez installé le SDK. Par défaut, ce fichier se trouve dans le « C: ». L’adresse du répertoire contenant le fichier « javac.exe » est donc souvent de la forme « C:\\Program Files\\Java\\jdkXXXX\\bin ». Si vous ne savez plus où est installé le SDK, vous pouvez faire une recherche, à partir du menu « Démarrer » de Windows. Une fois le chemin indiqué, retapez la commande « javac » et cette fois, tout devrait fonctionner. Comme il peut être lourd de modifier la variable d’environnement PATH chaque fois, il est possible de la modifier une fois pour toutes : allez dans « Démarrer », choisissez « Paramètres », puis « Panneau de configuration », et ouvrez « Système », cliquez sur l’onglet « Avancé » ; cliquez ensuite sur le bouton « Variables d’environnement », sélectionnez « PATH » dans la liste des variables, cliquez sur le bouton « Modifier » et ajoutez, à la fin du contenu de la variable, « ;adresse_du_fichier_javac.exe », par exemple « ;C:\\Program Files\\Java\\jdk21\\bin ».\nEnsuite, placez-vous dans le dossier où se trouvent votre fichier XML et sa DTD. Vous savez toujours où vous vous trouvez dans l’arborescence de votre ordinateur, puisque chaque ligne de commande commence par l’adresse où vous êtes. La commande pour se déplacer est « cd adresse ». Par exemple, si la ligne commence par « C:\\Documents and Settings\\lucie\u0026gt; », vous êtes dans le dossier de lucie. Pour aller au dossier XML qui se trouve sur le disque C, il faut taper : « cd C:\\XML », puis faire le retour de chariot. Une nouvelle ligne apparaît et commence par : « C:\\XML\u0026gt; ». Maintenant que vous êtes dans le dossier où se trouve votre fichier XML, vous pouvez vérifier s’il est valable.\nFaites « javac Validateur.java » pour compiler le petit programme qui pourra vous servir à vérifier la validité des documents XML. Vous ne devriez pas avoir de mal avec la compilation. Par exemple, vous pourriez voir à l’écran quelque chose comme « Note: Validateur.java uses or overrides a deprecated API. Note: Recompile with -Xlint:deprecation for details. ». Vous pouvez ignorer les avertissements vous incitant à utiliser l’option « -deprecation ».\nTapez la ligne de commande « java Validateur mauvais.xml », puis faites un retour de chariot. Il est important de respecter la casse dans les lignes de commande. Si rien de significatif ne s’affiche, votre fichier est valable, sinon, une description des erreurs s’affichera (en anglais). Si la machine virtuelle quitte avec l’erreur « java.lang.NoClassDefFoundError » alors que vous êtes bien dans le bon répertoire, faites alors « java -cp . Validateur mauvais.xml ».\nPour quitter, vous n’avez qu’à fermer la fenêtre de commande.\nVérification de la procédure # Après avoir tapé la commande « java Validateur mauvais.xml » pour vérifier si le fichier « mauvais.xml » est valable, vous devriez obtenir le message d’erreur suivant indiquant qu’il manque un élément « numero » (le message exact peut varier et il pourrait être en français) :\nmauvais.xml:7:1: Élément \u0026#34;etudiant\u0026#34; doit contenir un élément \u0026#34;numero\u0026#34;. Pour vous assurer de bien comprendre, reprenez la procédure ; créez un autre document appelé « bon.xml » avec le contenu suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \u0026#34;monfichier.dtd\u0026#34;\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;numero\u0026gt;123456\u0026lt;/numero\u0026gt; \u0026lt;nom\u0026gt;Jean Dupont\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;20\u0026lt;/age\u0026gt; \u0026lt;/etudiant\u0026gt; Cette fois-ci, vous devriez, en vérifiant que le document est valable, obtenir le message suivant :\nLe document est valide. Est-ce que vous avez pu vérifier si les fichiers « mauvais.xml » et « bon.xml » étaient valables ? Si oui, passez aux autres activités, sinon cherchez encore un peu.\n"},{"id":35,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/xpath_approfondissement/","title":"XPath : approfondissement","section":"XPath","content":" XPath : approfondissement # Expression XPath avec « | » # Parfois, nous voulons sélectionner plusieurs noms d\u0026rsquo;éléments; nous pouvons obtenir ce résultat avec le symbole « | » (barre verticale) qui signifie « union ». Par exemple, le modèle qui suit s\u0026rsquo;applique à tous les éléments « facture » et « montant », et seulement à ces éléments est facture|montant.\nExpression XPath pour le nom d\u0026rsquo;un élément # Supposons que nous voulions afficher uniquement les noms des éléments (sans leur contenu). Nous pouvons obtenir ce résultat avec la fonction XPath « name » qui donne le nom de l\u0026rsquo;élément. La fonction name inclut le préfixe de l\u0026rsquo;espace de noms. Si on souhaite le nom de l\u0026rsquo;élément sans le préfixe, on peut utiliser la fonction « local-name ». La fonction « namespace-uri » donne l\u0026rsquo;URI de l\u0026rsquo;espace de noms de l\u0026rsquo;élément. Nous reviendrons sur ces expressions XPath dans le contexte du XSLT.\nSélection conditionnelle # L\u0026rsquo;expression XPath « /listedeclients/client[nom=\u0026lsquo;Sylvain\u0026rsquo;] » nous donnera les éléments pour lesquels le contenu du sous-élément « nom » est « Sylvain ». L\u0026rsquo;expression plus complète « /listedeclients/client[nom=\u0026lsquo;Sylvain\u0026rsquo;]/@telephone » pointera directement sur l\u0026rsquo;attribut « telephone ». D\u0026rsquo;un autre côté, l\u0026rsquo;expression XPath « /listedeclients/client[@telephone=\u0026lsquo;533-3445\u0026rsquo;]/nom », nous donnera l\u0026rsquo;élément « nom » contenant le nom du client ayant le numéro de téléphone indiqué.\nL\u0026rsquo;absence du symbole « = » dans le crochets indique qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un test d\u0026rsquo;existence. Ainsi, « /listedeclients/client[nom] » donne les éléments « client » qui ont un sous-élément « nom ». De la même façon, « /listedeclients/client[@telephone] » donne les éléments « client » qui ont un attribut « telephone ».\nSupposons maintenant que nous soyons devant un fichier XML comme celui-ci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;listes\u0026gt; \u0026lt;vendeur nom=\u0026#34;Jean\u0026#34;\u0026gt; \u0026lt;client telephone=\u0026#34;543-5454\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Jacques\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;545-5455\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Sylvain\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;443-4456\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Claude\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;533-3445\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Yvon\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur nom=\u0026#34;Raymond\u0026#34;\u0026gt; \u0026lt;client telephone=\u0026#34;432-2145\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Arthur\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;545-5456\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Sylvain\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;443-4556\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Claudette\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;533-3445\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Yvon\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/listes\u0026gt; Il est maintenant plus fastidieux de trouver le numéro de téléphone d\u0026rsquo;un certain client, car il faut visiter tous les vendeurs. De plus, chaque vendeur peut avoir un numéro de téléphone (possiblement différent) pour chaque client. Comme nous allons le voir, XPath permet de gérer assez facilement ces situations.\nTout d\u0026rsquo;abord, l\u0026rsquo;expression « //client » donne une séquence de tous les éléments « client » dans le nœud courant. Avec l\u0026rsquo;expression XPath « //client[nom=\u0026lsquo;Sylvain\u0026rsquo;] », nous pouvons obtenir la séquence de tous les éléments « client » ayant pour nom « Sylvain ».\nDans le même ordre d\u0026rsquo;idée, nous pouvons tester des conditions à l\u0026rsquo;aide d\u0026rsquo;expressions XPath contenant les symboles « \u0026lt; », « = », « != », « or », « and », « \u0026gt; », « \u0026gt;= », « \u0026lt;= ».\nArithmétique en XPath # Nous pouvons aussi nous servir des expressions XPath pour faire du calcul simple. Par exemple, les trois expressions suivantes donneront 2, 2 et 2.5 respectivement :\n\u0026lt;xsl:value-of select=\u0026#34;1+1\u0026#34; /\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;2*1\u0026#34; /\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;5 div 2\u0026#34; /\u0026gt; Il arrive qu\u0026rsquo;on doive calculer une somme de nombres. Par exemple, supposons qu\u0026rsquo;une facture comporte une liste de montants.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;xslt.xml\u0026#34; type=\u0026#34;application/xml\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;montant\u0026gt;20.10\u0026lt;/montant\u0026gt; \u0026lt;montant\u0026gt;40.10\u0026lt;/montant\u0026gt; \u0026lt;/facture\u0026gt; La fonction XPath « sum » nous permet de calculer la somme des montants sans effort comme dans cet exemple :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;sum(montant)\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Comme en Java, on a aussi les fonctions « floor », « ceiling », « mod » et « round ». On peut aussi utiliser les paranthèses dans toutes expressions XPath : « (5 + 2) div 2 ».\nLa fonction « count » compte le nombre de valeurs. On obtient la moyenne en divisant la somme par le compte (sum(x)/count(x)). Et ainsi de suite.\nManipulations des chaînes de caractères en XPath # Outre les fonctions arithmétiques, on peut aussi manipuler les chaînes de caractères en XPath. La fonction la plus simple est « string-length ». Elle calcule la longueur d\u0026rsquo;une chaîne. Une autre fonction simple est « normalize-space » qui élimine tous les espaces au début et à la fin d\u0026rsquo;une chaîne en plus de remplacer les espaces répétés par un espace simple. La fonction « translate » permet de remplacer des caractères. Par exemple, pour remplacer les é par des e et les à par des a, on pourrait utiliser l\u0026rsquo;instruction suivante « translate(\u0026ldquo;à la vérité\u0026rdquo;,\u0026ldquo;éà\u0026rdquo;,\u0026ldquo;ea\u0026rdquo;) » qui renvoie « a la verite ».\nOn peut extraire des sous-chaînes de caractères de diverses manières : la fonction « substring » permet d\u0026rsquo;extraire une sous-chaîne lorsqu\u0026rsquo;on en connaît sa position et sa longueur, la fonction « substring-after » permet d\u0026rsquo;aller chercher un suffixe, la fonction « substring-before » permet d\u0026rsquo;aller chercher un préfixe. Par exemple, « substring(\u0026ldquo;la vie est belle\u0026rdquo;,3,7) » renvoie « vie est », « substring-after(\u0026ldquo;la vie est belle\u0026rdquo;,\u0026ldquo;est\u0026rdquo;) » renvoie « belle » alors que « substring-before(\u0026ldquo;la vie est belle\u0026rdquo;,\u0026ldquo;est\u0026rdquo;) » renvoie « la vie »\nOn peut aussi additionner deux chaînes de caractères pour en faire une seule avec la fonction « concat ». L\u0026rsquo;expression « concat(\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;) » a comme valeur \u0026ldquo;ab\u0026rdquo;.\nOn peut tester une chaîne pour la présence d\u0026rsquo;une sous-chaîne avec la fonction XPath « contains ». L\u0026rsquo;expression « contains(\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;bc\u0026rdquo;) » est vraie parce que \u0026ldquo;bc\u0026rdquo; est une sous-chaîne de \u0026ldquo;abc\u0026rdquo;, alors que l\u0026rsquo;expression « contains(\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;bz\u0026rdquo;) » est fausse.\nTester le contenu des chaînes de caractères # Nous avons vu comment comparer le nom ou le contenu d\u0026rsquo;un élément avec une chaîne de caractères donnée, mais il arrive qu\u0026rsquo;on veuille faire des comparaisons plus fine. Heureusement, il existe des fonctions XPath permettant d\u0026rsquo;analyser le contenu des chaînes. Par exemple, « starts-with(@toto,\u0026ldquo;a\u0026rdquo;) » renvoie la valeur vraie si et seulement si la valeur de l\u0026rsquo;attribut « toto » débute avec la lettre « a ». L\u0026rsquo;expression « ends-with(@toto,\u0026ldquo;a\u0026rdquo;) » est vraie si et seulement si la valeur de l\u0026rsquo;attribut « toto » se termine avec la lettre « a ». De la même façon, « contains(@toto,\u0026ldquo;abc\u0026rdquo;) » renvoie la valeur vraie si et seulement si la valeur de l\u0026rsquo;attribut « toto » contient la chaîne « abc » (comme dans « j\u0026rsquo;ai un abc »).\nAccès aux éléments d\u0026rsquo;un ensemble d\u0026rsquo;éléments # Avec XPath, nous pouvons traiter du XML un peu comme nous traitons un tableau en Java ou en C/C++. Par exemple, supposons que nous ayons une liste de clients avec leur numéro de téléphone, comme ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;listedeclients\u0026gt; \u0026lt;client telephone=\u0026#34;543-5454\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Jacques\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;545-5455\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Sylvain\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;443-4456\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Claude\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\u0026#34;533-3445\u0026#34;\u0026gt;\u0026lt;nom\u0026gt;Yvon\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;/listedeclients\u0026gt; Notez que l\u0026rsquo;expression XPath « /listedeclients/client » est en fait une séquence (ensemble ordonné) d\u0026rsquo;éléments. Ainsi, « /listedeclients/client[2] » représente le deuxième (et non le troisième!) élément « client », celui dont le nom est « Sylvain ».\nMaintenant, si nous voulons obtenir le numéro de téléphone du deuxième client de la liste, il faut d\u0026rsquo;abord ajouter le symbole « / » (barre oblique) pour indiquer qu\u0026rsquo;on cherche un sous-nœud de l\u0026rsquo;élément en question, suivi de « @telephone » pour désigner l\u0026rsquo;attribut « telephone ». L\u0026rsquo;expression XPath \u0026ldquo;/listedeclients/client[2]/@telephone\u0026rdquo; nous donnerait le numéro de téléphone désiré.\nNotez que l\u0026rsquo;expression « /listedeclients/client[0] » n\u0026rsquo;est pas valable, car la numérotation des éléments d\u0026rsquo;une séquence débute à 1 en XPath, contrairement à Java et à C/C++.\nNotez aussi qu\u0026rsquo;on aurait pu obtenir le même résultat avec l\u0026rsquo;expression XPath « (/listedeclients/client/@telephone)[2] », car « /listedeclients/client/@telephone » est aussi une séquence (mais une séquence d\u0026rsquo;attributs). Nous devons toutefois ajouter une parenthèse pour marquer la priorité des opérations. En effet, la syntaxe « a/b[2] » signifie : deuxième nœud de type « b » dans les nœuds de type « b ». Comme il ne peut y avoir qu\u0026rsquo;un seul attribut d\u0026rsquo;un type donné dans un élément, la syntaxe « a/@b[2] » donnera toujours un ensemble vide. D\u0026rsquo;un autre côté, la syntaxe « (a/b)[2] » signifie : deuxième nœud de type « b » dans la séquence des nœuds de type « b » contenus dans les nœuds de type « a ». De la même manière, « //b[2] » donne la liste de tous les éléments b « b » dans le document apparaissant deuxième dans la liste des éléments contenus dans un autre élément, alors que « (//b)[2] » est le deuxième élément « b » rencontré dans tout le document.\nVous croyez avoir bien compris ? Quelle est la différence entre « (b)[2] » et « b[2] » ? Quelle est la différence entre « (b[2])/a » et « b[2]/a » ?\nUnion, intersection et différence en XPath # Nous avons vu que le symbole « | » nous permet d\u0026rsquo;obtenir l\u0026rsquo;union de deux expressions XPath. Prenons l\u0026rsquo;exemple de ce document :\n\u0026lt;x\u0026gt; \u0026lt;a s=\u0026#34;1\u0026#34; t=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;b s=\u0026#34;1\u0026#34; t=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;c s=\u0026#34;0\u0026#34; t=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;d s=\u0026#34;0\u0026#34; t=\u0026#34;0\u0026#34; /\u0026gt; \u0026lt;/x\u0026gt; L\u0026rsquo;expression « //*[@s=\u0026ldquo;1\u0026rdquo;] » représente les éléments a et b, l\u0026rsquo;expression « //*[@t=\u0026ldquo;1\u0026rdquo;] » représente les éléments b et c, alors que l\u0026rsquo;expression « //*[@s=\u0026ldquo;1\u0026rdquo;]|//*[@t=\u0026ldquo;1\u0026rdquo;] » représente les éléments a,b,c (une union de « //*[@s=\u0026ldquo;1\u0026rdquo;] » et « //*[@t=\u0026ldquo;1\u0026rdquo;] »).\nSupposons maintenant que nous désirions obtenir les éléments qui satisfont « @s=\u0026ldquo;1\u0026rdquo; » et « @t=\u0026ldquo;1\u0026rdquo; » : on veut calculer l\u0026rsquo;intersection entre « //*[@s=\u0026ldquo;1\u0026rdquo;] » et « //*[@t=\u0026ldquo;1\u0026rdquo;] ». On pourrait, bien sûr, obtenir ce résultat avec « //*[@s=\u0026ldquo;1\u0026rdquo; and @t=\u0026ldquo;1\u0026rdquo;] », mais il existe une autre façon de le faire qui est d\u0026rsquo;application plus générale. Supposons que les résultats des expressions « //*[@s=\u0026ldquo;1\u0026rdquo;] » et « //*[@t=\u0026ldquo;1\u0026rdquo;] » sont déjà stockés dans les variables a1 et a2 respectivement. Alors l\u0026rsquo;expression « $a1[count(.|$a2)=count($a2)] » sélectionne l\u0026rsquo;élément b (ou « //*[@s=\u0026ldquo;1\u0026rdquo; and @t=\u0026ldquo;1\u0026rdquo;] »). Ce motif particulier calcule l\u0026rsquo;intersection entre le contenu des variables a1 et a2. Pour le comprendre, il suffit de réaliser que la condition « count(.|$a2)=count($a2) » n\u0026rsquo;est vraie que pour les nœuds appartenant déjà à l\u0026rsquo;ensemble a2.\nSupposons maintenant que l\u0026rsquo;on souhaite trouver les éléments qui satisfont « @s=\u0026ldquo;1\u0026rdquo; » mais pas « @t=\u0026ldquo;1\u0026rdquo; », c\u0026rsquo;est-à-dire l\u0026rsquo;élément a. En fait, on souhaite calculer la différence entre deux ensembles (« //*[@s=\u0026ldquo;1\u0026rdquo;] » et « //*[@t=\u0026ldquo;1\u0026rdquo;] »). On pourrait obtenir ce résultat avec l\u0026rsquo;expression « //*[@s=\u0026ldquo;1\u0026rdquo; and not(@t=\u0026ldquo;1\u0026rdquo;)] », mais encore une fois, il existe un motif plus général: « $a1[count(.|$a2)!=count($a2)] » ou « //*[@s=\u0026ldquo;1\u0026rdquo;][count(.|//*[@t=\u0026ldquo;1\u0026rdquo;])!=count(//*[@t=\u0026ldquo;1\u0026rdquo;])] ». Pour comprendre cette expression, il suffit de réaliser que si et seulement si un nœud x n\u0026rsquo;appartient pas à a2, alors l\u0026rsquo;expression « count(x|$a2)!=count($a2) » sera vraie.\n"},{"id":36,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/xslt_en_ligne/","title":"XSLT en ligne","section":"XSLT","content":" XSLT en ligne Testez vos transformations XSLT directement dans votre navigateur ! Cet outil vous permet de traiter n'importe quel fichier XML avec une feuille de style XSLT sans utiliser l'instruction xml-stylesheet . C'est une alternative pratique pour programmer et expérimenter avec XSLT sans charger de fichiers externes. Essayez la transformation XSLT proposée ci-dessous. Pouvez-vous repérer l'expression XPath dans le script ? Modifiez-la pour voir comment le résultat change. La pratique est essentielle pour maîtriser XSLT, alors n'hésitez pas à expérimenter ! Instructions : Saisissez un fichier XML source et une transformation XSLT valide, puis cliquez sur « Transformer ». Vous pouvez réinitialiser les champs avec le bouton « Réinitialiser ». Document XML source \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;monmessage\u0026gt; \u0026lt;de\u0026gt;Jean\u0026lt;/de\u0026gt; \u0026lt;a\u0026gt;Pierre\u0026lt;/a\u0026gt; \u0026lt;titre type=\"émotion\"\u0026gt;Ouch!\u0026lt;/titre\u0026gt; \u0026lt;corps\u0026gt;Maman!\u0026lt;/corps\u0026gt; \u0026lt;/monmessage\u0026gt; Feuille de style XSLT (ex. 1.0) \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:output method=\"text\"/\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; Résultat de l'attribut type : \u0026lt;xsl:value-of select=\"//titre/@type\"/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; Nombre d'éléments enfants du document : \u0026lt;xsl:value-of select=\"count(//*)\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Résultat Cliquez sur « Transformer ». Transformer Réinitialiser "},{"id":37,"href":"/orientee_donnees/docs/modules/d_module_html/autoevaluation/","title":"Autoévaluation HTML","section":"Module HTML, CSS, SVG, MathML","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Parmi les documents suivants, lesquels sont du XHTML valide? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Voici mon document \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Non. La balise « p » doit être fermée. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;P\u0026gt;Voici mon document\u0026lt;/P\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Non. La balise « P » n'existe pas en XHTML : le XML tient compte de la casse et l'élément « p » n'est pas la même chose que l'élément « P ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\" [ \u0026lt;!ENTITY texte \"\u0026lt;p\u0026gt;Note légale: vous pouvez faire ce que vous voulez\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Copyright 2004\u0026lt;/p\u0026gt;\"\u0026gt; ]\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026amp;texte; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Oui. L'entité contient deux éléments bien formés et le résultat est du XHTML valide. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\" [ \u0026lt;!ENTITY texte \"Voici mon document\u0026lt;/p\u0026gt;\"\u0026gt; ]\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;\u0026amp;texte; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Non. Une entité doit être du XML bien formé et si une entité contient des balises, il doit s'agir d'éléments avec balise ouvrante et balise fermante. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\" \u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=http://www.uqam.ca/img/logo/logo.jpg alt=\"logo de l'UQÀM\" /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Non, les attributs doivent être entre guillemets comme ceci : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\" \u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un titre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\"http://www.uqam.ca/img/logo/logo.jpg\" alt=\"logo de l'UQÀM\" /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Question 2 . Quel énoncé décrit le mieux le XHTML? Choisissez la bonne réponse parmi les suivantes. Un document XHTML est du XML bien formé. (Réponse correcte!) Effectivement. Du XHTML doit absolument être bien formé. Le document XHTML devrait être du XML bien formé, mais le navigateur va tolérer de petites erreurs comme des balises croisées \u0026lt;b\u0026gt;\u0026lt;i\u0026gt;test\u0026lt;/b\u0026gt;\u0026lt;/i\u0026gt;. (Réponse incorrecte!) Justement pas : on ne tolère pas de telles erreurs en XHTML, car cela rend la vie plus difficile aux machines et mène à des problèmes de compatibilité entre les navigateurs. Le XHTML est une nouvelle technologie qui exige un investissement important et une conversion coûteuse des documents. (Réponse incorrecte!) Non. Le XHTML est très similaire au HTML. Question 3 . Par rapport au XHTML, les énoncés suivants sont-ils justes? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Si mon entreprise utilise déjà beaucoup le XML, le XHTML est un choix plus facile. Effectivement. On peut facilement transformer le XML en XHTML et si vous connaissez les outils XML, vous pouvez les utiliser avec le XHTML. Les navigateurs ne supportent pas encore XHTML. C'est faux. La plupart des navigateurs supportent bien le XHTML, mais tous ne supportent pas l'ensemble des normes XML. Le XHTML est une technologie favorisant la pérennité des documents. Effectivement. Comme le XHTML suit une DTD fixe, il sera possible dans le futur de bien interpréter les documents XHTML, alors que le HTML que l'on trouve sur le web est souvent désuet après quelques mises à jour des navigateurs. Question 4 . Quels énoncés, parmi les suivants, décrivent bien le XHTML dans le contexte du XML? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». On peut utiliser les balises XHTML dans nos propres DTD. C'est sans problème. On peut recopier les parties des DTD XHTML et les utiliser dans nos propres DTD. Cela peut être utile si un document XML doit être transformé en XHTML plus tard. On peut utiliser nos propres balises en XHTML. Pas si nous utilisons les DTD officielles. Si nous écrivons vos propres DTD, il est possible que notre navigateur ne reconnaisse pas le contenu comme étant du XHTML. On peut définir ses propres entités en XHTML. Effectivement. Nous avons vu plus haut que les entités pouvaient être utilisées pour marquer le titre d'un livre ou le nom d'un auteur, mais on peut aussi définir des entités pour obtenir des caractères spéciaux, et ainsi de suite. Question 5 . Parmi les énoncés suivants, lesquels s'appliquent à un document XHTML? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». Il s'agit d'un document HTML pouvant s'afficher dans un navigateur. Oui. D'ailleurs, le texte d'introduction à HTML en est un exemple. Il s'agit d'un document XML bien formé. Effectivement. Il s'agit d'un document XML valide. Effectivement, avec une déclaration de type de document utilisant un identifiant public. Question 6 . Combien de paragraphes compte le document XHTML suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; L'enfant pleure dans la rue. Subitement, le Soleil se lève. Ah! Que la vie est belle! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\nChoisissez la bonne réponse parmi les suivantes. 1 (Réponse correcte!) Oui. 2 (Réponse incorrecte!) Non. 3 (Réponse incorrecte!) Non. Aucune de ces réponses (Réponse incorrecte!) Non. Question 7 . Combien de paragraphes compte le document XHTML suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;L'enfant pleure dans la rue. Subitement, le Soleil se lève.\u0026lt;p\u0026gt; \u0026lt;p\u0026gt;Ah! Que la vie est belle!\u0026lt;/P\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\nChoisissez la bonne réponse parmi les suivantes. 1 (Réponse incorrecte!) Non. Il ne s'agit pas de XHTML valide; la balise \u0026lt;/P\u0026gt; est incorrecte. 2 (Réponse incorrecte!) Ce serait vrai s'il s'agissait de XHTML valide. 3 (Réponse incorrecte!) Non. Aucune de ces réponses (Réponse correcte!) Effectivement. Il ne s'agit pas de XHTML valide, la seconde balise paragraphe se terminant par \u0026lt;/P\u0026gt;. Un logiciel compatible avec XHTML comme Google Chrome ou Firefox peut très bien ne rien afficher à l'écran. Question 8 . Combien de lignes horizontales sont représentées par ce document XHTML? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;hr\u0026gt;\u0026lt;/hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Choisissez la bonne réponse parmi les suivantes. 1 (Réponse incorrecte!) Non. 2 (Réponse correcte!) Oui. 3 (Réponse incorrecte!) Non. Aucune de ces réponses (Réponse incorrecte!) Non. Question 9 . Comment représente-t-on une liste numérotée en XHTML? Choisissez la bonne réponse parmi les suivantes. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;li\u0026gt; \u0026lt;ul\u0026gt;élément\u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt;élément\u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (Réponse incorrecte!) Non. Ce n'est pas du XHTML valide. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;li\u0026gt; \u0026lt;ol\u0026gt;élément\u0026lt;/ol\u0026gt; \u0026lt;ol\u0026gt;élément\u0026lt;/ol\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (Réponse incorrecte!) Non, ce n'est pas du XHTML valide. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;élément\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;élément\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (Réponse correcte!) Oui. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Titre de mon document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;élément\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;élément\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; (Réponse incorrecte!) Non. C'est bien du XHTML valide, mais la liste n'est pas numérotée. "},{"id":38,"href":"/orientee_donnees/docs/modules/a_module_json/markdown/","title":"MarkDown","section":"Module JSON","content":" MarkDown # Le MarkDown qui est un format de texte simple permettant un formattage basique des différents éléments. Il facile de produire du MarkDown, à la main ou à l'aide de logiciel. Pour utiliser le Markdown, il suffit de maîtriser quelques règles de base. Par exemple, pour créer un titre, on place un ou plusieurs # avant le texte (comme # Titre pour un titre principal), pour mettre du texte en gras, on entoure le mot avec deux étoiles **gras**, et pour une liste, on commence chaque ligne par un tiret -. Ces conventions permettent de structurer un document sans quitter le clavier pour des outils complexes comme Word. Le texte reste lisible même sans conversion, ce qui est parfait pour les gens qui veulent se concentrer sur le contenu plutôt que sur le formatage. Laboratoire Markdown : Rendu de Liste d'étudiants Modifiez ou utilisez le contenu Markdown ci-dessous, puis cliquez sur \"Rendre\" pour afficher le résultat formaté. Exemple : Exemple Markdown : # Liste d'étudiants Voici une liste d\u0026rsquo;étudiants inscrits :\nJean Aaron Pierre Laroche Fin du document. Contenu Markdown : # Liste d'étudiants Voici une liste d'étudiants inscrits : - **Jean Aaron** - **Pierre Laroche** *Fin du document.* Rendre "},{"id":39,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/xpath_en_ligne_java/","title":"XPath avec Java","section":"XPath","content":" Demonstration Java # Vous pouvez utiliser des requêtes XPath sur un fichier XML en ligne en utilisant java, en appuyant sur le bouton exécuter. Vous pouvez modifier les fichier Java et le fichier XML.\nSimpleXPath.javaimport javax.xml.xpath.*; import javax.xml.namespace.QName; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import java.io.File; public class SimpleXPath { public static void main(String[] args) throws Exception { // Fichier XML à lire File xmlFile = new File(\u0026#34;livres.xml\u0026#34;); // Construire le document DOM DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document doc = builder.parse(xmlFile); // Créer l\u0026#39;objet XPath XPath xpath = XPathFactory.newInstance().newXPath(); // === Exemples d\u0026#39;expressions XPath === // 1. Tous les titres de livres String expr1 = \u0026#34;//livre/titre\u0026#34;; printResult(xpath, doc, expr1, XPathConstants.NODESET); // 2. Le prix du premier livre String expr2 = \u0026#34;//livre[1]/prix\u0026#34;; printResult(xpath, doc, expr2, XPathConstants.STRING); // 3. Tous les livres de plus de 30 € String expr3 = \u0026#34;//livre[prix \u0026gt; 30]\u0026#34;; printResult(xpath, doc, expr3, XPathConstants.NODESET); // 4. Nombre total de livres String expr4 = \u0026#34;count(//livre)\u0026#34;; printResult(xpath, doc, expr4, XPathConstants.NUMBER); } private static void printResult(XPath xpath, Document doc, String expression, QName returnType) throws XPathExpressionException { Object result = xpath.evaluate(expression, doc, returnType); System.out.print(expression \u0026#43; \u0026#34; → \u0026#34;); if (returnType == XPathConstants.NODESET) { var nodes = (org.w3c.dom.NodeList) result; for (int i = 0; i \u0026lt; nodes.getLength(); i\u0026#43;\u0026#43;) { System.out.print(nodes.item(i).getTextContent()); if (i \u0026lt; nodes.getLength() - 1) System.out.print(\u0026#34; | \u0026#34;); } System.out.println(); } else if (returnType == XPathConstants.STRING) { System.out.println((String) result); } else if (returnType == XPathConstants.NUMBER) { System.out.println(((Number) result).doubleValue()); } else { System.out.println(result); } } } livres.xml\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;bibliotheque\u0026gt; \u0026lt;livre isbn=\u0026#34;978-2070416080\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;L\u0026#39;Étranger\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Albert Camus\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1942\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;7.50\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre isbn=\u0026#34;978-2253004226\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Le Petit Prince\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Antoine de Saint-Exupéry\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1943\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;6.90\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre isbn=\u0026#34;978-0140449136\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;1984\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;George Orwell\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1949\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;9.20\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;/bibliotheque\u0026gt; Exécuter "},{"id":40,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/xslt_en_ligne_java/","title":"XSLT avec Java","section":"XSLT","content":" Demonstration Java # Vous pouvez transformer le fichier XML en ligne en utilisant java, en appuyant sur le bouton exécuter. Attention au fait que la librairie standard de Java ne supporte que XSLT 1.0. Vous pouvez modifier les fichiers XSLT et XML.\nXmlVersConsole.javaimport javax.xml.transform.*; import javax.xml.transform.stream.StreamSource; import javax.xml.transform.stream.StreamResult; import java.io.File; import java.io.StringWriter; public class XmlVersConsole { public static void main(String[] args) { String xml = \u0026#34;livres.xml\u0026#34;; String xslt = \u0026#34;livres-vers-html.xsl\u0026#34;; try { String resultat = transformer(xml, xslt); System.out.println(resultat); } catch (TransformerException e) { System.out.println(\u0026#34;Erreur lors de la transformation : \u0026#34; \u0026#43; e.getMessageAndLocation()); } } public static String transformer(String fichierXml, String fichierXslt) throws TransformerException { TransformerFactory fabrique = TransformerFactory.newInstance(); Transformer transformateur = fabrique.newTransformer(new StreamSource(new File(fichierXslt))); // Transformation vers une chaîne en mémoire StringWriter writer = new StringWriter(); transformateur.transform( new StreamSource(new File(fichierXml)), new StreamResult(writer) ); return writer.toString(); } } livres-vers-html.xsl\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;html\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; indent=\u0026#34;yes\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Ma bibliothèque\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 40px; } h1 { color: #2c3e50; } table { width: 100%; border-collapse: collapse; margin-top: 20px; } th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; } th { background-color: #3498db; color: white; } tr:nth-child(even) { background-color: #f9f9f9; } tr:hover { background-color: #f2f2f2; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Ma petite bibliothèque\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Nombre de livres : \u0026lt;xsl:value-of select=\u0026#34;count(//livre)\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Titre\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Auteur\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Année\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Prix\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;bibliotheque/livre\u0026#34;\u0026gt; \u0026lt;xsl:sort select=\u0026#34;annee\u0026#34;/\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;strong\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;titre\u0026#34;/\u0026gt;\u0026lt;/strong\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;auteur\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;annee\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;prix\u0026#34;/\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;prix/@devise\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; livres.xml\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;bibliotheque\u0026gt; \u0026lt;livre isbn=\u0026#34;978-2070416080\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;L\u0026#39;Étranger\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Albert Camus\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1942\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;7.50\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre isbn=\u0026#34;978-2253004226\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Le Petit Prince\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Antoine de Saint-Exupéry\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1943\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;6.90\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre isbn=\u0026#34;978-0140449136\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;1984\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;George Orwell\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1949\u0026lt;/annee\u0026gt; \u0026lt;prix devise=\u0026#34;EUR\u0026#34;\u0026gt;9.20\u0026lt;/prix\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;/bibliotheque\u0026gt; Exécuter "},{"id":41,"href":"/orientee_donnees/docs/modules/b_module_xml/rdf/sparql/","title":"Activité SPARQL","section":"RDF","content":" Activité SPARQL # SPARQL (acronyme récursif de SPARQL Protocol and RDF Query Language) est le langage de requête standard pour interroger des données exprimées en RDF (Resource Description Framework). Il a été standardisé par le W3C en 2008 et sa version actuelle la plus utilisée est SPARQL 1.1 (2013).\nIl permet de récupérer et de manipuler des données stockées dans des triplestores ou dans n’importe quel graphe RDF, que ce soit sur le web (Linked Data), dans une base locale ou via un endpoint SPARQL public comme DBpedia, Wikidata ou data.gouv.fr.\nSPARQL ressemble beaucoup à SQL, mais au lieu de tables et colonnes, on travaille avec des triplets de la forme sujet – prédicat – objet (ex. : http://example.org/Paris rdf:type dbo:City).\nIl existe quatre formes principales de requêtes SPARQL :\nSELECT : retourne un tableau de résultats (le plus courant) CONSTRUCT : crée un nouveau graphe RDF à partir des résultats ASK : retourne simplement vrai ou faux DESCRIBE : retourne une description RDF d’une ressource Syntaxe de base # Une requête SELECT classique ressemble à ceci :\nPREFIX dbo: \u0026lt;http://dbpedia.org/ontology/\u0026gt; PREFIX rdfs: \u0026lt;http://www.w3.org/2000/01/rdf-schema#\u0026gt; SELECT ?ville ?population WHERE { ?ville a dbo:City ; dbo:populationTotal ?population ; rdfs:label \u0026#34;Paris\u0026#34;@fr . FILTER(?population \u0026gt; 1000000) } ORDER BY DESC(?population) LIMIT 10 Exemples concrets # 1. Exemple très simple – capitale de la France (sur DBpedia) # PREFIX dbo: \u0026lt;http://dbpedia.org/ontology/\u0026gt; PREFIX rdfs: \u0026lt;http://www.w3.org/2000/01/rdf-schema#\u0026gt; SELECT ?capitale WHERE { \u0026lt;http://dbpedia.org/resource/France\u0026gt; dbo:capital ?capitale . ?capitale rdfs:label ?label . FILTER(lang(?label) = \u0026#34;fr\u0026#34;) } Résultat attendu : http://dbpedia.org/resource/Paris avec le label \u0026ldquo;Paris\u0026rdquo;.\n2. Trouver tous les films réalisés par Quentin Tarantino (Wikidata) # PREFIX wdt: \u0026lt;http://www.wikidata.org/prop/direct/\u0026gt; PREFIX wd: \u0026lt;http://www.wikidata.org/entity/\u0026gt; PREFIX rdfs: \u0026lt;http://www.w3.org/2000/01/rdf-schema#\u0026gt; SELECT ?film ?filmLabel ?annee WHERE { ?film wdt:P57 wd:Q3772 . # P57 = réalisateur, Q3772 = Tarantino ?film wdt:P577 ?date . # date de publication BIND(YEAR(?date) AS ?annee) SERVICE wikibase:label { bd:serviceParam wikibase:language \u0026#34;fr\u0026#34;. } } ORDER BY ?annee 3. Exemple avec OPTIONAL (données facultatives) # PREFIX foaf: \u0026lt;http://xmlns.com/foaf/0.1/\u0026gt; PREFIX schema: \u0026lt;http://schema.org/\u0026gt; SELECT ?personne ?nom ?email ?site WHERE { ?personne a foaf:Person ; foaf:name ?nom . OPTIONAL { ?personne foaf:mbox ?email } OPTIONAL { ?personne foaf:homepage ?site } } LIMIT 20 Si une personne n’a pas d’email ou de site web, la ligne apparaît quand même avec les cellules vides.\n4. Exemple CONSTRUCT – créer un petit graphe # PREFIX foaf: \u0026lt;http://xmlns.com/foaf/0.1/\u0026gt; CONSTRUCT { ?ami foaf:knows ?ami2 . ?ami2 foaf:name ?nom2 . } WHERE { \u0026lt;http://example.org/alice\u0026gt; foaf:knows ?ami . ?ami foaf:knows ?ami2 . ?ami2 foaf:name ?nom2 . FILTER(?ami2 != \u0026lt;http://example.org/alice\u0026gt;) } Cela génère un nouveau graphe contenant les amis des amis d’Alice.\n5. Exemple avec FILTER, LANG et REGEX (recherche de labels en français contenant “église”) # PREFIX rdfs: \u0026lt;http://www.w3.org/2000/01/rdf-schema/\u0026gt; SELECT ?monument ?label WHERE { ?monument a \u0026lt;http://dbpedia.org/ontology/Monument\u0026gt; ; rdfs:label ?label . FILTER(LANG(?label) = \u0026#34;fr\u0026#34;) FILTER(REGEX(?label, \u0026#34;église\u0026#34;, \u0026#34;i\u0026#34;)) } LIMIT 15 6. Exemple d’agrégation (GROUP BY, COUNT) # PREFIX wdt: \u0026lt;http://www.wikidata.org/prop/direct/\u0026gt; SELECT ?pays ?paysLabel (COUNT(?ville) AS ?nbVilles) WHERE { ?ville wdt:P31 wd:Q515 ; # instance de \u0026#34;city\u0026#34; wdt:P17 ?pays . # pays SERVICE wikibase:label { bd:serviceParam wikibase:language \u0026#34;fr\u0026#34;. } } GROUP BY ?pays ?paysLabel HAVING(?nbVilles \u0026gt; 100) ORDER BY DESC(?nbVilles) LIMIT 10 Ce dernier exemple montre les 10 pays ayant le plus de villes recensées dans Wikidata.\nQuestions d’auto-évaluation # Écrivez une requête SPARQL qui retourne le nom (en français) et la date de naissance de toutes les personnes nées à Paris et décédées après 1950, en utilisant l’endpoint Wikidata. Utilisez le service wikibase:label et ordonnez les résultats par date de naissance décroissante.\nÀ l’aide d’une requête de type ASK, écrivez une requête qui vérifie simplement si Albert Einstein a gagné un prix Nobel (propriété Wikidata P166). La requête doit retourner true ou false.\nÉcrivez une requête CONSTRUCT qui, à partir de Wikidata, génère un petit graphe contenant :\nToutes les capitales européennes (P31/Q6465 ou instance de capitale + située dans un pays d’Europe) Leur population (P1082) Le nom du pays dont elles sont la capitale\nLe graphe résultant devra utiliser les prédicats schema:population et schema:country (http://schema.org/). (Solutions ci-dessous – à ne regarder qu’après avoir essayé !) Solution 1\nSELECT ?personne ?nom ?naissance WHERE { ?personne wdt:P19 wd:Q90 . # né à Paris ?personne wdt:P570 ?mort . # date de décès ?personne wdt:P569 ?naissance . FILTER(YEAR(?mort) \u0026gt; 1950) SERVICE wikibase:label { bd:serviceParam wikibase:language \u0026#34;fr\u0026#34;. } } ORDER BY DESC(?naissance) Solution 2\nASK { wd:Q937 wdt:P166 wd:Q38104 . # Einstein a reçu le prix Nobel de physique } Solution 3\nPREFIX wdt: \u0026lt;http://www.wikidata.org/prop/direct/\u0026gt; PREFIX wd: \u0026lt;http://www.wikidata.org/entity/\u0026gt; PREFIX schema: \u0026lt;http://schema.org/\u0026gt; CONSTRUCT { ?capitale schema:name ?nomCapitale ; schema:population ?pop ; schema:country ?pays . ?pays schema:name ?nomPays . } WHERE { ?capitale wdt:P31/wdt:P279* wd:Q5119 . # capitale (et sous-classes) ?capitale p:P17 ?statement . ?statement ps:P17 ?pays . ?pays wdt:P30 wd:Q46 . # continent Europe ?capitale wdt:P1082 ?pop . SERVICE wikibase:label { bd:serviceParam wikibase:language \u0026#34;fr\u0026#34;. ?capitale rdfs:label ?nomCapitale . ?pays rdfs:label ?nomPays . } } Activité avec Apache Jena # Apache Jena est un framework Java open source développé par la fondation Apache, dédié à la construction d\u0026rsquo;applications pour le Web sémantique et les données liées (Linked Data). Il fournit une API complète pour manipuler des données RDF (Resource Description Framework), lire et écrire des graphes RDF dans divers formats, exécuter des requêtes SPARQL, gérer des ontologies OWL, et même effectuer du raisonnement inférentiel.\nVoici un exemple que vous pouvez exécuter.\nDemoRdfXmlSparql.java import org.apache.jena.query.*; import org.apache.jena.rdf.model.Model; import org.apache.jena.rdf.model.ModelFactory; import java.io.StringReader; public class DemoRdfXmlSparql { private static final String DONNEES_RDF_XML = \u0026#34;\u0026#34;\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns:dc=\u0026#34;http://purl.org/dc/elements/1.1/\u0026#34; xmlns:foaf=\u0026#34;http://xmlns.com/foaf/0.1/\u0026#34; xmlns:bibo=\u0026#34;http://purl.org/ontology/bibo/\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema#\u0026#34;\u0026gt; \u0026lt;bibo:Book rdf:about=\u0026#34;http://example.org/books#book1\u0026#34;\u0026gt; \u0026lt;dc:title\u0026gt;Semantic Web Primer\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#grigoris\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Grigoris Antoniou\u0026lt;/foaf:name\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#frank\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Frank van Harmelen\u0026lt;/foaf:name\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:date rdf:datatype=\u0026#34;http://www.w3.org/2001/XMLSchema#gYear\u0026#34;\u0026gt;2008\u0026lt;/dc:date\u0026gt; \u0026lt;dc:publisher\u0026gt;MIT Press\u0026lt;/dc:publisher\u0026gt; \u0026lt;/bibo:Book\u0026gt; \u0026lt;bibo:Book rdf:about=\u0026#34;http://example.org/books#book2\u0026#34;\u0026gt; \u0026lt;dc:title\u0026gt;Linked Data\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#tim\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Tim Berners-Lee\u0026lt;/foaf:name\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#toby\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Toby Segaran\u0026lt;/foaf:name\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:date rdf:datatype=\u0026#34;http://www.w3.org/2001/XMLSchema#gYear\u0026#34;\u0026gt;2011\u0026lt;/dc:date\u0026gt; \u0026lt;dc:publisher\u0026gt;Wiley\u0026lt;/dc:publisher\u0026gt; \u0026lt;/bibo:Book\u0026gt; \u0026lt;bibo:Book rdf:about=\u0026#34;http://example.org/books#book3\u0026#34;\u0026gt; \u0026lt;dc:title\u0026gt;Programming the Semantic Web\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#toby\u0026#34;/\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/people#grigoris\u0026#34;/\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:date rdf:datatype=\u0026#34;http://www.w3.org/2001/XMLSchema#gYear\u0026#34;\u0026gt;2009\u0026lt;/dc:date\u0026gt; \u0026lt;dc:publisher\u0026gt;O\u0026#39;Reilly\u0026lt;/dc:publisher\u0026gt; \u0026lt;/bibo:Book\u0026gt; \u0026lt;/rdf:RDF\u0026gt; \u0026#34;\u0026#34;\u0026#34;; public static void main(String[] args) { Model modele = ModelFactory.createDefaultModel(); try (StringReader lecteur = new StringReader(DONNEES_RDF_XML)) { modele.read(lecteur, null, \u0026#34;RDF/XML\u0026#34;); } System.out.println(\u0026#34;Données bibliographiques RDF/XML chargées\u0026#34;); System.out.println(\u0026#34;Nombre total de triplets : \u0026#34; \u0026#43; modele.size() \u0026#43; \u0026#34;\\n\u0026#34;); // 1. Tous les livres executerRequete(modele, \u0026#34;\u0026#34;\u0026#34; PREFIX dc: \u0026lt;http://purl.org/dc/elements/1.1/\u0026gt; PREFIX foaf: \u0026lt;http://xmlns.com/foaf/0.1/\u0026gt; SELECT ?livre ?titre ?nomAuteur WHERE { ?livre dc:title ?titre . ?livre dc:creator ?auteur . ?auteur foaf:name ?nomAuteur . } ORDER BY ?titre \u0026#34;\u0026#34;\u0026#34;, \u0026#34;Tous les livres avec leurs titres et auteurs\u0026#34;); // 2. Nombre de livres par éditeur executerRequete(modele, \u0026#34;\u0026#34;\u0026#34; PREFIX dc: \u0026lt;http://purl.org/dc/elements/1.1/\u0026gt; SELECT ?editeur (COUNT(?livre) AS ?nombreLivres) WHERE { ?livre dc:publisher ?editeur . } GROUP BY ?editeur ORDER BY DESC(?nombreLivres) \u0026#34;\u0026#34;\u0026#34;, \u0026#34;Nombre de livres par éditeur\u0026#34;); // 3. FIX: Livres publiés après 2009 executerRequete(modele, \u0026#34;\u0026#34;\u0026#34; PREFIX dc: \u0026lt;http://purl.org/dc/elements/1.1/\u0026gt; PREFIX xsd: \u0026lt;http://www.w3.org/2001/XMLSchema#\u0026gt; SELECT ?livre ?titre ?annee WHERE { ?livre dc:title ?titre . ?livre dc:date ?annee . FILTER(?annee \u0026gt; \u0026#34;2009\u0026#34;^^xsd:gYear) } \u0026#34;\u0026#34;\u0026#34;, \u0026#34;Livres publiés après 2009\u0026#34;); // 4. Auteurs prolifiques executerRequete(modele, \u0026#34;\u0026#34;\u0026#34; PREFIX dc: \u0026lt;http://purl.org/dc/elements/1.1/\u0026gt; PREFIX foaf: \u0026lt;http://xmlns.com/foaf/0.1/\u0026gt; SELECT ?nomAuteur (COUNT(?livre) AS ?livresEcrits) WHERE { ?livre dc:creator ?auteur . ?auteur foaf:name ?nomAuteur . } GROUP BY ?nomAuteur HAVING (COUNT(?livre) \u0026gt; 1) \u0026#34;\u0026#34;\u0026#34;, \u0026#34;Auteurs ayant écrit plus d\u0026#39;un livre\u0026#34;); } private static void executerRequete(Model modele, String requeteString, String description) { System.out.println(description \u0026#43; \u0026#34; :\u0026#34;); Query requete = QueryFactory.create(requeteString); try (QueryExecution execution = QueryExecutionFactory.create(requete, modele)) { ResultSet resultats = execution.execSelect(); ResultSetFormatter.out(System.out, resultats, requete); System.out.println(); } catch (Exception e) { System.err.println(\u0026#34;Erreur lors de l\u0026#39;exécution de la requête : \u0026#34; \u0026#43; e.getMessage()); } } } Exécuter La constante DONNEES_RDF_XML contient les données RDF au format XML, embarquées directement dans le code. Elles décrivent trois livres bibliographiques en utilisant des vocabulaires standards : dc pour Dublin Core (titres, dates, éditeurs, créateurs), foaf pour les personnes (noms), et bibo pour les concepts bibliographiques (Book). Les dates sont typées en xsd:gYear pour une comparaison précise. Notez quelques ajustements par rapport à des versions précédentes, comme des références abrégées à des personnes existantes, ce qui enrichit les relations entre auteurs.\nDans la méthode main, un modèle vide est créé avec ModelFactory.createDefaultModel(), puis chargé via modele.read() en spécifiant le format \u0026ldquo;RDF/XML\u0026rdquo; et en utilisant un StringReader pour parser la chaîne embarquée.\nLe code exécute ensuite quatre requêtes SPARQL via la méthode executerRequete, qui affiche une description, crée la requête avec QueryFactory, l\u0026rsquo;exécute sur le modèle, et formate les résultats en tableau lisible.\nLa première requête liste tous les livres avec leurs titres et les noms des auteurs, triés par titre. La deuxième compte les livres par éditeur, avec un tri descendant sur le nombre. La troisième, corrigée avec le préfixe xsd et le type explicite, sélectionne les livres publiés après 2009 en comparant les années typées. La quatrième identifie les auteurs ayant contribué à plus d\u0026rsquo;un livre, grâce à GROUP BY, COUNT et HAVING.\nLa méthode executerRequete encapsule la logique d\u0026rsquo;exécution : création de la requête, ouverture d\u0026rsquo;une QueryExecution (fermée automatiquement via try-with-resources), récupération des résultats pour une requête SELECT, et affichage formaté. En cas d\u0026rsquo;erreur, un message clair est imprimé.\nActivité avec Java # Effectuez maintenant l\u0026rsquo;activité RDF avec Java. Vous devriez déjà avoir installé maven et Java à ce point-ci du cours.\n"},{"id":42,"href":"/orientee_donnees/docs/modules/e_module_services/serveurweb/","title":"Serveur Web Java","section":"Module Services et YAML","content":" Serveur Web Java # Le protocole HTTP (HyperText Transfer Protocol) est un protocole de communication standard utilisé pour transférer des données sur le web. Il définit comment les clients, tels que les navigateurs web, peuvent demander des ressources aux serveurs et comment ces derniers répondent. HTTP repose sur un modèle requête-réponse, où le client envoie une requête et le serveur renvoie une réponse.\nUne requête HTTP est une demande initiée par le client pour accéder à une ressource spécifique sur le serveur. Elle comprend généralement une méthode (GET, PUT, etc.), une URL pointant vers la ressource, des en-têtes contenant des informations supplémentaires (comme le type de contenu accepté), et parfois un corps pour les données envoyées. Le serveur traite la requête et renvoie une réponse avec un code de statut (par exemple, 200 pour succès, 404 pour non trouvé) et le contenu demandé.\nParmi les méthodes HTTP les plus courantes, GET est utilisée pour récupérer des données d’un serveur sans modifier l’état de la ressource : les paramètres sont appendus à l’URL sous forme de chaîne de requête, ce qui les rend visibles, limités en taille et propices à la mise en cache, mais moins sécurisés pour des informations sensibles ; elle est idempotente, c’est-à-dire que plusieurs appels identiques produisent le même résultat sans effet secondaire. À l’opposé, POST sert à envoyer des données au serveur pour créer ou mettre à jour une ressource, en plaçant les paramètres dans le corps de la requête, ce qui les rend invisibles dans l’URL, permet de transmettre des volumes plus importants (y compris des fichiers) et offre une meilleure confidentialité, bien que la sécurité réelle repose sur l’utilisation de HTTPS ; contrairement à GET, POST n’est pas idempotente et n’est généralement pas mise en cache. En pratique, on privilégie GET pour des opérations de lecture simples comme des recherches ou des filtres, et POST pour des soumissions de formulaires ou des envois de données confidentielles.\nIl arrive que l\u0026rsquo;on souhaite lancer rapidement un petit serveur web. Il est facile d\u0026rsquo;y arriver avec Java. Créez un fichier ExempleServeurFichiersSimple.java avec le contenu suivant, compilez et exécutez-le dans un dossier. Si le port 8000 n\u0026rsquo;est pas utilisé sur votre ordinateur vous aurez un serveur web fonctionnant sur votre machine. (Dans le cas contraire, remplacez le port 8000 par 8001 ou 8002.) Vous pouvez déposer des fichiers HTML dans ce répertoire et les chargez dans votre navigateur.\nimport com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.SimpleFileServer; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.file.Path; public class ExempleServeurFichiersSimple { public static void main(String[] args) throws IOException { int port = 8000; Path repertoireCourant = Path.of(\u0026#34;.\u0026#34;).toAbsolutePath(); // Répertoire courant HttpServer serveur = HttpServer.create(new InetSocketAddress(port), 0); serveur.createContext(\u0026#34;/\u0026#34;, SimpleFileServer.createFileHandler(repertoireCourant)); serveur.start(); System.out.println(\u0026#34;Serveur démarré sur le port \u0026#34; + port + \u0026#34;, servant les fichiers depuis \u0026#34; + repertoireCourant.toAbsolutePath()); System.out.println(\u0026#34;Accédez-y via http://localhost:\u0026#34; + port + \u0026#34;/\u0026#34;); } } Essayez de déposer ce dossier un fichier nommé test.html avec le contenu suivant.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Allo!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vous devriez pouvoir charger ce fichier dans votre navigateur.\nGestion des chemins avec createContext # La méthode createContext de la classe HttpServer permet de définir des gestionnaires pour des chemins spécifiques sur le serveur HTTP. Cela offre une flexibilité pour gérer différentes routes et répondre de manière appropriée selon l\u0026rsquo;URL demandée par le client. Pour créer un contexte, vous utilisez serveur.createContext(path, handler), où :\npath est la chaîne de caractères représentant le chemin (par exemple, \u0026ldquo;/hello\u0026rdquo;) handler est une implémentation de l\u0026rsquo;interface HttpHandler qui définit comment traiter les requêtes pour ce chemin Qu\u0026rsquo;est-ce qu\u0026rsquo;un HttpHandler ? # HttpHandler est une interface fonctionnelle définie dans le package com.sun.net.httpserver. Elle ne contient qu\u0026rsquo;une seule méthode abstraite : void handle(HttpExchange exchange) throws IOException. Cette méthode est appelée chaque fois qu\u0026rsquo;une requête HTTP correspond au chemin associé au contexte.\nL\u0026rsquo;objet HttpExchange passé en paramètre représente l\u0026rsquo;échange complet entre le client et le serveur. Il encapsule :\nLa requête entrante (méthode HTTP, URI, en-têtes, corps) La réponse sortante (code de statut, en-têtes, corps) Méthodes importantes de HttpExchange # getRequestMethod() : Retourne la méthode HTTP (GET, POST, etc.) getRequestURI() : Retourne l\u0026rsquo;URI de la requête getRequestHeaders() : Retourne les en-têtes de la requête sous forme de map getRequestBody() : Retourne un InputStream pour lire le corps de la requête sendResponseHeaders(int statusCode, long responseLength) : Envoie les en-têtes de réponse avec le code de statut getResponseBody() : Retourne un OutputStream pour écrire le corps de la réponse getResponseHeaders() : Retourne les en-têtes de réponse pour les modifier Exemple d\u0026rsquo;utilisation # Dans l\u0026rsquo;exemple ci-dessous, le gestionnaire vérifie la méthode de la requête et répond différemment selon qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un GET ou d\u0026rsquo;un POST :\nVoici un exemple simple où nous créons un contexte pour le chemin \u0026ldquo;/hello\u0026rdquo; qui renvoie une réponse texte :\nimport com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpExchange; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; public class ExempleServeurContext { public static void main(String[] args) throws IOException { int port = 8000; HttpServer serveur = HttpServer.create(new InetSocketAddress(port), 0); // Contexte pour la racine - sert les fichiers statiques serveur.createContext(\u0026#34;/\u0026#34;, SimpleFileServer.createFileHandler(Path.of(\u0026#34;.\u0026#34;).toAbsolutePath())); // Contexte personnalisé pour /hello serveur.createContext(\u0026#34;/hello\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String method = exchange.getRequestMethod(); String response; if (\u0026#34;GET\u0026#34;.equals(method)) { response = \u0026#34;Hello, World! (via GET)\u0026#34;; } else if (\u0026#34;POST\u0026#34;.equals(method)) { response = \u0026#34;Hello, World! (via POST)\u0026#34;; } else { response = \u0026#34;Méthode non supportée: \u0026#34; + method; exchange.sendResponseHeaders(405, response.length()); // Method Not Allowed OutputStream os = exchange.getResponseBody(); os.write(response.getBytes()); os.close(); return; } exchange.sendResponseHeaders(200, response.length()); OutputStream os = exchange.getResponseBody(); os.write(response.getBytes()); os.close(); } }); serveur.start(); System.out.println(\u0026#34;Serveur démarré sur le port \u0026#34; + port); } } Gestion des méthodes HTTP GET et PUT # Dans un serveur web, il est essentiel de gérer différentes méthodes HTTP pour implémenter des API RESTful. Les méthodes GET et PUT sont couramment utilisées :\nGET : Récupère des données depuis le serveur sans les modifier. Idempotente et mise en cache possible. PUT : Met à jour une ressource existante ou en crée une nouvelle à l\u0026rsquo;emplacement spécifié. Idempotente. Exemple d\u0026rsquo;implémentation # Voici un exemple de gestionnaire qui traite les requêtes GET et PUT pour un chemin \u0026ldquo;/api/data\u0026rdquo; :\nserveur.createContext(\u0026#34;/api/data\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String method = exchange.getRequestMethod(); String response; switch (method) { case \u0026#34;GET\u0026#34;: // Simuler la récupération de données response = \u0026#34;{\\\u0026#34;message\\\u0026#34;: \\\u0026#34;Données récupérées\\\u0026#34;, \\\u0026#34;data\\\u0026#34;: \\\u0026#34;valeur\\\u0026#34;}\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); exchange.sendResponseHeaders(200, response.length()); break; case \u0026#34;PUT\u0026#34;: // Lire le corps de la requête pour les données à mettre à jour InputStream is = exchange.getRequestBody(); String requestBody = new String(is.readAllBytes(), StandardCharsets.UTF_8); is.close(); // Traiter les données (ici, simplement les afficher) System.out.println(\u0026#34;Données reçues : \u0026#34; + requestBody); response = \u0026#34;{\\\u0026#34;message\\\u0026#34;: \\\u0026#34;Données mises à jour\\\u0026#34;, \\\u0026#34;received\\\u0026#34;: \u0026#34; + requestBody + \u0026#34;}\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); exchange.sendResponseHeaders(200, response.length()); break; default: response = \u0026#34;{\\\u0026#34;error\\\u0026#34;: \\\u0026#34;Méthode non supportée\\\u0026#34;}\u0026#34;; exchange.sendResponseHeaders(405, response.length()); break; } OutputStream os = exchange.getResponseBody(); os.write(response.getBytes(StandardCharsets.UTF_8)); os.close(); } }); Types MIME et exemples # Les types MIME (Multipurpose Internet Mail Extensions) sont des identificateurs standardisés qui spécifient le format des données transmises sur Internet. Ils permettent aux navigateurs et autres clients de savoir comment interpréter le contenu d\u0026rsquo;une réponse HTTP. Dans un serveur Java utilisant HttpServer, il est essentiel de définir correctement l\u0026rsquo;en-tête Content-Type pour garantir que le client traite la réponse de manière appropriée.\nDéfinition du Content-Type dans HttpServer # Pour définir le type MIME d\u0026rsquo;une réponse, utilisez la méthode getResponseHeaders().set() sur l\u0026rsquo;objet HttpExchange :\nexchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;type/sous-type\u0026#34;); Il est également recommandé d\u0026rsquo;ajouter l\u0026rsquo;encodage pour les types textuels :\nexchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html; charset=UTF-8\u0026#34;); Types MIME courants et exemples # Voici les types MIME les plus fréquemment utilisés avec des exemples.\n1. HTML (text/html) # Utilisé pour servir des pages web.\nserveur.createContext(\u0026#34;/page\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String html = \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, html.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(html.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); 2. JSON (application/json) # Pour les API REST et les échanges de données structurées.\nserveur.createContext(\u0026#34;/api/data\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String json = \u0026#34;{\\\u0026#34;message\\\u0026#34;: \\\u0026#34;Hello\\\u0026#34;, \\\u0026#34;status\\\u0026#34;: \\\u0026#34;success\\\u0026#34;}\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, json.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(json.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); 3. XML (application/xml ou text/xml) # Pour les données XML.\nserveur.createContext(\u0026#34;/api/xml\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String xml = \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34;?\u0026gt;\u0026lt;root\u0026gt;\u0026lt;message\u0026gt;Hello\u0026lt;/message\u0026gt;\u0026lt;/root\u0026gt;\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/xml; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, xml.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(xml.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); 4. Texte brut (text/plain) # Pour du texte simple.\nserveur.createContext(\u0026#34;/text\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String text = \u0026#34;Ceci est un texte brut.\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, text.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(text.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); 5. Images (image/png, image/jpeg, etc.) # Pour servir des images.\nserveur.createContext(\u0026#34;/image\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { // Simuler une image (en pratique, lisez depuis un fichier) byte[] imageData = \u0026#34;fake png data\u0026#34;.getBytes(); // Remplacer par de vraies données exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/png\u0026#34;); exchange.sendResponseHeaders(200, imageData.length); try (OutputStream os = exchange.getResponseBody()) { os.write(imageData); } } }); 6. CSS (text/css) # Pour les feuilles de style.\nserveur.createContext(\u0026#34;/style.css\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String css = \u0026#34;body { background-color: lightblue; }\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/css; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, css.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(css.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); 7. JavaScript (application/javascript) # Pour les scripts.\nserveur.createContext(\u0026#34;/script.js\u0026#34;, new HttpHandler() { @Override public void handle(HttpExchange exchange) throws IOException { String js = \u0026#34;console.log(\u0026#39;Hello from server!\u0026#39;);\u0026#34;; exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/javascript; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, js.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(js.getBytes(\u0026#34;UTF-8\u0026#34;)); } } }); "},{"id":43,"href":"/orientee_donnees/docs/modules/a_module_json/javascript/","title":"JavaScript et JSON","section":"Module JSON","content":" Introduction à JavaScript # JavaScript est un langage de programmation dynamique principalement utilisé pour le développement web côté client, mais aussi côté serveur grâce à des environnements comme Node.js. Si vous êtes déjà familiers avec Java, un langage statiquement typé et orienté objet classique, JavaScript peut sembler au premier abord déroutant en raison de son typage dynamique et de sa flexibilité extrême. Cependant, de nombreuses concepts que vous connaissez déjà en Java existent sous une forme similaire en JavaScript, même si leur implémentation diffère souvent.\nEn JavaScript, la déclaration de variables se fait principalement avec deux mots-clés : let et const.La différence principale entre let et const réside dans la réassignation : let permet de modifier la valeur de la variable après sa déclaration, tandis que const interdit toute réassignation (bien que pour les objets, les propriétés internes restent modifiables). Il est recommandé d\u0026rsquo;utiliser const par défaut et let uniquement quand une réassignation est nécessaire, en évitant complètement var dans le code moderne.\nVoici un exemple illustrant ces différences. La fonction console.log est équivalente à System.out.println en Java.\n// Exemple avec let : réassignation possible let age = 25; console.log(age); // 25 age = 26; // OK console.log(age); // 26 // Exemple avec const : réassignation interdite const nom = \u0026#34;Alice\u0026#34;; console.log(nom); // Alice // nom = \u0026#34;Bob\u0026#34;; // Erreur : Assignment to constant variable // Pour les objets avec const : propriétés modifiables, mais pas l\u0026#39;objet lui-même const personne = { nom: \u0026#34;Alice\u0026#34;, age: 25 }; personne.age = 26; // OK, modification d\u0026#39;une propriété console.log(personne); // { nom: \u0026#34;Alice\u0026#34;, age: 26 } // personne = { nom: \u0026#34;Bob\u0026#34;, age: 30 }; // Erreur : réassignation de l\u0026#39;objet Les fonctions occupent une place centrale en JavaScript, bien plus qu\u0026rsquo;en Java où elles sont toujours membres d\u0026rsquo;une classe. En JavaScript, les fonctions sont des citoyens de première classe : elles peuvent être assignées à des variables, passées en paramètres ou retournées par d\u0026rsquo;autres fonctions. Une fonction simple s\u0026rsquo;écrit function addition(a, b) { return a + b; } ou, de manière plus moderne, avec une flèche : const addition = (a, b) =\u0026gt; a + b;.\nVoici quelques exemples illustrant ces concepts.\n// Fonction assignée à une variable const multiplier = function(a, b) { return a * b; }; console.log(multiplier(3, 4)); // 12 // Fonction flèche const soustraire = (a, b) =\u0026gt; a - b; console.log(soustraire(10, 3)); // 7 // Fonction passée en paramètre function appliquerOperation(a, b, operation) { return operation(a, b); } console.log(appliquerOperation(5, 3, (x, y) =\u0026gt; x + y)); // 8 // Fonction retournée par une autre fonction (closure) function creerMultiplicateur(facteur) { return function(nombre) { return nombre * facteur; }; } const doubler = creerMultiplicateur(2); console.log(doubler(5)); // 10 Les objets en JavaScript sont fondamentalement différents des classes Java. Il n\u0026rsquo;y a pas de classes traditionnelles (avant ES6), mais des objets basés sur des prototypes. Chaque objet peut hériter directement d\u0026rsquo;un autre via sa chaîne de prototypes, ce qui remplace le système d\u0026rsquo;héritage par classes de Java. Depuis ES6, la syntaxe class a été introduite pour faciliter la transition des développeurs venant de langages comme Java, mais sous le capot, il s\u0026rsquo;agit toujours d\u0026rsquo;héritage prototypal.\nVous pouvez créer un objet de manière littérale très simplement : const personne = { nom: \u0026quot;Dupont\u0026quot;, age: 30 };. Pour ajouter une fonction (appelée méthode lorsqu\u0026rsquo;elle est dans un objet), il suffit d\u0026rsquo;ajouter une propriété qui contient une fonction : personne.saluer = function() { console.log(\u0026quot;Bonjour, je m'appelle \u0026quot; + this.nom); }; ou, avec la syntaxe moderne : const personne = { nom: \u0026quot;Dupont\u0026quot;, age: 30, saluer() { console.log(\\Bonjour, je m\u0026rsquo;appelle ${this.nom}`); } };. L'appel se fait ensuite avec personne.saluer();`.\nEn JavaScript, les chaînes de caractères peuvent être définies avec des guillemets simples ('texte') ou doubles (\u0026quot;texte\u0026quot;). Depuis ES6, les littéraux de gabarit (template literals) permettent d\u0026rsquo;intégrer des expressions directement dans les chaînes en utilisant des backticks (`) et la syntaxe ${expression}.\nCette syntaxe ${personne.nom} habite à ${personne.ville} est un exemple de littéral de gabarit. Elle permet d\u0026rsquo;insérer la valeur d\u0026rsquo;une variable ou le résultat d\u0026rsquo;une expression directement dans la chaîne, sans avoir à utiliser la concaténation avec l\u0026rsquo;opérateur +.\nVoici des exemples comparatifs :\nconst personne = { nom: \u0026#34;Alice\u0026#34;, age: 25, ville: \u0026#34;Paris\u0026#34; }; // Concaténation traditionnelle (comme en Java) const message1 = \u0026#34;Bonjour, je m\u0026#39;appelle \u0026#34; + personne.nom + \u0026#34; et j\u0026#39;ai \u0026#34; + personne.age + \u0026#34; ans.\u0026#34;; console.log(message1); // Bonjour, je m\u0026#39;appelle Alice et j\u0026#39;ai 25 ans. // Littéral de gabarit (plus moderne et lisible) const message2 = `Bonjour, je m\u0026#39;appelle ${personne.nom} et j\u0026#39;ai ${personne.age} ans.`; console.log(message2); // Bonjour, je m\u0026#39;appelle Alice et j\u0026#39;ai 25 ans. // Avec des expressions const message3 = `${personne.nom} habite à ${personne.ville.toUpperCase()} et a ${personne.age + 5} ans dans 5 ans.`; console.log(message3); // Alice habite à PARIS et a 30 ans dans 5 ans. // Chaînes multi-lignes const messageMultiligne = `Ceci est une chaîne sur plusieurs lignes sans avoir à utiliser \\n`; console.log(messageMultiligne); La gestion des erreurs en JavaScript repose sur les exceptions comme en Java, avec try, catch et finally.\ntry { let resultat = 10 / 0; throw new Error(\u0026#34;Quelque chose s\u0026#39;est mal passé\u0026#34;); } catch (erreur) { console.error(\u0026#34;Erreur capturée :\u0026#34;, erreur.message); } finally { console.log(\u0026#34;Ce bloc s\u0026#39;exécute toujours\u0026#34;); } Une autre exemple courant avec une fonction.\nfunction diviser(a, b) { if (b === 0) throw new Error(\u0026#34;Division par zéro\u0026#34;); return a / b; } try { diviser(10, 0); } catch (e) { console.log(\u0026#34;Impossible :\u0026#34;, e.message); } JavaScript est très permissif sur les égalités : == effectue des conversions de type implicites (souvent source de bugs), tandis que === compare sans conversion, ce qui est l\u0026rsquo;équivalent de la comparaison stricte en Java. De même, les valeurs truthy/falsy (comme \u0026quot;\u0026quot;, 0, null, undefined) se comportent différemment des booléens stricts.\nVoici des exemples illustrant ces comportements.\n// Différence entre == et === console.log(1 == \u0026#34;1\u0026#34;); // true (conversion implicite : string \u0026#34;1\u0026#34; devient number 1) console.log(1 === \u0026#34;1\u0026#34;); // false (pas de conversion : types différents) console.log(0 == false); // true (conversion : false devient 0) console.log(0 === false); // false (types différents : number vs boolean) console.log(null == undefined); // true (égalité spéciale pour null/undefined) console.log(null === undefined); // false (types différents) // Valeurs falsy (considérées comme false dans les conditions) console.log(\u0026#34;Valeurs falsy :\u0026#34;); if (\u0026#34;\u0026#34;) console.log(\u0026#34;Chaîne vide\u0026#34;); else console.log(\u0026#34;Chaîne vide est falsy\u0026#34;); if (0) console.log(\u0026#34;Zéro\u0026#34;); else console.log(\u0026#34;0 est falsy\u0026#34;); if (null) console.log(\u0026#34;Null\u0026#34;); else console.log(\u0026#34;null est falsy\u0026#34;); if (undefined) console.log(\u0026#34;Undefined\u0026#34;); else console.log(\u0026#34;undefined est falsy\u0026#34;); if (false) console.log(\u0026#34;False\u0026#34;); else console.log(\u0026#34;false est falsy\u0026#34;); if (NaN) console.log(\u0026#34;NaN\u0026#34;); else console.log(\u0026#34;NaN est falsy\u0026#34;); // Valeurs truthy (considérées comme true dans les conditions) console.log(\u0026#34;Valeurs truthy :\u0026#34;); if (\u0026#34;hello\u0026#34;) console.log(\u0026#34;Chaîne non vide : truthy\u0026#34;); if (42) console.log(\u0026#34;Nombre positif : truthy\u0026#34;); if ([]) console.log(\u0026#34;Array vide : truthy (attention !)\u0026#34;); if ({}) console.log(\u0026#34;Objet vide : truthy\u0026#34;); Activité de mise en pratique # Vous pouvez tester votre compréhension de la syntaxe avec la console suivante.\nConsole JavaScript \u003e Exécuter Remettre à zéro Questions de révision # Testez vos connaissances avec ces questions. Cliquez sur chaque question pour voir la réponse.\nQuelle est la différence principale entre let et const en JavaScript ? let permet la réassignation de la variable après sa déclaration, tandis que const l'interdit. Cependant, pour les objets déclarés avec const, les propriétés internes peuvent être modifiées.\nComment déclare-t-on une fonction en JavaScript ? Donnez deux syntaxes. Avec la syntaxe traditionnelle : function nomFonction(parametres) { corps }. Avec les fonctions flèches (ES6) : const nomFonction = (parametres) =\u003e corps.\nQue signifie \"les fonctions sont des citoyens de première classe\" en JavaScript ? Cela signifie que les fonctions peuvent être assignées à des variables, passées en paramètres à d'autres fonctions, et retournées par des fonctions, comme n'importe quelle autre valeur.\nComment créer un objet en JavaScript de manière littérale ? Avec la syntaxe : const objet = { propriete1: valeur1, propriete2: valeur2, methode() { code } };\nQuelle est la différence entre == et === en JavaScript ? == effectue des conversions de type implicites avant la comparaison (souvent source de bugs), tandis que === compare les valeurs et les types sans conversion.\nQuelles sont les valeurs \"falsy\" en JavaScript ? Les valeurs falsy sont : \"\" (chaîne vide), 0, null, undefined, false, et NaN. Elles sont considérées comme false dans les conditions.\nComment gérer les erreurs en JavaScript ? Avec les blocs try, catch, et finally. On lance des erreurs avec throw new Error(\"message\"), et on les capture dans catch(erreur).\nQuelle est la différence entre l'héritage par classes (Java) et l'héritage prototypal (JavaScript) ? En Java, l'héritage se fait par classes avec extends. En JavaScript, les objets héritent directement d'autres objets via leur chaîne de prototypes, sans classes traditionnelles (bien que ES6 introduise la syntaxe class).\nComment utiliser une fonction flèche avec plusieurs paramètres ? const fonction = (param1, param2) =\u003e { return resultat; }; ou pour une expression simple : const fonction = (param1, param2) =\u003e resultat;.\nQue se passe-t-il si on compare null et undefined avec == et === ? Avec == : null == undefined retourne true (égalité spéciale). Avec === : null === undefined retourne false (types différents).\nVidéo suggérée # JSON et JavaScript # En JavaScript, JSON est nativement supporté grâce aux méthodes JSON.stringify() pour convertir des objets JavaScript en chaînes JSON, et JSON.parse() pour analyser des chaînes JSON et les convertir en objets JavaScript.\nVoici quelques exemples pratiques illustrant comment générer et consommer du JSON en JavaScript.\nGénération de JSON # Pour convertir un objet JavaScript en une chaîne JSON, utilisez JSON.stringify(). Cette méthode prend un objet en paramètre et retourne sa représentation JSON sous forme de chaîne.\n// Exemple avec un objet simple const personne = { nom: \u0026#34;Dupont\u0026#34;, age: 30, ville: \u0026#34;Paris\u0026#34;, hobbies: [\u0026#34;lecture\u0026#34;, \u0026#34;sport\u0026#34;] }; const jsonString = JSON.stringify(personne); console.log(jsonString); // Sortie : {\u0026#34;nom\u0026#34;:\u0026#34;Dupont\u0026#34;,\u0026#34;age\u0026#34;:30,\u0026#34;ville\u0026#34;:\u0026#34;Paris\u0026#34;,\u0026#34;hobbies\u0026#34;:[\u0026#34;lecture\u0026#34;,\u0026#34;sport\u0026#34;]} Vous pouvez également formater le JSON pour une meilleure lisibilité en ajoutant des espaces :\nconst jsonPretty = JSON.stringify(personne, null, 2); console.log(jsonPretty); /* Sortie : { \u0026#34;nom\u0026#34;: \u0026#34;Dupont\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;ville\u0026#34;: \u0026#34;Paris\u0026#34;, \u0026#34;hobbies\u0026#34;: [ \u0026#34;lecture\u0026#34;, \u0026#34;sport\u0026#34; ] } */ Consommation de JSON # Pour analyser une chaîne JSON et la convertir en objet JavaScript, utilisez JSON.parse(). Cette méthode prend une chaîne JSON valide et retourne l\u0026rsquo;objet JavaScript correspondant.\n// Exemple avec une chaîne JSON const jsonData = \u0026#39;{\u0026#34;nom\u0026#34;:\u0026#34;Martin\u0026#34;,\u0026#34;age\u0026#34;:25,\u0026#34;ville\u0026#34;:\u0026#34;Lyon\u0026#34;,\u0026#34;actif\u0026#34;:true}\u0026#39;; const objet = JSON.parse(jsonData); console.log(objet.nom); // Martin console.log(objet.age); // 25 console.log(objet.actif); // true Attention : si la chaîne JSON n\u0026rsquo;est pas valide, JSON.parse() lèvera une exception SyntaxError. Il est donc recommandé d\u0026rsquo;utiliser un bloc try...catch :\ntry { const donnees = JSON.parse(jsonData); console.log(\u0026#34;Données analysées :\u0026#34;, donnees); } catch (erreur) { console.error(\u0026#34;Erreur de parsing JSON :\u0026#34;, erreur.message); } Exemples avec des tableaux # JSON peut également représenter des tableaux. Voici un exemple complet :\n// Génération d\u0026#39;un tableau d\u0026#39;objets en JSON const personnes = [ { nom: \u0026#34;Alice\u0026#34;, age: 28, ville: \u0026#34;Marseille\u0026#34; }, { nom: \u0026#34;Bob\u0026#34;, age: 32, ville: \u0026#34;Toulouse\u0026#34; }, { nom: \u0026#34;Charlie\u0026#34;, age: 45, ville: \u0026#34;Nice\u0026#34; } ]; const jsonArray = JSON.stringify(personnes); console.log(jsonArray); // Sortie : [{\u0026#34;nom\u0026#34;:\u0026#34;Alice\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;ville\u0026#34;:\u0026#34;Marseille\u0026#34;},{\u0026#34;nom\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:32,\u0026#34;ville\u0026#34;:\u0026#34;Toulouse\u0026#34;},{\u0026#34;nom\u0026#34;:\u0026#34;Charlie\u0026#34;,\u0026#34;age\u0026#34;:45,\u0026#34;ville\u0026#34;:\u0026#34;Nice\u0026#34;}] // Consommation du JSON const parsedArray = JSON.parse(jsonArray); parsedArray.forEach(personne =\u0026gt; { console.log(`${personne.nom} habite à ${personne.ville}`); }); // Sortie : // Alice habite à Marseille // Bob habite à Toulouse // Charlie habite à Nice Mise à l\u0026rsquo;essai # Utilisez la console suivante pour tester vos programmes JavaScript.\nExécuter le code Console prête. Écrivez du code et cliquez sur \"Exécuter le code\". // Exemple de code JavaScript console.log(\"Bonjour le monde !\"); for (let i = 1; i Vidéo suggérée # Activités suggérées # Pour appliquer les concepts de JSON en JavaScript, voici 5 activités pratiques à réaliser :\nCréation et sérialisation d\u0026rsquo;un objet : Définissez un objet JavaScript représentant un étudiant (nom, âge, notes sous forme de tableau). Utilisez JSON.stringify() pour le convertir en chaîne JSON et affichez-le dans la console.\nParsing d\u0026rsquo;une chaîne JSON : Créez une chaîne JSON représentant une liste de produits (nom, prix, catégorie). Utilisez JSON.parse() pour la convertir en objet, puis parcourez le tableau pour afficher chaque produit.\nManipulation de données JSON imbriquées : Définissez un objet complexe avec des objets imbriqués (par exemple, une entreprise avec des employés, chacun ayant un poste et un salaire). Convertissez-le en JSON, puis parsez-le et modifiez une valeur avant de le reconvertir.\nGestion d\u0026rsquo;erreurs de parsing : Écrivez un script qui tente de parser différentes chaînes JSON, certaines valides et d\u0026rsquo;autres non. Utilisez un bloc try...catch pour gérer les erreurs et afficher des messages appropriés.\nSimulation d\u0026rsquo;une API REST : Créez une fonction qui simule une réponse d\u0026rsquo;API en retournant une chaîne JSON. Écrivez ensuite du code qui \u0026ldquo;fetch\u0026rdquo; cette donnée, la parse, et affiche les informations dans une liste HTML en manipulant le DOM.\nInstallation et essai de Node.js (optionnel) : JavaScript n\u0026rsquo;est pas limité au navigateur ! Installez Node.js, l\u0026rsquo;environnement d\u0026rsquo;exécution JavaScript côté serveur. Téléchargez la dernière version depuis le site officiel (nodejs.org), installez-la, puis ouvrez un terminal et tapez node -v pour vérifier l\u0026rsquo;installation. Créez ensuite un fichier test.js avec du code simple (par exemple, console.log(\u0026quot;Hello from Node.js!\u0026quot;);), et exécutez-le avec node test.js.\n"},{"id":44,"href":"/orientee_donnees/docs/modules/a_module_json/jq/","title":"Activité avec jq","section":"Module JSON","content":" Laboratoire pratique avec jq # jq est un puissant processeur de données JSON en ligne de commande, conçu pour manipuler, filtrer et transformer des fichiers JSON de manière efficace et expressive. Inspiré des outils Unix comme sed et awk, jq permet aux développeurs et analystes de données de travailler avec des structures JSON complexes sans écrire de code complexe. Que ce soit pour extraire des valeurs spécifiques, reformater des données, ou effectuer des requêtes avancées, jq offre une syntaxe concise et fonctionnelle qui s\u0026rsquo;intègre parfaitement dans les pipelines shell.\nAu-delà de ses capacités de base, jq excelle dans le traitement de gros volumes de données JSON, supportant des opérations comme le filtrage conditionnel, les agrégations, et les transformations structurelles. Il est particulièrement utile pour l\u0026rsquo;analyse de logs, le traitement d\u0026rsquo;APIs REST, ou la préparation de données pour d\u0026rsquo;autres outils. Grâce à sa nature fonctionnelle, les requêtes jq peuvent être composées et réutilisées, faisant de cet outil un incontournable pour quiconque travaille régulièrement avec du JSON dans un environnement de développement ou de production.\nInstallation sur Windows # Il y a plusieurs méthodes. Voici les deux plus simples pour un débutant.\nMéthode 1 – La plus simple : télécharger l’exécutable officiel # Ouvrez votre navigateur et allez ici : https://github.com/jqlang/jq/releases\nDescendez à la dernière version.\nSous “Assets”, cliquez sur le fichier jq-win64.exe. Il est possible que vous deviez chercher un peu, le fichier est bel est bien présent.\nLe fichier se télécharge (environ 3-4 Mo).\nRenommez-le pour plus de simplicité : cliquez droit sur le fichier → Renommer → appelez-le simplement jq.exe\nDéplacez-le dans un dossier facile d’accès\nCréez un dossier par exemple C:\\jq et mettez-y le fichier jq.exe.\nAjoutez ce dossier au PATH (c’est ce qui permet de taper jq depuis n’importe où)\na. Cliquez droit sur “Ce PC” (ou “Ordinateur”) → Propriétés\nb. Cliquez sur “Paramètres système avancés” (à droite)\nc. Cliquez sur “Variables d’environnement”\nd. Dans la partie “Variables système” (en bas), trouvez la ligne “Path” → cliquez sur Modifier\ne. Cliquez sur “Nouveau” → tapez C:\\jq → OK → OK → OK\nFermez et rouvrez votre terminal (Invite de commandes ou PowerShell).\nTapez :\njq --version Si vous voyez la version s’afficher → c’est bon !\nMéthode 2 – Avec Winget # Si vous avez Windows 10 ou 11 ou mieux :\nOuvrez PowerShell ou l’Invite de commandes en tant qu’administrateur (clic droit → Exécuter en tant qu’administrateur). Tapez cette commande : winget install jqlang.jq Appuyez sur Entrée, acceptez si on vous demande. Une fois terminé, ouvrez un nouveau terminal (normal, pas admin) et tapez : jq --version Méthode 3 – Avec Chocolatey # Ouvrez PowerShell en administrateur. Installez Chocolatey (une seule fois) : Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Puis installez jq : choco install jq Installation sur macOS # Méthode recommandée et la plus simple : Homebrew # Ouvrir le Terminal\nAppuyez sur Cmd + Espace, tapez Terminal et appuyez sur Entrée.\nInstallez Homebrew (c’est un gestionnaire de paquets, comme un “App Store” en ligne de commande)\nCopiez-collez cette ligne dans le Terminal et appuyez sur Entrée :\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Il va vous demander votre mot de passe (vous ne verrez pas les étoiles quand vous tapez, c’est normal). Appuyez sur Entrée quand il vous le demande pour continuer. Ça prend 2 à 5 minutes selon votre connexion. Une fois Homebrew installé, installez jq en une seule commande\nbrew install jq Vérifiez que ça fonctionne\nTapez cette commande et appuyez sur Entrée :\njq --version Vous devriez voir quelque chose comme jq-1.7 ou jq-1.7.1.\nC’est fini ! Vous avez jq sur votre Mac.\nMéthode sans Homebrew # Vous pouvez télécharger la version pré-compilée directement :\nAllez sur cette page : https://github.com/jqlang/jq/releases Descendez jusqu’à la dernière version (en haut). Sous “Assets”, cliquez sur le fichier qui s’appelle jq-macos-arm64 (si vous avez un Mac M1/M2/M3/\u0026hellip;) ou jq-macos-amd64 (si vous avez un Mac Intel plus ancien). Le fichier se télécharge (il fait ~3 Mo). Ouvrez le Terminal, allez dans votre dossier Téléchargements : cd ~/Downloads Rendez-le exécutable et déplacez-le au bon endroit : chmod +x jq-macos-arm64 sudo mv jq-macos-arm64 /usr/local/bin/jq (Il vous demandera votre mot de passe pour sudo). Vérifiez avec jq --version. Premier test rapide # Copiez-collez ceci dans votre terminal :\necho \u0026#39;{\u0026#34;utilisateur\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;ville\u0026#34;: \u0026#34;Paris\u0026#34;}\u0026#39; | jq \u0026#39;.utilisateur\u0026#39; Vous devriez voir s’afficher :\n\u0026#34;Alice\u0026#34; Si vous voyez ça → bravo, jq est parfaitement installé !\nSyntaxe des requêtes jq # jq utilise un langage de programmation fonctionnel pour manipuler les données JSON. Les requêtes jq sont composées d\u0026rsquo;expressions qui transforment l\u0026rsquo;entrée JSON en sortie JSON. L\u0026rsquo;opérateur principal est le point . pour accéder aux propriétés, similaire à l\u0026rsquo;accès aux objets en JavaScript. Par exemple, .nom extrait la valeur de la clé \u0026ldquo;nom\u0026rdquo; d\u0026rsquo;un objet.\nLes requêtes peuvent être chaînées avec le pipe |, permettant de composer des transformations complexes. Par exemple, .bibliotheque.livres[] | .titre parcourt d\u0026rsquo;abord le tableau des livres, puis extrait le titre de chaque livre. Cette approche fonctionnelle rend jq puissant pour filtrer, transformer et agréger des données JSON.\njq supporte différents types d\u0026rsquo;expressions : sélecteurs pour naviguer dans la structure, filtres pour sélectionner des éléments, et constructeurs pour créer de nouveaux objets. Les tableaux sont gérés avec [] pour itérer, et les conditions utilisent select() pour filtrer. Par exemple, select(.prix \u0026lt; 20) garde seulement les objets où le prix est inférieur à 20.\nLes transformations permettent de reconstruire les données. Utilisez {clé: valeur} pour créer des objets, ou [expression] pour des tableaux. Les variables temporaires avec as $var facilitent les références. Par exemple, .titre as $t | .auteur | \u0026quot;\\($t) par \\(.auteur)\u0026quot; combine titre et auteur dans une chaîne.\nEnfin, jq offre des fonctions intégrées pour les agrégations comme length, min, max, et des opérations sur les chaînes et nombres. Pour les données manquantes, l\u0026rsquo;opérateur // fournit des valeurs par défaut. Ces fonctionnalités font de jq un outil essentiel pour le traitement de données JSON en ligne de commande.\nJeu de données utilisé # Créez un fichier bibliotheque.json :\n{ \u0026#34;bibliotheque\u0026#34;: { \u0026#34;nom\u0026#34;: \u0026#34;Médiathèque centrale\u0026#34;, \u0026#34;livres\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b001\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;1984\u0026#34;, \u0026#34;auteur\u0026#34;: \u0026#34;George Orwell\u0026#34;, \u0026#34;année\u0026#34;: 1949, \u0026#34;genres\u0026#34;: [\u0026#34;dystopie\u0026#34;, \u0026#34;politique\u0026#34;], \u0026#34;empruntable\u0026#34;: true, \u0026#34;emprunts\u0026#34;: [ {\u0026#34;date\u0026#34;: \u0026#34;2024-01-15\u0026#34;, \u0026#34;lecteur\u0026#34;: \u0026#34;Alice\u0026#34;}, {\u0026#34;date\u0026#34;: \u0026#34;2025-03-20\u0026#34;, \u0026#34;lecteur\u0026#34;: \u0026#34;Bob\u0026#34;} ] }, { \u0026#34;id\u0026#34;: \u0026#34;b002\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;Le Petit Prince\u0026#34;, \u0026#34;auteur\u0026#34;: \u0026#34;Antoine de Saint-Exupéry\u0026#34;, \u0026#34;année\u0026#34;: 1943, \u0026#34;genres\u0026#34;: [\u0026#34;conte\u0026#34;], \u0026#34;empruntable\u0026#34;: false }, { \u0026#34;id\u0026#34;: \u0026#34;b003\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;Fondation\u0026#34;, \u0026#34;auteur\u0026#34;: \u0026#34;Isaac Asimov\u0026#34;, \u0026#34;année\u0026#34;: 1951, \u0026#34;genres\u0026#34;: [\u0026#34;science-fiction\u0026#34;, \u0026#34;cycle\u0026#34;], \u0026#34;empruntable\u0026#34;: true, \u0026#34;prix\u0026#34;: 18.90 } ] } } Vidéo suggérée # Exercices # Exercice 1 – Affichage brut et pretty-print # jq . bibliotheque.json # équivalent cat jq \u0026#39;.\u0026#39; bibliotheque.json # plus lisible Exercice 2 – Sélection simple (équivalent XPath absolu) # # Tous les titres de livres jq \u0026#39;.bibliotheque.livres[].titre\u0026#39; bibliotheque.json # Le nom de la bibliothèque jq \u0026#39;.bibliotheque.nom\u0026#39; bibliotheque.json Exercice 3 – Parcours de tableau avec [] (comme // en XPath) # # Tous les auteurs jq \u0026#39;.bibliotheque.livres[].auteur\u0026#39; bibliotheque.json # Tous les genres (aplatissement automatique) jq \u0026#39;.bibliotheque.livres[].genres[]\u0026#39; bibliotheque.json Exercice 4 – Filtrage avec select() (comme [condition] en XPath) # # Livres publiés après 1950 jq \u0026#39;.bibliotheque.livres[] | select(.année \u0026gt; 1950)\u0026#39; bibliotheque.json # Livres empruntables jq \u0026#39;.bibliotheque.livres[] | select(.empruntable == true)\u0026#39; bibliotheque.json # Livres contenant \u0026#34;fiction\u0026#34; dans les genres jq \u0026#39;.bibliotheque.livres[] | select(.genres[] | contains(\u0026#34;fiction\u0026#34;))\u0026#39; bibliotheque.json Exercice 5 – Projection / construction de nouveaux objets (comme XSLT) # # Liste simplifiée : titre + année jq \u0026#39;.bibliotheque.livres[] | {titre, année}\u0026#39; bibliotheque.json # Créer un catalogue avec id comme clé jq \u0026#39;.bibliotheque.livres | map({key: .id, value: {titre, auteur}}) | from_entries\u0026#39; bibliotheque.json Exercice 6 – Agrégations (length, min, max, group_by…) # # Nombre total de livres jq \u0026#39;[.bibliotheque.livres[]] | length\u0026#39; bibliotheque.json # Année la plus ancienne jq \u0026#39;[.bibliotheque.livres[].année] | min\u0026#39; bibliotheque.json # Regrouper par première lettre du titre jq \u0026#39;.bibliotheque.livres | group_by(.titre[0:1]) | map({lettre: .[0].titre[0:1], count: length})\u0026#39; bibliotheque.json Exercice 7 – Gestion des valeurs optionnelles (comme if en XQuery) # # Afficher le prix, ou \u0026#34;non vendu\u0026#34; s\u0026#39;il n’existe pas jq \u0026#39;.bibliotheque.livres[] | .titre as $t | .prix // \u0026#34;non vendu\u0026#34; | \u0026#34;\\($t) : \\(.)\u0026#34;\u0026#39; bibliotheque.json Exercice 8 – Transformation complète (votre premier \u0026ldquo;XSLT JSON\u0026rdquo;) # Créer un fichier catalogue-court.json contenant seulement :\n[ {\u0026#34;id\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;titre\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;auteur\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;disponible\u0026#34;: true/false} ] Solution en une ligne :\njq \u0026#39;[ .bibliotheque.livres[] | {id, titre, auteur, disponible: .empruntable}]\u0026#39; bibliotheque.json \u0026gt; catalogue-court.json Exercice 9 – Bonus : jq comme greppel pour logs JSON # # Supposons un log d’accès au format JSON par ligne JSON cat access.log | jq \u0026#39;select(.status == 404) | .ip + \u0026#34; \u0026#34; + .url\u0026#39; Mini-projet # À partir de bibliotheque.json, produisez un fichier rapport.md en Markdown contenant :\nLe nom de la bibliothèque en titre Un tableau Markdown avec : Titre | Auteur | Année | Genres | Empruntable | Nombre d’emprunts (0 si absent) Le nombre total de livres et le nombre de livres empruntables Exemple de solution (à adapter) :\necho \u0026#34;# Rapport $(jq -r \u0026#39;.bibliotheque.nom\u0026#39; bibliotheque.json)\u0026#34; \u0026gt; rapport.md echo \u0026#34;\u0026#34; \u0026gt;\u0026gt; rapport.md echo \u0026#34;| Titre | Auteur | Année | Genres | Empruntable | Nb emprunts |\u0026#34; \u0026gt;\u0026gt; rapport.md echo \u0026#34;|-------|--------|------|--------|-------------|-------------|\u0026#34; \u0026gt;\u0026gt; rapport.md jq -r \u0026#39;.bibliotheque.livres[] | .emprunts // [] | { titre: .titre, auteur, année, genres: (.genres | join(\u0026#34;, \u0026#34;)), empruntable, nb: length } | \u0026#34;| \\(titre) | \\(auteur) | \\(année) | \\(genres) | \\(empruntable) | \\(nb) |\u0026#34;\u0026#39; bibliotheque.json \u0026gt;\u0026gt; rapport.md echo -e \u0026#34;\\nTotal livres : $(jq \u0026#39;[.bibliotheque.livres[]] | length\u0026#39; bibliotheque.json)\u0026#34; \u0026gt;\u0026gt; rapport.md echo \u0026#34;Empruntables : $(jq \u0026#39;[.bibliotheque.livres[] | select(.empruntable)] | length\u0026#39; bibliotheque.json)\u0026#34; \u0026gt;\u0026gt; rapport.md "},{"id":45,"href":"/orientee_donnees/docs/modules/b_module_xml/valid/autoevaluation_dtd/","title":"Autoévaluation","section":"Validation","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Rappel : L'environnement web du cours transforme parfois automatiquement les adresses web (URL) en lien. L'environnement du cours met aussi en forme certains guillemets et apostrophes. Il n'est possible pour le professeur de corriger ce comportement (il n'est pas possible de changer l'environnement) et vous devez l'ignorer lors de votre lecture. Par ailleurs, si vous copiez-collez du contenu des exercices et des exemples, vous devez adapter le code manuellement. Question 1 . Combien de DTD peut avoir un document XML? Choisissez la bonne réponse parmi les suivantes. Une seule. (Réponse correcte!) Par contre, il peut y avoir une partie interne à la DTD, c'est-à-dire une partie qui est écrite dans le document XML lui-même. Le tout (DTD externe et interne) forme une seule DTD. Autant qu'on veut. (Réponse incorrecte!) Non. Question 2 . Il est nécessaire d'avoir une définition de type de document, par exemple un document DTD, pour déterminer si un document XML est valide. Choisissez la bonne réponse parmi les suivantes. Vrai. (Réponse correcte!) Un document est dit valide s'il est bien formé et respecte sa DTD. Faux. (Réponse incorrecte!) On peut seulement vérifier qu'il est bien formé. Question 3 . Qu'est-ce qu'une DTD interne? Choisissez la bonne réponse parmi les suivantes. Une DTD qui a été conçue à l'interne, dans une compagnie ou institution. (Réponse incorrecte!) Incorrect. La provenance de la DTD est sans conséquence. Une DTD qui apparaît dans le document XML entre des crochets. (Réponse correcte!) Correct. Question 4 . Quel symbole est utilisé dans les DTD pour signifier qu'un élément est optionnel, c'est-à-dire qu'on peut en trouver un ou aucun? Choisissez la bonne réponse parmi les suivantes. ? (Réponse correcte!) Oui. * (Réponse incorrecte!) Non. + (Réponse incorrecte!) Non. | (Réponse incorrecte!) Non. Question 5 . Quel symbole est utilisé dans les DTD pour signifier qu'un élément peut ne pas apparaître, n'apparaître qu'une fois ou apparaître plusieurs fois? Choisissez la bonne réponse parmi les suivantes. ? (Réponse incorrecte!) Non. * (Réponse correcte!) Oui. + (Réponse incorrecte!) Non. | (Réponse incorrecte!) Non. Question 6 . Quel symbole est utilisé dans les DTD pour signifier qu'un élément doit apparaître au moins une fois? Choisissez la bonne réponse parmi les suivantes. ? (Réponse incorrecte!) Non. * (Réponse incorrecte!) Non. + (Réponse correcte!) Oui. | (Réponse incorrecte!) Non. Question 7 . Quel symbole est utilisé dans les DTD pour signifier qu'un élément ou un autre peut apparaître? Choisissez la bonne réponse parmi les suivantes. ? (Réponse incorrecte!) Non. * (Réponse incorrecte!) Non. + (Réponse incorrecte!) Non. | (Réponse correcte!) Oui. Question 8 . Combien d'éléments « nom » peut contenir un document XML qui débute ainsi : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; ]\u0026gt; Choisissez la bonne réponse parmi les suivantes. Au moins un. (Réponse incorrecte!) Non. 1 (Réponse incorrecte!) Non. 2 (Réponse correcte!) Effectivement. La déclaration de type de document nous indique que l'élément-racine est « cheque » et que l'élement « cheque » doit contenir exactement un élément « recipiendaire » et un élément « emetteur », chacun contenant exactement un élément « nom ». 3 (Réponse incorrecte!) Non. 3 ou plus (Réponse incorrecte!) Non. Question 9 . Soit le document DTD suivant, disponible à l'adresse « http://www.mondomain.com/madtd.dtd ». Dites quels documents XML sont valides . \u0026lt;!ELEMENT etudiant (nom, numero, cours*)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT numero (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cours (#PCDATA)\u0026gt; Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;\u0026lt;/nom\u0026gt;\u0026lt;numero\u0026gt;\u0026lt;/numero\u0026gt; \u0026lt;/etudiant\u0026gt; Oui. Ce document est valide, car l'astérisque (*) permet d'avoir zéro ou plusieurs balises « cours ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Jean \u0026lt;gras\u0026gt;B\u0026lt;/gras\u0026gt; Pearson\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;12\u0026lt;/numero\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; Non, la balise \u0026lt;nom\u0026gt; ne peut contenir que du texte et aucune balise. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE nom SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Jean Pearson\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;12\u0026lt;/numero\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; Non, la déclaration de type de document indique que la racine doit être une balise de type « nom ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE nom SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;nom\u0026gt;Jean Pearson\u0026lt;/nom\u0026gt; Oui. On utilise bien l'élément « nom » comme élément-racine et il est défini dans la DTD. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Réjean Bougon\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;3156\u0026lt;/numero\u0026gt; \u0026lt;cours\u0026gt;Introduction à l'arithmétique\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; Oui. L'astérisque permet d'avoir plusieurs éléments « cours ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;nom\u0026gt;Réjean Bougon\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;3156\u0026lt;/numero\u0026gt; \u0026lt;/etudiant\u0026gt; Non. Il faut que les éléments apparaissent dans l'ordre : nom, numero et cours. Question 10 . Soit le document DTD suivant, disponible à l'adresse « http://www.mondomain.com/madtd.dtd ». Dites quels documents XML sont valides . \u0026lt;!ELEMENT etudiant (nom, numero, cours+)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT numero (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cours (#PCDATA)\u0026gt; Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Jean Pearson\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;12\u0026lt;/numero\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;Introduction à l'informatique\u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; Non. La déclaration XML doit apparaître en premier dans un document XML. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;\u0026lt;/nom\u0026gt;\u0026lt;numero\u0026gt;\u0026lt;/numero\u0026gt; \u0026lt;/etudiant\u0026gt; Non. Le document n'est pas valide parce que le symbole « + » implique que l'élément « cours » doit apparaître au moins une fois. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE etudiant SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;etudiant\u0026gt; \u0026lt;nom\u0026gt;Jean Pearson\u0026lt;/nom\u0026gt; \u0026lt;numero\u0026gt;12\u0026lt;/numero\u0026gt; \u0026lt;cours\u0026gt;Introduction aux ordinateurs\u0026lt;/cours\u0026gt; \u0026lt;/etudiant\u0026gt; Oui. L'élément « cours » apparaît une fois, comme cela est exigé. Question 11 . Soit le document DTD suivant, disponible à l'adresse « http://www.mondomain.com/madtd.dtd ». Dites quels documents XML sont valides . \u0026lt;!ELEMENT compagnie (president, ingénieur*, comptable+)\u0026gt; \u0026lt;!ELEMENT president (prenom,nom)\u0026gt; \u0026lt;!ELEMENT ingenieur (prenom,nom)\u0026gt; \u0026lt;!ELEMENT comptable (prenom,nom)\u0026gt; \u0026lt;!ELEMENT prenom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;/compagnie\u0026gt; Non. Selon la DTD, il faut que les noms apparaissent après les prénoms. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;/compagnie\u0026gt; Oui. La compagnie a un comptable et un président, comme cela est demandé. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;ingenieur\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/ingenieur\u0026gt; \u0026lt;/compagnie\u0026gt; Non. Il faut au moins un comptable. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;ingenieur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Bertran\u0026lt;/nom\u0026gt; \u0026lt;/ingenieur\u0026gt; \u0026lt;ingenieur\u0026gt; \u0026lt;prenom\u0026gt;Luc\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Fauche\u0026lt;/nom\u0026gt; \u0026lt;/ingenieur\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;/compagnie\u0026gt; Oui. On peut avoir plus d'un ingénieur. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;ingenieur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Bertran\u0026lt;/nom\u0026gt; \u0026lt;/ingenieur\u0026gt; \u0026lt;ingenieur\u0026gt; \u0026lt;prenom\u0026gt;Luc\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Fauche\u0026lt;/nom\u0026gt; \u0026lt;/ingenieur\u0026gt; \u0026lt;/compagnie\u0026gt; Non. Les ingénieurs doivent apparaître avant les comptables. Question 12 . Soit le document DTD suivant, disponible à l'adresse « http://www.mondomain.com/madtd.dtd ». Dites quels documents XML sont valides . \u0026lt;!ELEMENT compagnie (employe*)\u0026gt; \u0026lt;!ELEMENT employe (nom,prenom,telephone?,division+)\u0026gt; \u0026lt;!ELEMENT division (#PCDATA)\u0026gt; \u0026lt;!ELEMENT prenom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT telephone (#PCDATA)\u0026gt; Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;telephone\u0026gt;432432432\u0026lt;/telephone\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/compagnie\u0026gt; Non. L'élément employé doit contenir au moins un élément « division ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;division\u0026gt;Services récréatifs\u0026lt;/division\u0026gt; \u0026lt;telephone\u0026gt;432432432\u0026lt;/telephone\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/compagnie\u0026gt; Non. L'élément employé doit contenir un élément « division », mais après l'élément « telephone ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;division\u0026gt;Services récréatifs\u0026lt;/division\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/compagnie\u0026gt; Oui. L'élément « telephone est facultatif ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\"\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;telephone\u0026gt;432-432-432444\u0026lt;/telephone\u0026gt; \u0026lt;telephone\u0026gt;433-444-444444\u0026lt;/telephone\u0026gt; \u0026lt;division\u0026gt;Services récréatifs\u0026lt;/division\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/compagnie\u0026gt; Non. L'élément « telephone » peut ne pas apparaître ou apparaître une fois. Question 13 . Soit le document DTD suivant, disponible à l'adresse « http://www.mondomain.com/madtd.dtd ». Dites quels documents XML sont valides . \u0026lt;!ELEMENT compagnie (president, ingénieur*, comptable+)\u0026gt; \u0026lt;!ELEMENT president (prenom,nom)\u0026gt; \u0026lt;!ELEMENT ingenieur (prenom,nom)\u0026gt; \u0026lt;!ELEMENT comptable (prenom,nom)\u0026gt; \u0026lt;!ELEMENT prenom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie [ \u0026lt;!ELEMENT compagnie (president, ingénieur*, comptable+)\u0026gt; \u0026lt;!ELEMENT president (nom,prenom)\u0026gt; \u0026lt;!ELEMENT ingenieur (nom,prenom)\u0026gt; \u0026lt;!ELEMENT comptable (nom,prenom)\u0026gt; \u0026lt;!ELEMENT prenom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;nom\u0026gt;Palado\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;/compagnie\u0026gt; Dans ce cas précis, la DTD à l'adresse « http://www.mondomain.com/madtd.dtd » n'est jamais utilisé. Il ne faut donc considérer que la DTD interne. Selon cette DTD, le document XML est valable. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE taxe SYSTEM \"http://www.mondomain.com/madtd.dtd\" [ \u0026lt;!ELEMENT taxe (montant, comptable)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;taxe\u0026gt; \u0026lt;montant\u0026gt; 50$ \u0026lt;/montant\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;/taxe\u0026gt; Pour traiter le document, il faut ici combiner les deux DTD; on voit que l'élément « taxe » utilise un élément « comptable » de la DTD externe. Cela est parfaitement valable. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE compagnie SYSTEM \"http://www.mondomain.com/madtd.dtd\" [ \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;compagnie\u0026gt; \u0026lt;president\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt; \u0026lt;prenom\u0026gt;Yvon\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Côté\u0026lt;/nom\u0026gt; \u0026lt;/comptable\u0026gt; \u0026lt;montant\u0026gt; 50$ \u0026lt;/montant\u0026gt; \u0026lt;/compagnie\u0026gt; Il n'est pas prévu dans la DTD externe que l'élément « compagnie » contienne un élément « montant », donc ce n'est pas permis. La DTD interne vient s'ajouter à la DTD externe, mais sans plus. Question 14 . Dites quels documents XML sont valides . Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE jeu [ \u0026lt;!ELEMENT jeu (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans\u0026lt;/age\u0026gt; \u0026lt;niveau\u0026gt;jeune adulte\u0026lt;/niveau\u0026gt; \u0026lt;/jeu\u0026gt; Non. La DTD interne stipule que l'élément « jeu » contient un élément « nom », suivi d'un élément « age » ou d'un élément « niveau », mais pas les deux. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE jeu [ \u0026lt;!ELEMENT jeu (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans\u0026lt;/age\u0026gt; \u0026lt;/jeu\u0026gt; Oui. La DTD interne stipule que l'élément « jeu » contient un élément « nom », suivi d'un élément « age » ou d'un élément « niveau », mais pas les deux. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE jeu [ \u0026lt;!ELEMENT jeu (nom,(age|niveau)+)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la poudre\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;25-35 ans\u0026lt;/age\u0026gt; \u0026lt;niveau\u0026gt;universitaire\u0026lt;/niveau\u0026gt; \u0026lt;/jeu\u0026gt; Oui. La DTD interne stipule que l'élément « jeu » contient un élément « nom » qui peut ou non être suivi de plusieurs éléments « age » ou éléments « niveau ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE jeu [ \u0026lt;!ELEMENT jeu (nom,(#PCDATA|age|niveau)*)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la poudre\u0026lt;/nom\u0026gt; J'ai maintenant la balise age... \u0026lt;age\u0026gt;25-35 ans\u0026lt;/age\u0026gt; suivie d'une balise niveau \u0026lt;niveau\u0026gt;universitaire\u0026lt;/niveau\u0026gt; et je peux continuer \u0026lt;/jeu\u0026gt; Oui. La DTD interne stipule que l'élément « jeu » contient un élément « nom », suivi de contenu mixte avec texte et choix de balises entre « age » et « niveau ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE jeu [ \u0026lt;!ELEMENT jeu (nom,(#PCDATA|age|niveau)*)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;jeu\u0026gt; Ceci est du XML avec contenu mixte \u0026lt;nom\u0026gt;Jeu de la poudre\u0026lt;/nom\u0026gt; J'ai maintenant la balise age... \u0026lt;age\u0026gt;25-35 ans\u0026lt;/age\u0026gt; suivie d'une balise niveau \u0026lt;niveau\u0026gt;universitaire\u0026lt;/niveau\u0026gt; et je peux continuer \u0026lt;/jeu\u0026gt; Non. L'élément « jeu » doit commencer par une balise « nom ». Question 15 . Dites quels documents XML sont valides . Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE activite [ \u0026lt;!ELEMENT activite ANY\u0026gt; \u0026lt;!ELEMENT travail (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT jeu (nom,(age|niveau),gratuit?)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; \u0026lt;!ELEMENT gratuit EMPTY\u0026gt; ]\u0026gt; \u0026lt;activite\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans\u0026lt;/age\u0026gt; \u0026lt;niveau\u0026gt;jeune adulte\u0026lt;/niveau\u0026gt; \u0026lt;/jeu\u0026gt; \u0026lt;/activite\u0026gt; Le problème ici est qu'on peut avoir un élément « age » ou un élément « niveau », mais pas les deux. L'élément « activite » peut contenir tout élément déclaré dont « jeu ». L'élément « jeu » a une balise optionnelle « gratuit », qui est ici absente. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE activite [ \u0026lt;!ELEMENT activite ANY\u0026gt; \u0026lt;!ELEMENT travail (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT jeu (nom,(age|niveau),gratuit?)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; \u0026lt;!ELEMENT gratuit EMPTY\u0026gt; ]\u0026gt; \u0026lt;activite\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle \u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans \u0026lt;/age\u0026gt; \u0026lt;gratuit\u0026gt; \u0026lt;/gratuit\u0026gt; \u0026lt;/jeu\u0026gt; \u0026lt;/activite\u0026gt; Non. L'élément « gratuit » doit être vide de tout, incluant les espaces et retours de chariot. Il faut donc utiliser la syntaxe \u0026lt;gratuit\u0026gt;\u0026lt;/gratuit\u0026gt; ou, plus simplement, \u0026lt;gratuit /\u0026gt;. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE activite [ \u0026lt;!ELEMENT activite ANY\u0026gt; \u0026lt;!ELEMENT travail (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT jeu (nom,(age|niveau),gratuit?)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; \u0026lt;!ELEMENT gratuit EMPTY\u0026gt; ]\u0026gt; \u0026lt;activite\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle \u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans \u0026lt;/age\u0026gt; \u0026lt;niveau\u0026gt;jeune adulte \u0026lt;/niveau\u0026gt; \u0026lt;gratuit /\u0026gt; \u0026lt;/jeu\u0026gt; \u0026lt;/activite\u0026gt; On utilise les éléments « age » et « niveau », alors qu'on doit choisir entre l'un ou l'autre, à cause de l'opérateur « | » (ou logique). \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE activite [ \u0026lt;!ELEMENT activite ANY\u0026gt; \u0026lt;!ELEMENT travail (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT jeu (nom,(age|niveau),gratuit?)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; \u0026lt;!ELEMENT gratuit EMPTY\u0026gt; ]\u0026gt; \u0026lt;activite\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans\u0026lt;/age\u0026gt; \u0026lt;/jeu\u0026gt; J'ajoute une balise \u0026lt;nom\u0026gt;Mon nom est Bond\u0026lt;/nom\u0026gt; \u0026lt;/activite\u0026gt; Oui. L'élément « activite » peut contenir n'importe quel élément déclaré et du contenu mixte. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE activite [ \u0026lt;!ELEMENT activite ANY\u0026gt; \u0026lt;!ELEMENT travail (nom,(age|niveau))\u0026gt; \u0026lt;!ELEMENT jeu (nom,(age|niveau),gratuit?)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT age (#PCDATA)\u0026gt; \u0026lt;!ELEMENT niveau (#PCDATA)\u0026gt; \u0026lt;!ELEMENT gratuit EMPTY\u0026gt; ]\u0026gt; \u0026lt;activite\u0026gt; \u0026lt;jeu\u0026gt; \u0026lt;nom\u0026gt;Jeu de la chandelle\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;15-25 ans\u0026lt;/age\u0026gt; \u0026lt;/jeu\u0026gt; \u0026lt;peuimporte\u0026gt;je peux tout me permettre\u0026lt;/peuimporte\u0026gt; \u0026lt;/activite\u0026gt; Non. L'élément « peuimporte » n'est pas prévu par la DTD; il n'est donc pas permis. Question 16 . Dites quels documents XML sont valides . Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;cheque commentaire=\"loyer\"\u0026gt; \u0026lt;recipiendaire\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; Non. Il n'est pas permis d'avoir un attribut non déclaré dans la DTD. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #REQUIRED\u0026gt; ]\u0026gt; \u0026lt;cheque commentaire=\"loyer\"\u0026gt; \u0026lt;recipiendaire\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; Oui. L'élément « cheque » a bien un attribut « commentaire », comme cela est nécessaire. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #REQUIRED\u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #REQUIRED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #REQUIRED\u0026gt; ]\u0026gt; \u0026lt;cheque commentaire=\"loyer\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; Non. L'élément « emetteur » devrait avoir un attribut « commentaire ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #IMPLIED\u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #IMPLIED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #IMPLIED\u0026gt; ]\u0026gt; \u0026lt;cheque commentaire=\"loyer\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; Oui. L'élément « emetteur » n'a pas d'attribut « commentaire », mais c'est permis à cause de la mention « IMPLIED ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE cheque [ \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #IMPLIED numero ID #REQUIRED \u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #IMPLIED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #IMPLIED\u0026gt; ]\u0026gt; \u0026lt;cheque commentaire=\"loyer\" numero=\"1324\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; Non. L'attribut « numero=\"1324\" » doit avoir comme valeur un nom XML; en d'autres termes, il ne peut commencer par un chiffre. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE chequier [ \u0026lt;!ELEMENT chequier (cheque*)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #IMPLIED numero ID #REQUIRED \u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #IMPLIED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #IMPLIED\u0026gt; ]\u0026gt; \u0026lt;chequier\u0026gt; \u0026lt;cheque commentaire=\"loyer\" numero=\"cheque1324\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;cheque commentaire=\"encore le loyer\" numero=\"cheque1324\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami (encore)\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;/chequier\u0026gt; Non. Nous avons ici deux attributs avec une valeur de type ID : il faut qu'ils aient des valeurs différentes. En XML, la valeur d'un attribut de type ID identifie un élément unique. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE chequier [ \u0026lt;!ELEMENT chequier (cheque*)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #IMPLIED numero ID #REQUIRED \u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #IMPLIED nas ID #IMPLIED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #IMPLIED\u0026gt; ]\u0026gt; \u0026lt;chequier\u0026gt; \u0026lt;cheque commentaire=\"loyer\" numero=\"cheque1324\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\" nas=\"n333-344-444\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;cheque commentaire=\"encore le loyer\" numero=\"cheque1325\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami (encore)\" nas=\"n333-344-444bis\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;/chequier\u0026gt; Oui. Observez que tous les attributs ayant des valeurs de type ID ont des valeurs distinctes. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE chequier [ \u0026lt;!ELEMENT chequier (cheque*)\u0026gt; \u0026lt;!ELEMENT recipiendaire (nom)\u0026gt; \u0026lt;!ELEMENT emetteur (nom)\u0026gt; \u0026lt;!ELEMENT montant (#PCDATA)\u0026gt; \u0026lt;!ELEMENT cheque (recipiendaire,emetteur,montant)\u0026gt; \u0026lt;!ELEMENT nom (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cheque commentaire CDATA #IMPLIED numero ID #REQUIRED \u0026gt; \u0026lt;!ATTLIST recipiendaire commentaire CDATA #IMPLIED nas ID #IMPLIED\u0026gt; \u0026lt;!ATTLIST emetteur commentaire CDATA #IMPLIED \u0026gt; ]\u0026gt; \u0026lt;chequier\u0026gt; \u0026lt;cheque commentaire=\"le loyer d'aujourd'hui\" numero=\"cheque1324\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami\" nas=\"n333-344-444\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;cheque commentaire=\"encore le loyer\" numero=\"cheque1325\"\u0026gt; \u0026lt;recipiendaire commentaire=\"mon ami (encore)\" nas=\"n333-344-444bis\"\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;emetteur\u0026gt; \u0026lt;nom\u0026gt;Martin\u0026lt;/nom\u0026gt; \u0026lt;/emetteur\u0026gt; \u0026lt;montant\u0026gt;10$\u0026lt;/montant\u0026gt; \u0026lt;/cheque\u0026gt; \u0026lt;/chequier\u0026gt; Oui. Observez encore une fois que tous les attributs ayant des valeurs de type ID ont des valeurs distinctes. Question 17 . Dans une DTD, que signifie la ligne suivante? \u0026lt;!ATTLIST etudiant universite CDATA \"Université du Québec à Montréal\"\u0026gt; Indice. Il s'agit d'une valeur d'attribut par défaut. Choisissez la bonne réponse parmi les suivantes. Que les éléments « etudiant » doivent toujours avoir explicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal ». (Réponse incorrecte!) Non. Que les éléments « etudiant » ont toujours implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal ». (Réponse incorrecte!) Non. Que les éléments « etudiant » ont implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal », à moins que l'on fournisse une autre valeur de type CDATA. (Réponse correcte!) Oui. Que les éléments « etudiant » ont implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal » et que si l'on fournit explicitement l'attribut, il doit avoir comme valeur « Université du Québec à Montréal ». (Réponse incorrecte!) Non. Question 18 . Dans une DTD, que signifie la ligne suivante? \u0026lt;!ATTLIST etudiant universite CDATA #FIXED \"Université du Québec à Montréal\"\u0026gt; Indice. Il s'agit d'une valeur d'attribut par défaut. Choisissez la bonne réponse parmi les suivantes. Que les éléments « etudiant » doivent toujours avoir explicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal ». (Réponse incorrecte!) Non. La valeur peut aussi être implicite. Que les éléments « etudiant » ont toujours implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal ». (Réponse incorrecte!) C'est vrai, mais on peut aussi stipuler explicitement la valeur. Que les éléments « etudiant » ont implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal », à moins que l'on fournisse une autre valeur de type CDATA. (Réponse incorrecte!) Non. La valeur de l'attribut est fixe. Que les éléments « etudiant » ont implicitement un attribut « universite » ayant comme valeur « Université du Québec à Montréal », et que si l'on fournit explicitement l'attribut, il doit avoir comme valeur « Université du Québec à Montréal ». (Réponse correcte!) Oui. Question 19 . Dans un document XML, que signifie la ligne suivante? \u0026lt;!ENTITY % administration \"president,comptable,adjoint\"\u0026gt; si le document XML commence par \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt;!DOCTYPE taxe SYSTEM \"http://www.mondomain.com/mabelledtd.dtd\" [ \u0026lt;!ENTITY % administration \"president,comptable,adjoint\"\u0026gt; ]\u0026gt; Indice. Il s'agit d'une entité paramètre. Choisissez la bonne réponse parmi les suivantes. Partout dans le document XML où le texte « \u0026amp;administration; » apparaît, il est remplacé par « president,comptable,adjoint ». (Réponse incorrecte!) Non. Ce serait toutefois le cas si nous avions la ligne \u0026lt;!ENTITY administration \"president,comptable,adjoint\"\u0026gt; Partout dans la DTD externe, le texte « %administration; » est remplacé par « president,comptable,adjoint ». (Réponse correcte!) Oui. Partout dans la DTD externe, à supposer qu'elle ne définisse pas déjà l'entité « administration », le texte « %administration; » est remplacé par « president,comptable,adjoint ». (Réponse incorrecte!) Non. La partie interne de la DTD a préséance sur la DTD externe. Question 20 . Choisissez les documents valables. Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE dossier [ \u0026lt;!ELEMENT dossier (cas*)\u0026gt; \u0026lt;!ELEMENT cas (#PCDATA|reference)*\u0026gt; \u0026lt;!ELEMENT reference (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cas numero ID #REQUIRED\u0026gt; \u0026lt;!ATTLIST reference numero IDREF #REQUIRED\u0026gt; ]\u0026gt; \u0026lt;dossier\u0026gt; \u0026lt;cas numero=\"5543\"\u0026gt;La mère souffre de la grippe.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"5544\"\u0026gt;Le père est en santé.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"5548\"\u0026gt;L'enfant de \u0026lt;reference numero=\"5543\" /\u0026gt; et de \u0026lt;reference numero=\"5544\" /\u0026gt; se porte bien.\u0026lt;/cas\u0026gt; \u0026lt;/dossier\u0026gt; La valeur d'un attribut de type « ID » ou « IDREF » doit être un nom XML valable, donc elle ne doit pas débuter par un chiffre. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE dossier [ \u0026lt;!ELEMENT dossier (cas*)\u0026gt; \u0026lt;!ELEMENT cas (#PCDATA|reference)*\u0026gt; \u0026lt;!ELEMENT reference (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cas numero ID #REQUIRED\u0026gt; \u0026lt;!ATTLIST reference numero IDREF #REQUIRED\u0026gt; ]\u0026gt; \u0026lt;dossier\u0026gt; \u0026lt;cas numero=\"c5543\"\u0026gt;La mère souffre de la grippe.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"c5544\"\u0026gt;Le père est en santé.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"c5548\"\u0026gt;L'enfant de \u0026lt;reference numero=\"c12\" /\u0026gt; et de \u0026lt;reference numero=\"c13\" /\u0026gt; se porte bien.\u0026lt;/cas\u0026gt; \u0026lt;/dossier\u0026gt; Non. Toutes les valeurs d'attribut de type « IDREF » ne correspondent pas à une valeur d'attribut de type « ID ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?\u0026gt; \u0026lt;!DOCTYPE dossier [ \u0026lt;!ELEMENT dossier (cas*)\u0026gt; \u0026lt;!ELEMENT cas (#PCDATA|reference)*\u0026gt; \u0026lt;!ELEMENT reference (#PCDATA)\u0026gt; \u0026lt;!ATTLIST cas numero ID #REQUIRED\u0026gt; \u0026lt;!ATTLIST reference numero IDREF #REQUIRED\u0026gt; ]\u0026gt; \u0026lt;dossier\u0026gt; \u0026lt;cas numero=\"c5543\"\u0026gt;La mère souffre de la grippe.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"c5544\"\u0026gt;Le père est en santé.\u0026lt;/cas\u0026gt; \u0026lt;cas numero=\"c5548\"\u0026gt;L'enfant de \u0026lt;reference numero=\"c5543\" /\u0026gt; et de \u0026lt;reference numero=\"c5544\" /\u0026gt; se porte bien.\u0026lt;/cas\u0026gt; \u0026lt;/dossier\u0026gt; Effectivement. Tous les valeurs d'attribut de type « IDREF » correspondent à une valeur d'attribut de type « ID ». Question 21 . Trouvez le terme qui se distingue. Choisissez la bonne réponse parmi les suivantes. XML Schema (Réponse incorrecte!) Non. XML Schema est une technologie permettant de valider du XML. Relax NG (Réponse incorrecte!) Non. Relax NG est une technologie permettant de valider du XML. DTD (Réponse incorrecte!) Non. DTD est une technologie permettant de valider du XML. Schematron (Réponse incorrecte!) Non. Schematron est une technologie permettant de valider du XML. XML (Réponse correcte!) Non. Le XML n'est pas une technologie de validation. Examplotron (Réponse incorrecte!) Non. Examplotron est une technologie permettant de valider du XML. Question 22 . Je dois définir des entités, quelle technologie est-ce que je dois utiliser? Choisissez la bonne réponse parmi les suivantes. XML Schema (Réponse incorrecte!) Non. XML Schema ne permet pas de définir des entités. Relax NG (Réponse incorrecte!) Non. Relax NG ne permet pas de définir des entités. DTD (Réponse correcte!) Effectivement. DTD permet la définition des entités. Question 23 . Quelle est la signification de DTD? Choisissez la bonne réponse parmi les suivantes. Document Type Definition (Réponse correcte!) Effectivement. Document Type Declaration (Réponse incorrecte!) Non. Dynamic Type Definition (Réponse incorrecte!) Non. Question 24 . Choisissez la meilleure réponse Choisissez la bonne réponse parmi les suivantes. La spécification DTD fait partie intégrante du XML. (Réponse correcte!) Effectivement. Le nom des éléments doit être en minuscule. (Réponse incorrecte!) Non. Tous les documents doivent avoir une DTD. (Réponse incorrecte!) Non. Question 25 . Choisissez la meilleure réponse Choisissez la bonne réponse parmi les suivantes. Toutes ces réponses sont vraies (Réponse correcte!) Effectivement. Le XML est sensible à la casse des cararactères (Réponse incorrecte!) Oui, mais ce n'est pas tout. Tous les documents XML doivent avoir un élément-racine. (Réponse incorrecte!) Oui, mais ce n'est pas tout. Vous avez maintenant terminé votre autoévaluation. "},{"id":46,"href":"/orientee_donnees/legacy/semaine_11/autoevaluation/","title":"Autoévaluation","section":"Semaine 11","content":" Autoévaluation DOM # Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Si vous faites la lecture d'un document XML avec une librairie supportant DOM et que, par la suite, vous utilisez la même librairie pour sauvegarder exactement le même modèle en arbre, est-ce que le fichier nouvellement produit sera identique au fichier d'origine? Choisissez la bonne réponse parmi les suivantes. Oui (Réponse incorrecte!) Il y a plusieurs façons de représenter un même arbre XML. Par exemple, l'espace entre les éléments n'est pas significatif en XML et « \u0026lt;toto\u0026gt;fds\u0026lt;/toto\u0026gt;\u0026lt;toto\u0026gt;fds\u0026lt;/toto\u0026gt; » est équivalent à « \u0026lt;toto\u0026gt;fds\u0026lt;/toto\u0026gt; \u0026lt;toto\u0026gt;fds\u0026lt;/toto\u0026gt; ». Non (Réponse correcte!) Effectivement, il peut y avoir des différences. Question 2 . Si vous voulez absolument produire du XML bien formé, quelle est la meilleure méthode? Choisissez la bonne réponse parmi les suivantes. En traitant le XML comme du texte (System.out en Java). (Réponse incorrecte!) S'il est important que votre document soit bien formé, ce n'est probablement pas la meilleure méthode, à moins que le travail ne soit relativement simple. En utilisant le XSLT. (Réponse incorrecte!) Non. Le XSLT ne permet pas de vérifier que le document produit est du XML bien formé. Il est possible de générer du XML incorrect à partir du XSLT : par exemple, ayant deux éléments-racines. En utilisant une librairie avec modèle DOM. (Réponse correcte!) Oui. Une bonne librairie devrait nous assurer que le document produit est du XML bien formé. Question 3 . Est-ce qu'une librairie événementielle nous avertit de la présence d'un commentaire dans le texte XML? Est-ce que le modèle en arbre doit contenir les commentaires? Choisissez la bonne réponse parmi les suivantes. Oui. Dans les deux cas. (Réponse incorrecte!) Non. C'est pourquoi les commentaires ne devraient pas contenir des informations importantes, car les parseurs peuvent omettre les commentaires. Non. Dans les deux cas. (Réponse correcte!) Effectivement. Certains parseurs omettent les commentaires; si les les commentaires XML servent à stocker des informations importantes, cela peut entraîner un problème. Question 4 . Quel type de modèle est le DOM? Choisissez la bonne réponse parmi les suivantes. En arbre (Réponse correcte!) Oui. C'est même le modèle en arbre de référence. Événementiel (Réponse incorrecte!) Non, mais on peut utiliser un traitement événementiel pour produire un DOM. Texte (Réponse incorrecte!) Non. Question 5 . Si, dans un document XML, seule la valeur des attributs « montant » vous intéresse, quelle serait le meilleur modèle de programmation? Choisissez la bonne réponse parmi les suivantes. En arbre (Réponse incorrecte!) Non. Il peut être fastidieux et coûter beaucoup de mémoire que de tout mettre dans un arbre pour n'aller chercher que quelques valeurs. Événementiel (Réponse correcte!) Effectivement. Vous pourriez ainsi aller chercher que ce dont vous avez besoin. Texte (Réponse incorrecte!) Le traitement du XML comme texte peut fonctionner dans certains cas simples, mais pas en général. "},{"id":47,"href":"/orientee_donnees/docs/modules/d_module_html/css/","title":"CSS","section":"Module HTML, CSS, SVG, MathML","content":" CSS # La norme CSS a d\u0026rsquo;abord été proposée par Håkon Lie du CERN en Suisse en 1994 (environ 4 ans après l\u0026rsquo;apparition de la première page web). Cette norme a été acceptée comme recommandation officielle du W3C deux ans plus tard, soit en 1996, et la seconde version (CSS 2.0) est devenue une recommandation du W3C l\u0026rsquo;année suivante, soit en 1997. Une troisième version (CSS 3) a été adoptée à compter de 2011. À l\u0026rsquo;origine, les instructions CSS étaient destinées uniquement à indiquer aux navigateurs comment présenter le HTML (couleurs, polices, etc.) ; on s\u0026rsquo;est vite rendu compte qu\u0026rsquo;on pouvait aussi l\u0026rsquo;appliquer au XML et on considère maintenant les CSS comme une technologie qui s\u0026rsquo;applique autant au HTML qu\u0026rsquo;au XML (et aussi, évidemment, au XHTML).\nNous avons vu que le XSLT permettait de transformer du XML en HTML pour l\u0026rsquo;affichage dans un navigateur. En général, le XSLT permet de transformer tout document XML en un autre format (HTML, XML ou autre).\nUn fichier CSS est beaucoup plus limité dans la mesure où il ne transforme pas le document XML. Il permet seulement de spécifier comment le contenu du document XML sera affiché. Le fichier XSLT est un outil de transformation, alors que le fichier CSS est un outil de formatage. Un document CSS permet de rendre un document XML plus lisible. D\u0026rsquo;un autre côté, le fichier CSS permet de contrôler avec beaucoup de finesse la présentation du document XML, alors qu\u0026rsquo;il peut être difficile et fastidieux d\u0026rsquo;obtenir le même résultat en XSLT, sans utiliser les CSS. Les fichiers CSS tendent aussi à être plus simples que les fichiers XSLT ; il peut donc être plus facile de les modifier et de les garder à jour. Finalement, on peut utiliser à la fois des fichiers CSS et des fichiers XSLT, en combinant les avantages des deux (présentation et transformation).\npoint de vue critique # CSS est un langage déclaratif relativement limité. Il n\u0026rsquo;est pas possible de définir des variables, des fonctions ou de faire de l\u0026rsquo;arithmétique en CSS. On peut, par contre, redéfinir à volonté des règles, ce qui peut rendre le comportement final difficile à comprendre pour un humain. Il n\u0026rsquo;est pas facile, en CSS, de détecter le navigateur utilisé alors que tous les navigateurs ne traitent pas les règles de la même façon.\nnotions de base # Pour l\u0026rsquo;essentiel, le langage CSS prend la forme d\u0026rsquo;une succession d\u0026rsquo;affirmations de la forme élément {propriété: valeur; autrepropriété: valeur;}. Il s\u0026rsquo;agit d\u0026rsquo;une syntaxe très simple.\nSupposons un document XML comme celui-ci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;comptearecevoir\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Madeleine Bédard\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;20.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;un crayon\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;/comptearecevoir\u0026gt; Certains navigateurs affichent le XML brut sans formatage, ce qui n\u0026rsquo;est pas très accessible. D\u0026rsquo;autres affichent le document sans les balises :\nJean Rochond 10.10 Achat d\u0026#39;ordinateur Madeleine Bédard 20.10 Achat d\u0026#39;un crayon Ce document XML est difficile à lire, même sans les balises, surtout si vous n\u0026rsquo;êtes pas un expert en XML. Sans le transformer, il est possible de l\u0026rsquo;afficher avec de la couleur ou de l\u0026rsquo;italique, comme ceci :\nJean Rochond 10.10\nAchat d\u0026rsquo;ordinateur Madeleine Bédard 20.10\nAchat d\u0026rsquo;un crayon Voilà qui est nettement plus lisible ! Nous pouvons obtenir ce résultat à l\u0026rsquo;aide du fichier CSS suivant :\nfacture { display: block; margin-bottom: 30pt; } montant { color: red; } raison { display: block; font-style: italic; margin-left: 1cm; } Pour vérifier que c\u0026rsquo;est bien le cas, il suffit de créer un fichier « chap12.css » avec le contenu CSS précédent et de modifier le fichier XML en y ajoutant une ligne pointant vers le fichier CSS (\u0026lt;?xml-stylesheet type=\u0026quot;text/css\u0026quot; href=\u0026quot;chap12.css\u0026quot;?\u0026gt;), comme ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/css\u0026#34; href=\u0026#34;chap12.css\u0026#34;?\u0026gt; \u0026lt;comptearecevoir\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Madeleine Bédard\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;20.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;un crayon\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;/comptearecevoir\u0026gt; Si le fichier XML est dans le même répertoire que le fichier CSS, votre navigateur devrait vous présenter le document XML avec le montant en rouge et le commentaire (raison) en italique, comme nous l\u0026rsquo;avons présenté plus haut.\nNotez que dans le laboratoire de cette semaine, vous pourrez expérimenter avec CSS au sein de votre navigateur sans devoir créer de fichiers.\nExaminons maintenant les différentes instructions du fichier CSS.\nL\u0026rsquo;instruction « display: block; » déclare que l\u0026rsquo;élément devrait former son propre paragraphe. L\u0026rsquo;instruction « display: none; » rend l\u0026rsquo;élément invisible.\nLes instructions « margin-bottom: 30pt; » et « margin-left: 1cm; » définissent des marges en bas et à gauche de 30 points et de 1 cm respectivement.\nL\u0026rsquo;instruction « color: red; » affirme que le contenu de l\u0026rsquo;élément devrait être écrit en rouge, alors que « font-style: italic; » nous dit que le texte de l\u0026rsquo;élément devrait être en italique. On pourrait aussi contrôler la couleur de fond avec une instruction comme « background-color:red ».\nDans l\u0026rsquo;éventualité où nous voulons choisir une couleur très précise, et non les couleurs courantes comme « red », « green », « blue », « yellow », « white », « black », etc., nous pouvons la spécifier selon sa composition avec les couleurs de base (« red », « green », « blue ») avec une instruction comme « background-color:rgb(200,200,200); », où chaque valeur numérique est entre 0 et 255 inclusivement.\nles unités de mesure # En CSS, on peut spécifier la taille d\u0026rsquo;un objet avec plusieurs unités de mesure, par exemple cm pour centimètre ou px pour pixel. Ainsi donc l\u0026rsquo;instruction « width:1px » spécifie une largeur de 1 pixel. On peut aussi utiliser des unités relatives comme « em », « rem » ou « % ». Une mesure de « 50 % » indique que l\u0026rsquo;objet devrait occuper la moitié de l\u0026rsquo;espace disponible. Une mesure de « 1em » correspond à la taille de la police de caractère dans l\u0026rsquo;élément courant alors que « 1rem » correspond à la taille de la police de caractère dans l\u0026rsquo;élément-racine du document. On peut aussi combiner les unités\u0026hellip; par exemple, pour spécifier une dimension correspondant à tout l\u0026rsquo;espace disponible moins 80 pixels, on peut utiliser la valeur « calc(100% - 80px) ». Pour bien comprendre, l\u0026rsquo;idéal est de faire des expériences.\ncontenu en ligne ou en bloc ? # Par défaut, les éléments s\u0026rsquo;affichent en ligne, un à la suite de l\u0026rsquo;autre. On peut contrôler comment s\u0026rsquo;affiche un élément avec la propriété « display » qui peut prendre plusieurs valeurs dont celles-ci :\n« display: none » : l\u0026rsquo;élément ne doit pas s\u0026rsquo;afficher. Par exemple, l\u0026rsquo;instruction « img{display: none;} » fait en sorte que les images ne s\u0026rsquo;affichent plus en HTML. Il est fréquent qu\u0026rsquo;avec du JavaScript, on cache et affiche tour à tour des éléments pour donner l\u0026rsquo;impression que la page est dynamique. « display: inline » : l\u0026rsquo;élément s\u0026rsquo;affiche à la suite du précédent comme s\u0026rsquo;il s\u0026rsquo;agissait d\u0026rsquo;un caractère. « display: block » : l\u0026rsquo;élément s\u0026rsquo;affiche dans un bloc distinct, comme un nouveau paragraphe, par exemple. « display: list-item » : l\u0026rsquo;élément s\u0026rsquo;affiche comme un élément d\u0026rsquo;une liste. « display: flex » ou « display: inline-flex » : les éléments contenus s\u0026rsquo;affichent selon un modèle flexible (voir https://css-tricks.com/snippets/css/a-guide-to-flexbox/). Voici un exemple :\np { display: block } strong { display: inline } li { display: list-item } img { display: none } On peut aussi définir la propriété « float » d\u0026rsquo;un élément qui lui permet de sortir du flot normal des éléments et de se placer à gauche ou à droite. Par exemple, une image en XHTML s\u0026rsquo;affiche normalement comme un bloc. On peut forcer l\u0026rsquo;image à s\u0026rsquo;intégrer au paragraphe suivant avec l\u0026rsquo;instruction « float: right » ou « float: left ». On peut aussi utiliser la propriété « float » pour créer plusieurs colonnes de texte comme dans un journal. Je vous invite à faire différentes expériences pour mieux comprendre l\u0026rsquo;utilisation de cette instruction.\ncentrer un élément # Bien qu\u0026rsquo;on puisse changer la justification du texte avec une instruction comme « text-align: center », centrer un élément requiert plutôt une manipulation des marges avec la valeur spéciale « auto », comme dans cet exemple :\np { width: 5cm; margin-left: auto; margin-right: auto; } Il aurait été sans doute préférable d\u0026rsquo;avoir une instruction dédiée pour centrer les éléments comme il s\u0026rsquo;agit d\u0026rsquo;une opération courante.\nles infobulles (tooltips) # Les infobulles sont des petits textes d\u0026rsquo;aide qui apparaissent généralement au survol d\u0026rsquo;un élément avec la souris. En CSS, on peut créer des infobulles personnalisées en utilisant les pseudo-éléments ::before ou ::after combinés avec la pseudo-classe :hover.\nVoici un exemple simple d\u0026rsquo;infobulle où le texte est défini directement en CSS :\n.tooltip { position: relative; display: inline-block; cursor: pointer; } .tooltip::after { content: \u0026#34;Ceci est une infobulle\u0026#34;; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background-color: #333; color: #fff; padding: 5px 10px; border-radius: 4px; white-space: nowrap; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; } .tooltip:hover::after { opacity: 1; visibility: visible; } Pour utiliser cette infobulle en HTML :\n\u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;Passez la souris ici\u0026lt;/span\u0026gt; Pour des infobulles avec du texte dynamique, on peut utiliser l\u0026rsquo;attribut data-tooltip en remplaçant content: \u0026quot;Ceci est une infobulle\u0026quot;; par content: attr(data-tooltip); et ajouter data-tooltip=\u0026quot;Votre texte\u0026quot; dans le HTML. On peut personnaliser l\u0026rsquo;apparence, la position (par exemple, à droite avec left: 100%) et ajouter des flèches avec des bordures CSS. Les infobulles améliorent l\u0026rsquo;accessibilité et l\u0026rsquo;expérience utilisateur en fournissant des informations contextuelles sans encombrer l\u0026rsquo;interface.\nVoici un exemple complet d\u0026rsquo;infobulle dynamique :\n.tooltip { position: relative; display: inline-block; cursor: pointer; } .tooltip::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background-color: #333; color: #fff; padding: 5px 10px; border-radius: 4px; white-space: nowrap; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; } .tooltip:hover::after { opacity: 1; visibility: visible; } Pour utiliser cette infobulle en HTML :\n\u0026lt;span class=\u0026#34;tooltip\u0026#34; data-tooltip=\u0026#34;Ceci est une infobulle personnalisée\u0026#34;\u0026gt;Passez la souris ici\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;tooltip\u0026#34; data-tooltip=\u0026#34;Autre information utile\u0026#34;\u0026gt;Ou ici\u0026lt;/span\u0026gt; Les commentaires # Tout comme en Java, on peut ajouter des commentaires à un fichier CSS qui sont systématiquement ignorés par la machine. Un bloc de commentaire débute par « /* » et se termine par « */ ».\n/* mon fichier css */ montant { color: red; /* la couleur rouge */ } sélectionner le premier caractère ou la première ligne # On peut sélectionner la première ligne d\u0026rsquo;un élément s\u0026rsquo;affichant en mode « block » et le premier caractère de tout élément avec les sélecteurs « :first-line » et « :first-letter » respectivement. Voici un exemple :\np:first-line {text-transform: uppercase} p:first-letter {font-size: 200%; float: left;} ajouter du contenu avant et après un élément # Avec CSS, on peut demander qu\u0026rsquo;une certaine chaîne de caractères apparaisse avant ou après un élément. Par exemple, si on veut ajouter automatiquement des guillemets avant et après un élément, on peut procéder comme ceci :\nblockquote:before {content:\u0026#34;«\u0026#34;;} blockquote:after {content:\u0026#34;»\u0026#34;;} Nous ne sommes pas limités au texte cependant. Il est possible, par exemple, d\u0026rsquo;ajouter automatiquement une image avant chaque élément comme ceci :\np:before {content:url(\u0026#34;monimage.png\u0026#34;);} qu\u0026rsquo;est-ce qu\u0026rsquo;un pseudo-élément ? # Les instructions first-line, first-letter, before et after que nous venons de présenter sont les principaux exemples de pseudo-éléments.\nsélecteurs d\u0026rsquo;interaction # Certains sélecteurs n\u0026rsquo;agissent qu\u0026rsquo;en réponse aux comportements de l\u0026rsquo;utilisateur. Par exemple, le sélecteur « p:hover » sélectionne les éléments « p » qui sont survolés par le curseur de la souris. Il existe plusieurs sélecteurs d\u0026rsquo;interaction dont « :link » (lien non visité), « :visited » (lien visité), « :active » (l\u0026rsquo;utilisateur utilise un élément), « :focus » (l\u0026rsquo;élément est sélectionné par l\u0026rsquo;utilisateur). On peut aussi combiner les sélecteurs comme dans cet exemple : « a:hover:focus ». On appelle aussi ces sélecteurs de pseudo-classes.\nrègles par défaut # Dans le cas du HTML ou du XHTML, les navigateurs utilisent une liste de règles par défaut. Ces règles vont varier d\u0026rsquo;un navigateur à l\u0026rsquo;autre, mais voici un exemple de règles utilisées par des navigateurs :\nhtml, div { display: block; } body { display: block; margin: 8px; } p, dl, multicol { display: block; margin: 1em 0; } blockquote { display: block; margin: 1em 40px; } h1 { display: block; font-size: 2em; font-weight: bold; margin: .67em 0; } h2 { display: block; font-size: 1.5em; font-weight: bold; margin: .83em 0; } pre { display: block; white-space: pre; margin: 1em 0; } b, strong { font-weight: bolder; } i, cite, em, var, dfn { font-style: italic; } u, ins { text-decoration: underline; } s, strike, del { text-decoration: line-through; } big { font-size: larger; } small { font-size: smaller; } sub { vertical-align: sub; font-size: smaller; line-height: normal; } sup { vertical-align: super; font-size: smaller; line-height: normal; } ul, menu, dir { display: block; list-style-type: disc; margin: 1em 0; } ol { display: block; list-style-type: decimal; margin: 1em 0; } li { display: list-item; } area, base, basefont, head, meta, script, style, title, noembed, param { display: none; } l\u0026rsquo;astérisque # L\u0026rsquo;astérisque nous permet d\u0026rsquo;appliquer une règle à tous les éléments, comme dans cet exemple : « * {color:red;} ».\nsélection sur la base des attributs # Avec les CSS, en utilisant les crochets, nous pouvons sélectionner tous les éléments ayant un attribut donné. Par exemple, l\u0026rsquo;instruction « *[monattribut] { color:red;} » mettra en rouge tous les éléments ayant un attribut portant le nom « monattribut ». Nous pouvons aussi limiter la sélection à des éléments portant un nom donné comme dans « maman[monattribut] { color:red;} » où les éléments « maman » ayant un attribut « monattribut » seront en rouge. Finalement, nous pouvons de plus limiter la sélection à des attributs ayant une certaine valeur, comme dans « maman[monattribut=\u0026quot;papa\u0026quot;] { color:red;} ».\nIl arrive fréquemment qu\u0026rsquo;une valeur d\u0026rsquo;attribut contienne plusieurs mots, comme dans « \u0026lt;amerique pays=\u0026quot;États-Unis Canada\u0026quot; /\u0026gt; ». Pour sélectionner tous les éléments dont un attribut contient un mot particulier, on remplace « = » par « ~= » comme dans l\u0026rsquo;instruction « *[pays~=\u0026quot;Canada\u0026quot;] { color:red;} » qui mettra en rouge tout élément dont l\u0026rsquo;attribut « pays » contient le mot « Canada ». Les mots doivent être séparés par des espaces. Dans l\u0026rsquo;éventualité où les mots sont séparés par des tirets, comme dans « \u0026lt;amerique pays=\u0026quot;Mexique-Canada\u0026quot; /\u0026gt; », on peut obtenir le même résultat avec « |= » comme dans « *[pays|=\u0026quot;Canada\u0026quot;] { color:red;} ».\nles espaces de noms # Les espaces de noms ne sont pas supportés en CSS 1 ou CSS 2. Ainsi « monelement { color:red;} » met en rouge le contenu de tous les éléments monelement, peu importe leur espace de noms. Il est incorrect d\u0026rsquo;utiliser la syntaxe « xhtml:monelement { color:red;} ».\nsélection de la langue # On a vu qu\u0026rsquo;il est possible en XML de spécifier la langue dans laquelle est écrit un texte avec l\u0026rsquo;attribut « xml:lang ». On pourrait penser que pour mettre le texte déclaré comme étant en anglais en rouge, il suffirait de l\u0026rsquo;instruction « *[lang=\u0026quot;fr\u0026quot;] { color:red;} », mais que se passera-t-il si on a utilisé un code de région avec la langue comme « fr-CA » ? Une solution plus élégante consiste alors à utiliser la sélection sur la langue avec une instruction comme « :lang(en) { color:red;} ».\nsélection de plusieurs éléments # Supposons maintenant que nous voulions afficher en rouge tous les éléments « facture » et « maison ». Nous pouvons le faire avec deux instructions :\nfacture { color:red;} maison { color:red;} En pratique cependant, il est préférable d\u0026rsquo;utiliser la virgule pour grouper les éléments, comme ceci :\nfacture, maison { color:red;} Les deux formes sont exactement équivalentes.\nsélection sur la base de la relation entre les éléments # Supposons maintenant que nous ne voulions pas afficher tous les éléments « personne » en rouge, mais seulement les éléments « personne » contenus dans un élément « facture ». Nous obtiendrons ce résultat en plaçant les deux noms d\u0026rsquo;élément côte-à-côte (séparés par un espace). Ainsi, l\u0026rsquo;instruction « facture personne { color:red;} » affichera en rouge tous les éléments « personne » contenus dans un élément « facture », comme dans l\u0026rsquo;exemple qui suit ou dans ce deuxième exemple.\nNous pourrions vouloir que seuls les éléments immédiatement contenus dans l\u0026rsquo;élément « facture », comme dans le premier exemple, soient en rouge, et non pas ceux qui sont contenus dans des éléments eux-mêmes dans un élément « facture » (deuxième exemple). Nous pouvons obtenir ce résultat avec l\u0026rsquo;instruction « facture \u0026gt; personne { color:red;} ».\nEn somme, la règle « a b { color:red;} » s\u0026rsquo;applique à l\u0026rsquo;élément « b », si l\u0026rsquo;élément « b » est contenu dans un élément « a » comme dans « \u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt; » ou « \u0026lt;a\u0026gt;\u0026lt;c\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/c\u0026gt;\u0026lt;/a\u0026gt; ».\nPar contre, la règle « a \u0026gt; b { color:red;} » s\u0026rsquo;applique à l\u0026rsquo;élément « b », si et seulement si l\u0026rsquo;élément « b » est immédiatement contenu dans un élément « a », comme dans « \u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt; ». Elle ne s\u0026rsquo;applique pas si « b » est contenu dans un élément lui-même contenu dans « a », comme dans « \u0026lt;a\u0026gt;\u0026lt;c\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/c\u0026gt;\u0026lt;/a\u0026gt; ».\nSupposons maintenant, dans l\u0026rsquo;exemple suivant, que nous voulions indenter le premier paragraphe (élément « p ») suivant le titre (élément « titre ») :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;titre\u0026gt;Mon histoire\u0026lt;/titre\u0026gt; \u0026lt;p\u0026gt;C\u0026#39;est triste.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Oui, c\u0026#39;est triste.\u0026lt;/p\u0026gt; Ce résultat s\u0026rsquo;obtient avec l\u0026rsquo;instruction « titre + p { text-indent: 0cm;} ». La syntaxe « a + b { \u0026hellip; } » s\u0026rsquo;applique à l\u0026rsquo;élément « b » quand les éléments « a » et « b » sont contenus dans le même élément, et que « b » est immédiatement après « a ». Notez que la règle « a + b { \u0026hellip; } » s\u0026rsquo;applique à « b », mais ne s\u0026rsquo;applique pas à « a ».\nSupposons que nous désirions indenter le premier paragraphe (élément « p ») dans l\u0026rsquo;élément « section » :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;section titre=\u0026#34;Mon histoire\u0026#34; \u0026gt; \u0026lt;p\u0026gt;C\u0026#39;est triste.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Oui, c\u0026#39;est triste.\u0026lt;/p\u0026gt; \u0026lt;/section\u0026gt; On peut obtenir ce résultat avec le sélecteur « section \u0026gt; p:first-child { \u0026hellip; } » où « :first-child » signifie que seuls les éléments « p » étant le premier élément au sein d\u0026rsquo;un autre élément sont sélectionnés. En fait, dans cet exemple particulier, on obtiendrait aussi le résultat voulu avec le sélecteur « p:first-child { \u0026hellip; } ».\nPar ailleurs, nous pouvons combiner les espaces, les « + », les virgules et les « \u0026gt; » dans un même sélecteur. Par exemple, « a + b, c { \u0026hellip; } » s\u0026rsquo;applique aux éléments « c » et aux éléments « b » qui suivent immédiatement un élément « a ».\nsélection d\u0026rsquo;élément par valeur ID # Si vous avez des éléments ayant des attributs de type « ID », on sait alors que leur valeur est un nom XML et qu\u0026rsquo;elle ne doit être utilisée qu\u0026rsquo;une seule fois. C\u0026rsquo;est le cas des attributs de la forme « id=\u0026ldquo;xxx\u0026rdquo; » que l\u0026rsquo;on peut utiliser avec pratiquement tous les éléments XHTML. On peut sélectionner un élément basé sur la valeur d\u0026rsquo;un tel attribut en utilisant le symbole « # » :\n#xxx { color: red; } Dans ce cas, le contenu d\u0026rsquo;un élément comme une balise XHTML « \u0026lt;p id='xxx'\u0026gt;test\u0026lt;/p\u0026gt; » s\u0026rsquo;affichera en rouge. On peut combiner les sélecteurs « # » avec les autres règles que nous avons traitées ; par exemple, le code suivant ne mettra en rouge que les éléments « i » contenus dans un élément ayant un attribut de type « ID » avec pour valeur « xxx » :\n#xxx i{ color: red; } "},{"id":48,"href":"/orientee_donnees/legacy/semaine_6/des_pages_web_dynamiques_avec_javascript/","title":"Des pages web dynamiques avec JavaScript","section":"Semaine 6","content":" Des pages web dynamiques avec JavaScript Dans ce cours, vous serez amené à utiliser le language JavaScript, aussi parfois appelé JavaScript. Il s’agit du langage de programmation utilisé par tous les navigateurs au sein des pages. Même s’il s’agit d’un langage de programmation complètement différent du Java, la syntaxe est similaire. Puisque vous maîtrisez Java, vous devriez être capable d’utiliser le JavaScript sans grand mal. Il n’est pas nécessaire de devenir un exemple en la matière, mais nous vous invitons tout de même à vous familiariser avec la langage au besoin. Un point d’entrée est le livre en ligne Programmation JavaScript chez wikibooks (gratuit). Par ailleurs, dans ce cas il vous faudra apprendre à manipuler des documents XML, notamment en utilisant l’interface DOM. Cette même interface est utilisée en Java et en JavaScript. Nous y reviendrons. Pour l’instant, faites l’exercice suivant. Enregistrez le fichier XHTML suivant sur disque et consultez-le. \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.1//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Un petit test\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Honoré de Balzac est né en...\u0026lt;/p\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;agebalzac\u0026#34; onclick=\u0026#34;javascript:document.getElementById(\u0026#39;reponse1\u0026#39;).style.display = \u0026#39;block\u0026#39;;\u0026#34; /\u0026gt; 1799. \u0026lt;span id=\u0026#34;reponse1\u0026#34; style=\u0026#34;display:none;font-weight:bold;\u0026#34; class=\u0026#34;feedback\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; (Réponse correcte!) \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;agebalzac\u0026#34; onclick=\u0026#34;javascript:document.getElementById(\u0026#39;reponse2\u0026#39;).style.display = \u0026#39;block\u0026#39;;\u0026#34; /\u0026gt; 1832. \u0026lt;span id=\u0026#34;reponse2\u0026#34; style=\u0026#34;display:none;font-weight:bold;\u0026#34; class=\u0026#34;feedback\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; (Réponse incorrecte!) \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;agebalzac\u0026#34; onclick=\u0026#34;javascript:document.getElementById(\u0026#39;reponse3\u0026#39;).style.display = \u0026#39;block\u0026#39;;\u0026#34; /\u0026gt; 1910. \u0026lt;span id=\u0026#34;reponse3\u0026#34; style=\u0026#34;display:none;font-weight:bold;\u0026#34; class=\u0026#34;feedback\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; (Réponse incorrecte!) \u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Enregistrez le contenu dans un fichier avec l’encodage UTF-8. Le résultat devrait avoir la forme suivante : Honoré de Balzac est né en... 1799. (Réponse correcte!) 1832. (Réponse incorrecte!) 1910. (Réponse incorrecte!) Familiarisez-vous avec le code JavaScript en ajoutant une seconde question. Peut-être est-ce que vous pourriez demander où Balzac a vécu. Portez une attention particulière aux attributs « id » ainsi qu’à la fonction « document.getElementById ». "},{"id":49,"href":"/orientee_donnees/legacy/semaine_15/examen/","title":"Examen","section":"Semaine 15","content":" Examen Vous avez complété les quinze semaines de cours, réalisé toutes les activités d’autoévaluation et tenu compte des rétroactions reçues à vos cinq travaux notés. Félicitations ! C’est maintenant le temps de passer votre examen final. L’examen compte pour 40 % de la note du cours et comporte 5 questions, lesquelles portent sur le contenu couvert par les travaux. La correction de l’examen est rigoureuse : vous devez décrire le comportement exact des programmes et pouvoir répondre aux questions de façon aussi précise que durant les travaux. Durant l’examen, vous avez droit à vos notes de cours et à tout autre document. Cependant, il est important d’avoir lu tous les textes et d’avoir fait toutes les activités d’autoévaluation du cours avant de cliquer sur le lien ci-dessous. Bonne chance! Pour passer votre examen Pour continuer vos études INF 2007 : Programmation avancée INF 6460 : recherche d'informations INF 9004 : Entrepôts de données INF 2020 : programmation en Python "},{"id":50,"href":"/orientee_donnees/legacy/semaine_5/familiarisation_avec_epub/","title":"Familiarisation avec EPUB","section":"Semaine 5","content":" Familiarisation avec EPUB # La semaine prochaine, nous étudierons le format EPUB. Afin de préparer ces travaux, nous vous invitons à faire les lectures préparatoires suivantes :\nLa page Wikipedia sur les livres électroniques La page Wikipedia sur EPUB La page Wikipedia sur Projet Gutenberg Par ailleurs, vous devriez visiter le site du projet Gutenberg et consulter quelques livres électroniques.\n"},{"id":51,"href":"/orientee_donnees/docs/modules/a_module_json/gjson/","title":"Google Gson","section":"Module JSON","content":" Activité JSON avec Gson # Gson est une bibliothèque Java puissante et largement utilisée pour la manipulation de données JSON. Développée par Google, elle facilite la conversion entre objets Java et représentations JSON, permettant aux développeurs de travailler avec des structures de données complexes sans se soucier des détails de parsing manuel. Que ce soit pour consommer des API REST, stocker des configurations ou échanger des données entre systèmes, Gson offre une API simple et intuitive.\nUn des aspects clés de Gson est son utilisation de la réflexion Java (reflection). La réflexion permet à Gson d\u0026rsquo;inspecter dynamiquement les classes et leurs champs à l\u0026rsquo;exécution, sans nécessiter d\u0026rsquo;annotations spéciales ou de code boilerplate. Cela signifie que Gson peut automatiquement mapper les propriétés d\u0026rsquo;un objet Java vers des clés JSON et vice versa, en accédant même aux champs privés grâce aux mécanismes de réflexion. Cette approche rend Gson très flexible et réduit considérablement le code nécessaire pour la sérialisation et désérialisation.\nCependant, l\u0026rsquo;utilisation de la réflexion a aussi des implications en termes de performance et de sécurité. La réflexion peut être plus lente que des approches compilées, et elle nécessite souvent des permissions spéciales dans les environnements sécurisés comme les applets ou les applications Android avec restrictions. Malgré ces considérations, la simplicité et la puissance de Gson en font un choix populaire pour de nombreux projets Java, équilibrant facilité d\u0026rsquo;utilisation et fonctionnalités avancées.\nUtilisation de Google Gson pour le traitement JSON en Java # Google Gson est une bibliothèque Java open-source populaire développée par Google pour convertir des objets Java en JSON (sérialisation) et du JSON en objets Java (désérialisation).\nMaven est un outil de gestion et d\u0026rsquo;automatisation de build pour les projets Java. Il simplifie la gestion des dépendances (bibliothèques externes), la compilation, les tests et le packaging des applications. En déclarant les dépendances dans un fichier pom.xml, Maven télécharge automatiquement les bibliothèques nécessaires depuis des dépôts centraux, évitant les conflits de versions et facilitant le partage de projets.\nPour l\u0026rsquo;inclure dans un projet Maven, ajoutez la dépendance suivante.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.code.gson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.13.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Sérialisation et désérialisation de base # La sérialisation convertit un objet Java en chaîne JSON. La désérialisation fait l\u0026rsquo;inverse. Par défaut, Gson sérialise les champs privés, exclut les champs transient et static, et omet les valeurs null. Les champs transient en Java ne sont pas destinés à être sauvegardé.\nVoici un exemple autonome.\nExempleBasique.java import com.google.gson.Gson; class Personne { private String nom; private int age; private transient String motDePasse; // Sera ignoré public Personne(String nom, int age, String motDePasse) { this.nom = nom; this.age = age; this.motDePasse = motDePasse; } } public class ExempleBasique { public static void main(String[] args) { Gson gson = new Gson(); Personne personne = new Personne(\u0026#34;Alice\u0026#34;, 30, \u0026#34;secret\u0026#34;); // Sérialisation String json = gson.toJson(personne); System.out.println(\u0026#34;JSON sérialisé :\u0026#34;); System.out.println(json); // Désérialisation Personne deserialisee = gson.fromJson(json, Personne.class); } } Exécuter L\u0026rsquo;exécution de ce code affiche un JSON compact sans le champ transient, puis reconstruit l\u0026rsquo;objet.\nMise en forme jolie et inclusion des null # Pour une sortie lisible, utilisez la mise en forme jolie. Pour inclure les champs null, configurez le builder.\nExempleMiseEnForme.java import com.google.gson.Gson; import com.google.gson.GsonBuilder; class Livre { private String titre; private String auteur; private Integer pages; // Peut être null public Livre(String titre, String auteur, Integer pages) { this.titre = titre; this.auteur = auteur; this.pages = pages; } } public class ExempleMiseEnForme { public static void main(String[] args) { Gson gson = new GsonBuilder() .setPrettyPrinting() .serializeNulls() .create(); Livre livre = new Livre(\u0026#34;Programmation Java\u0026#34;, \u0026#34;John Doe\u0026#34;, null); String json = gson.toJson(livre); System.out.println(\u0026#34;JSON mis en forme avec nulls :\u0026#34;); System.out.println(json); } } Exécuter Cela affiche un JSON formaté, incluant le champ \u0026ldquo;pages\u0026rdquo; null.\nGestion des collections et génériques # Gson sérialise facilement les collections, mais nécessite des informations de type pour la désérialisation des génériques en raison de l\u0026rsquo;effacement de type. Utilisez TypeToken pour cela.\nExempleCollections.java import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; import java.lang.reflect.Type; import java.util.ArrayList; import java.util.List; public class ExempleCollections { public static void main(String[] args) { Gson gson = new Gson(); List\u0026lt;String\u0026gt; fruits = new ArrayList\u0026lt;\u0026gt;(); fruits.add(\u0026#34;Pomme\u0026#34;); fruits.add(\u0026#34;Banane\u0026#34;); fruits.add(\u0026#34;Orange\u0026#34;); // Sérialisation String json = gson.toJson(fruits); System.out.println(\u0026#34;Liste sérialisée :\u0026#34;); System.out.println(json); // Désérialisation Type typeListe = new TypeToken\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(){}.getType(); List\u0026lt;String\u0026gt; deserialisee = gson.fromJson(json, typeListe); System.out.println(\u0026#34;\\nListe désérialisée :\u0026#34;); System.out.println(deserialisee); } } Exécuter Cela fonctionne de manière similaire pour les tableaux, sets, maps et autres collections.\nObjets imbriqués # Gson gère automatiquement les hiérarchies d\u0026rsquo;objets.\nExempleObjetsImbriques.java import com.google.gson.Gson; class Adresse { private String ville; private String pays; public Adresse(String ville, String pays) { this.ville = ville; this.pays = pays; } } class Employe { private String nom; private Adresse adresse; public Employe(String nom, Adresse adresse) { this.nom = nom; this.adresse = adresse; } } public class ExempleObjetsImbriques { public static void main(String[] args) { Gson gson = new Gson(); Adresse adresse = new Adresse(\u0026#34;New York\u0026#34;, \u0026#34;USA\u0026#34;); Employe employe = new Employe(\u0026#34;Bob\u0026#34;, adresse); String json = gson.toJson(employe); System.out.println(\u0026#34;Objet imbriqué sérialisé :\u0026#34;); System.out.println(json); Employe deserialise = gson.fromJson(json, Employe.class); } } Exécuter Noms de champs personnalisés avec @SerializedName # Utilisez l\u0026rsquo;annotation @SerializedName pour des noms de champs JSON différents.\nExempleSerializedName.java import com.google.gson.Gson; import com.google.gson.annotations.SerializedName; class Produit { @SerializedName(\u0026#34;product_id\u0026#34;) private int id; @SerializedName(\u0026#34;product_name\u0026#34;) private String nom; public Produit(int id, String nom) { this.id = id; this.nom = nom; } } public class ExempleSerializedName { public static void main(String[] args) { Gson gson = new Gson(); Produit produit = new Produit(101, \u0026#34;Ordinateur portable\u0026#34;); String json = gson.toJson(produit); System.out.println(\u0026#34;JSON avec noms personnalisés :\u0026#34;); System.out.println(json); Produit deserialise = gson.fromJson(json, Produit.class); } } Exécuter Exclusion de champs avec @Expose # Configurez Gson pour sérialiser uniquement les champs annotés avec @Expose.\nExempleExpose.java import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.google.gson.annotations.Expose; class Utilisateur { @Expose private String nomUtilisateur; private String motDePasse; // Non exposé public Utilisateur(String nomUtilisateur, String motDePasse) { this.nomUtilisateur = nomUtilisateur; this.motDePasse = motDePasse; } } public class ExempleExpose { public static void main(String[] args) { Gson gson = new GsonBuilder() .excludeFieldsWithoutExposeAnnotation() .create(); Utilisateur utilisateur = new Utilisateur(\u0026#34;charlie\u0026#34;, \u0026#34;caché\u0026#34;); String json = gson.toJson(utilisateur); System.out.println(\u0026#34;JSON avec uniquement les champs exposés :\u0026#34;); System.out.println(json); } } Exécuter Activité # Nous vous invitons maintenant à faire une activité pratique avec la librairie Java Gson. L'activité vous amènera sur la plateforme GitHub et vous devrez utiliser Maven. Cette démarche ressemble à une activité industrielle. "},{"id":52,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/le_fichier_sitemapxml/","title":"Le fichier sitemap.xml","section":"Exemples","content":" Le fichier sitemap.xml # Le sitemap.xml est un fichier au format XML qui liste les URLs importantes d\u0026rsquo;un site web afin d\u0026rsquo;aider les moteurs de recherche (Google, Bing, etc.) à découvrir et indexer plus efficacement ses pages. Il est particulièrement utile pour les sites volumineux, les nouveaux sites ou ceux qui possèdent beaucoup de contenu difficilement accessible par les liens internes classiques. Bien qu\u0026rsquo;il ne garantisse pas l\u0026rsquo;indexation de toutes les pages listées, il constitue un signal fort pour les crawlers et améliore généralement la couverture du site. Ce fichier doit être placé à la racine du site et suivre le protocole officiel défini sur sitemaps.org. On peut y indiquer pour chaque URL la date de dernière modification (\u0026lt;lastmod\u0026gt;), la fréquence de mise à jour estimée (\u0026lt;changefreq\u0026gt;), et une priorité relative (\u0026lt;priority\u0026gt;) entre 0.0 et 1.0. Depuis quelques années, il est aussi possible d\u0026rsquo;utiliser des sitemaps vidéo, image, news ou même des index de sitemaps quand le fichier dépasse 50 000 URLs ou 50 Mo. Voici un exemple simple de sitemap.xml contenant quatre pages :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34;\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://www.example.com/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2025-12-01\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;daily\u0026lt;/changefreq\u0026gt; \u0026lt;priority\u0026gt;1.0\u0026lt;/priority\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://www.example.com/a-propos/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2025-11-15\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;monthly\u0026lt;/changefreq\u0026gt; \u0026lt;priority\u0026gt;0.8\u0026lt;/priority\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://www.example.com/blog/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2025-12-04\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;priority\u0026gt;0.9\u0026lt;/priority\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://www.example.com/contact/\u0026lt;/loc\u0026gt; \u0026lt;changefreq\u0026gt;yearly\u0026lt;/changefreq\u0026gt; \u0026lt;priority\u0026gt;0.5\u0026lt;/priority\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;/urlset\u0026gt; Activité # Pouvez-vous vérifier si le site de teluq.ca a un fichier sitemap.xml ?\nPrenez quelques secondes pour exécuter le programme suivant dans votre navigateur.\nSitemapViewer.java import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.nio.charset.StandardCharsets; public class SitemapViewer { public static void main(String[] args) { String urlString = \u0026#34;https://teluq.ca/sitemap.xml\u0026#34;; try { URL url = new URL(urlString); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setInstanceFollowRedirects(true); // Ouvrir la connexion et lire le contenu ligne par ligne try (BufferedReader reader = new BufferedReader( new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) { System.out.println(\u0026#34;Contenu de \u0026#34; \u0026#43; urlString \u0026#43; \u0026#34; (premières 20 lignes) :\\n\u0026#34;); String line; int count = 0; while ((line = reader.readLine()) != null \u0026\u0026 count \u0026lt; 20) { System.out.println(line); count\u0026#43;\u0026#43;; } if (count == 20) { System.out.println(\u0026#34;... (tronqué pour la démonstration)\u0026#34;); } } } catch (Exception e) { System.err.println(\u0026#34;Erreur lors du chargement du sitemap : \u0026#34; \u0026#43; e.getMessage()); e.printStackTrace(); } } } Exécuter "},{"id":53,"href":"/orientee_donnees/docs/modules/d_module_html/","title":"Module HTML, CSS, SVG, MathML","section":"Modules","content":" Module HTML, CSS, SVG, MathML # Ce module explore les technologies de présentation web : HTML5 pour la structure des pages, CSS (niveaux 2 et 3) pour le style et la mise en forme, SVG pour les graphiques vectoriels évolutifs, MathML pour l\u0026rsquo;affichage d\u0026rsquo;expressions mathématiques, et XHTML comme variante XML de HTML. Il inclut des laboratoires pratiques, des auto-évaluations, et des exemples d\u0026rsquo;intégration (par exemple, CSS avec MathML).\nUn problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l\u0026rsquo;amélioration du cours.\n"},{"id":54,"href":"/orientee_donnees/legacy/semaine_12/problemes_resolus/","title":"Problèmes résolus","section":"Semaine 12","content":" Problèmes résolus Deux problèmes avec solution Pour vous aider à maîtriser le modèle DOM, nous vous proposons deux problèmes et une solution possible pour chacun. Problème 1 Créez une classe « Arbre » (fichier « Arbre.java ») qui donne l'arbre DOM d'un document XML. Pour chaque nœud, donnez son nom et sa valeur (indices : « getNodeName », « get NodeValue »). Enfin, indentez les nœuds selon le nombre de parents qu'ils ont. Ainsi, étant donné le fichier « test.xml » suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;joueur\u0026gt;\u0026lt;nom surnom=\"jojo\"\u0026gt;Jean\u0026lt;/nom\u0026gt;\u0026lt;buts\u0026gt;32\u0026lt;/buts\u0026gt;\u0026lt;/joueur\u0026gt; La commande « java Arbre test.xml » devrait afficher à l'écran le résultat suivant : Nom: #document Valeur: null Nom: joueur Valeur: null Nom: nom Valeur: null Nom: #text Valeur: Jean Nom: buts Valeur: null Nom: #text Valeur: 32 Problème 2 Nous pouvons utiliser un fichier XML comme archive d'une base de données primitive. Cette fois-ci, nous vous demandons d'écrire un programme qui permet de chercher, d'effacer et d'ajouter des noms dans un bottin téléphonique. Stockez les numéros dans un fichier XML nommé « bottin.xml » et ayant le contenu qui suit : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;bottin\u0026gt; \u0026lt;personne nom=\"Jean Réjean\" téléphone=\"432-4421\" /\u0026gt; \u0026lt;personne nom=\"Jules Desche\" téléphone=\"432-4332\" /\u0026gt; \u0026lt;/bottin\u0026gt; Concevez un programme dont le code source sera contenu dans un fichier nommé « Bottin.java ». Votre programme doit posséder les trois fonctions suivantes : « java Bottin efface \"Jean Réjean\" » : élimine du fichier « bottin.xml » tout élément « personne » ayant comme attribut « nom=\"Jean Réjean\" ». « java Bottin cherche \"Jean Réjean\" » : donne le numéro de téléphone correspondant au nom donné à partir du contenu du fichier « bottin.xml », et ne retourne rien si le nom donné n'est pas trouvé. « java Bottin ajoute \"Jean Réjean\" 432-4421 » : fait en sorte que le nom « Jean Réjean » soit associé au seul numéro de téléphone « 432-4421 ». Vous pouvez supposer que le fichier « bottin.xml » existe et se trouve dans le même répertoire que le fichier « Bottin.java ». Vous pouvez également supposer que l'élément-racine est « bottin ». "},{"id":55,"href":"/orientee_donnees/legacy/semaine_14/travail_5/","title":"Travail 5","section":"Semaine 14","content":" Travail 5 Consignes Lorsque vous aurez terminé le travail, transmettez à votre personne tutrice, un seul document (Word 97/2000/XP, ODF , PDF, RTF ou en format texte) comprenant, pour chaque exercice, le tableau, le code ou le contenu de votre document XSLT. Ne transmettez pas vos solutions en plusieurs fichiers. Ne transmettez pas une archive compressée (zip ou autre). Il s'agit d'un travail personnel et vous ne devez pas partager vos solutions. Vous devez transmettre votre travail en utilisant l'outil de dépôt de l'Université. Cette activité notée compte pour 10% de la note globale. Dans un tableau de triplets, les objets qui ne sont pas des URI, doivent être placés entre guillements (\" \"). Exercice 1 Représentez, dans un tableau de triplets (sujet, verbe, objet), le document RDF/XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:md=\"http://www.mondomaine.com/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"https://www.uqam.ca/\"\u0026gt; \u0026lt;md:titre\u0026gt;Site de l'UQAM\u0026lt;/md:titre\u0026gt; \u0026lt;md:autre rdf:resource=\"https://www.uqam.ca/index.html\" /\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Exercice 2 Écrivez un programme Java qui utilise l'API DOM pour extraire tous les titres des items d'un document RSS 1.0. Vous pouvez supposer que le fichier réside sur votre disque. Ne joignez pas un fichier à l'extension java. Exercice 3 Représentez, dans un tableau de triplets (sujet, verbe, objet), l'exemple en RDF qui suit et qui provient de la norme PRISM . \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:pcv=\"http://prismstandard.org/namespaces/pcv/1.0/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\u0026gt; \u0026lt;rdf:Description rdf:about=\"https://wanderlust.com/2000/08/Corfu.jpg\"\u0026gt; \u0026lt;dc:identifier rdf:resource=\"https://wanderlust.com/content/2357845\" /\u0026gt; \u0026lt;dc:creator\u0026gt; \u0026lt;pcv:Descriptor rdf:about=\"https://wanderlust.com/emp3845\"\u0026gt; \u0026lt;pcv:label\u0026gt;John Peterson \u0026lt;/pcv:label\u0026gt; \u0026lt;/pcv:Descriptor\u0026gt; \u0026lt;/dc:creator\u0026gt; \u0026lt;dc:coverage\u0026gt; \u0026lt;pcv:Descriptor rdf:about=\"https://prismstandard.org/vocabs/ISO-3166/GR\"\u0026gt; \u0026lt;pcv:label xml:lang=\"en\"\u0026gt;Greece\u0026lt;/pcv:label\u0026gt; \u0026lt;pcv:label xml:lang=\"fr\"\u0026gt;Grece\u0026lt;/pcv:label\u0026gt; \u0026lt;/pcv:Descriptor\u0026gt; \u0026lt;/dc:coverage\u0026gt; \u0026lt;/rdf:Description\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Exercice 4 Ecrivez un document XML/RDF correspondant au tableau suivant : Sujet Verbe Objet https://www.uqam.ca https://www.uquebec.ca/nom \"UQÀM\" Exercice 5 La licence identifiée par l'URI « https://www.mondomaine.ca/licence » permet la reproduction, la distribution et la modification des œuvres. Décrivez cette licence en utilisant Creative Commons et le format RDF/XML. Exercice 6 Le site flickr permet de chercher des photographies publiées avec une licence Creative Commons. Visitez la page https://www.flickr.com/photos/guppiecat/1351724368/in/set-72157601927001088/ et trouvez la licence Creative Commons. Écrivez-la en XML. Exercice 7 L' archive institutionelle de la TÉLUQ donne accès aux articles scientifiques de ses professeurs. Choisissez un article (à votre guise) et consultez le code source HTML de la page web correspondante. Vous y trouverez des étiquettes Dublin Core. Écrivez le tout en XML. "},{"id":56,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/un_peu_plus_de_xslt_fonctionnement_de_base_template_et_value-of/","title":"Un peu plus de XSLT : fonctionnement de base, template et value-of","section":"XSLT","content":" Un peu plus de XSLT : fonctionnement de base, template et value-of # « Éléments xsl:template » # Dans cette section, nous explorons les éléments xsl:template, qui sont essentiels pour définir des règles de transformation personnalisées dans les feuilles de style XSLT.\nModifions maintenant le fichier « xslt.xml » de façon à rendre l\u0026rsquo;expérience plus intéressante. Tout d\u0026rsquo;abord, traitons tous les éléments « facture » du document XML. Pour obtenir le résultat, il faut placer un élément « \u0026lt;xsl:template match=\u0026ldquo;facture\u0026rdquo;\u0026gt; » dans l\u0026rsquo;élément-racine du document XSLT comme ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; On doit mettre quelque chose ici!!! \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Il faut voir l\u0026rsquo;élément « xsl:template » comme une règle qui dit : à chaque fois qu\u0026rsquo;on rencontre un élément qui s\u0026rsquo;appelle « facture », faisons ceci. Le modèle est inclus dans l\u0026rsquo;élément « xsl:template ». Dans l\u0026rsquo;exemple de document XSLT que nous venons de voir, le processeur XSLT remplacerait tous les éléments « facture » qu\u0026rsquo;il rencontre par le texte « On doit mettre quelque chose ici!!! », ce qui donnerait comme résultat le fichier suivant (le résultat exact peut varier un peu selon le processeur XSLT) :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; On doit mettre quelque chose ici!!! Malheureusement, ce n\u0026rsquo;est pas du HTML valide et votre navigateur devrait n\u0026rsquo;afficher qu\u0026rsquo;un écran vide ou une erreur si vous tentez d\u0026rsquo;ouvrir le fichier « test.xml » avec un lien vers un tel fichier XSLT. (En pratique, le navigateur peut interpréter le résultat différemment.) Notre laboratoire XSLT en ligne risque d\u0026rsquo;ailleurs de vous donner une erreur, car il ne comprendra pas que vous génériez autre chose que du XML ou du HTML (mais on peut remédier à ce problème avec une instruction output, nous y reviendrons). Nous allons donc modifier le fichier XSLT, en ajoutant des balises, comme ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;On doit mettre quelque chose ici!!!\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Cette fois, si vous ouvrez le document « test.xml », vous devriez voir le texte « On doit mettre quelque chose ici!!! » s\u0026rsquo;afficher dans votre navigateur. Faites l\u0026rsquo;expérience.\nDans les exemples que nous allons proposer, nous omettons les éléments « html » et « body » par souci de simplicité. La présence de ces éléments n\u0026rsquo;est pas nécessaire et n\u0026rsquo;est utile que pour afficher le résultat dans un navigateur. À vous de les ajouter si vous désirez afficher le résultat.\nPour résumer, chaque fois que le processeur XSLT rencontre un élément « facture », il applique le modèle qui se trouve dans l\u0026rsquo;élément « \u0026lt;xsl:template match=\u0026ldquo;facture\u0026rdquo;\u0026gt; ». Notez que si l\u0026rsquo;élément « facture » contient lui-même des éléments, ils ne sont pas automatiquement visités par le processeur XSLT. Ce dernier considère que dès qu\u0026rsquo;un modèle est appliqué à un élément, il peut alors parcourir le reste du document sans se soucier du contenu de cet élément qui est maintenant « couvert », à moins qu\u0026rsquo;on lui dise explicitement de traiter les noeuds-enfants avec une instruction comme apply-template. Le XSLT est très bête: il part de la racine et applique les règles à ce qu\u0026rsquo;il rencontre.\n« Éléments xsl:value-of » # Dans cette section, nous découvrons les éléments xsl:value-of, qui permettent d\u0026rsquo;extraire et d\u0026rsquo;insérer le contenu textuel des éléments XML dans le résultat de la transformation.\nJusqu\u0026rsquo;à présent, le résultat n\u0026rsquo;est pas très fascinant parce que les éléments « xsl:template » ont été utilisés comme des outils pour faire du « Rechercher/Remplacer ». Le contenu de l\u0026rsquo;élément « facture » n\u0026rsquo;est pas traité, on le remplace bêtement par autre chose.\nNous pouvons traiter le contenu d\u0026rsquo;un élément à l\u0026rsquo;aide d\u0026rsquo;un élément « xsl:value-of » avec la syntaxe \u0026lt;xsl:value-of select=\u0026quot;\u0026hellip;\u0026quot; /\u0026gt;. La valeur de l\u0026rsquo;élément « select » est une expression XPath. Par exemple, si le processeur traite un élément « facture » qui contient un élément « montant », alors l\u0026rsquo;élément \u0026lt;xsl:value-of select=\u0026ldquo;montant\u0026rdquo; /\u0026gt; nous donne le contenu de l\u0026rsquo;élément « montant ». C\u0026rsquo;est ainsi que nous pouvons trouver le nom de la personne devant recevoir une facture, en utilisant \u0026lt;xsl:value-of select=\u0026ldquo;personne\u0026rdquo; /\u0026gt;.\nVoyons maintenant un exemple plus complexe de fichier XSLT :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Ceci est une facture pour \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt; de \u0026lt;xsl:value-of select=\u0026#34;montant\u0026#34; /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\u0026#34;raison\u0026#34; /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Si vous modifiez le fichier « xslt.xml » et que vous ouvrez le fichier « test.xml » dans un navigateur supportant le XSLT, vous devriez voir s\u0026rsquo;afficher à l\u0026rsquo;écran la ligne « Ceci est une facture pour Jean Rochond de 10.10$ pour: Achat d\u0026rsquo;ordinateur. ». Il faut avouer que c\u0026rsquo;est déjà beaucoup plus intéressant comme application!\nCe qui se passe, c\u0026rsquo;est que le nouveau document XSLT transforme notre document XML en un document HTML :\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Facture de Jean Rochond\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;p\u0026gt;Ceci est une facture pour Jean Rochond de 10.10$ pour: Achat d\u0026#39;ordinateur.\u0026lt;/p\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Pour résumer, nous pouvons aller chercher le contenu textuel d\u0026rsquo;une expression XPath avec une instruction comme « \u0026lt;xsl:value-of select=\u0026quot;\u0026hellip;\u0026quot; /\u0026gt; » où « \u0026hellip; » est une expression XPath comme le nom de l\u0026rsquo;élément.\nModèle de traitement XSLT # Dans cette section, nous examinons le modèle de traitement sous-jacent du XSLT, expliquant comment le processeur parcourt le document XML et applique les règles de transformation.\nUne source de confusion commune avec le XSLT est une mauvaise appréciation du modèle de traitement. Certains s\u0026rsquo;imaginent que le XSLT visite les règles une à une, les appliquant à tout le document. Ainsi, la règle de type «xsl:template match=\u0026ldquo;facture\u0026rdquo;» devrait, selon eux, s\u0026rsquo;appliquer à tous les éléments de type facture. Or, ce n\u0026rsquo;est pas le cas du tout en général. Le processeur XSLT visite les noeuds un à un. Quand il visite un noeud, il cherche la règle qui s\u0026rsquo;applique. Il est donc parfaitement possible que plusieurs des règles inscrites dans un document XSLT ne s\u0026rsquo;appliquent jamais. Un processeur XSLT traite un fichier XML en partant du début et en appliquant ses règles au fur et à mesure qu\u0026rsquo;il rencontre des noeuds. Rappelons que\nsi le processeur XSLT rencontre un élément pour lequel il n\u0026rsquo;a aucune règle (modèle), il visite les sous-éléments à leur tour, c\u0026rsquo;est une de ses règles par défaut.\nUne autre façon de décrire ce comportement est de dire que le XSLT utilise un modèle de fichiers XML « en arbre de nœuds ». Imaginons un arbre où, à la racine, se trouve un nœud spécial représentant le document dans son ensemble. Avec XPath, nous pouvons pointer directement sur le nœud-racine (le document lui-même) en utilisant la barre oblique « / » que nous plaçons au début de l\u0026rsquo;expression XPath, comme dans « \u0026lt;xsl:value-of select=\u0026quot;/\u0026quot; /\u0026gt; ». Dans ce cas, « \u0026lt;xsl:value-of select=\u0026quot;/jean\u0026quot; /\u0026gt; » donne la valeur de l\u0026rsquo;élément-racine, si celui-ci se nomme « jean ».\nLe nœud-racine contient lui-même l\u0026rsquo;élément-racine. Chaque élément et chaque élément de texte sont aussi des nœuds dans ce modèle d\u0026rsquo;arbre XSLT. Alors que les nœuds de texte ne peuvent pas contenir d\u0026rsquo;autres nœuds, les nœuds d\u0026rsquo;élément peuvent contenir plusieurs autres nœuds dont d\u0026rsquo;autres nœuds d\u0026rsquo;élément et de texte.\nAinsi, par défaut, le processeur XSLT qui atteint un élément visite tous les éléments et les nœuds de texte qu\u0026rsquo;il contient. Un nœud de texte rencontré est simplement recopié, par défaut, alors que pour les éléments, on visite également leur contenu. C\u0026rsquo;est ce qui explique que, par défaut, s\u0026rsquo;il n\u0026rsquo;y a aucune règle dans le document XSLT, un document XML est recopié sans les balises.\nD\u0026rsquo;autres nœuds existent comme les nœuds de commentaire, les nœuds d\u0026rsquo;instructions de traitement et les nœuds d\u0026rsquo;espaces de noms,\nmais ils sont moins importants que le nœud du document (nœud-racine), les nœuds d\u0026rsquo;attribut, les nœuds de texte ou les nœuds d\u0026rsquo;élément. Dans le modèle d\u0026rsquo;arbre, les nœuds d\u0026rsquo;espaces de noms et les nœuds d\u0026rsquo;attribut sont attachés à l\u0026rsquo;élément, mais ne sont pas un enfant (« child »).\nNous avons déjà vu que « * » et « @* » permettaient de sélectionner les sous-éléments et attributs d\u0026rsquo;un élément. On peut sélectionner les nœuds de texte avec la fonction XPath « text() ». Notons aussi que l\u0026rsquo;élément « xsl:apply-templates/ » signifie que les modèles s\u0026rsquo;appliquent à tous les nœuds contenus dans le nœud courant. Les règles par défaut qui s\u0026rsquo;appliquent en XSLT sont :\n\u0026lt;xsl:template match=\u0026#34;*|/\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;text()|@*\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34;/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;processing-instruction()|comment()\u0026#34; /\u0026gt; La première règle (ou instruction) indique que si on rencontre un élément ou la racine du document, on applique tout simplement les autres instructions aux noeuds que l\u0026rsquo;on y trouve. La seconde règle indique que si on trouve un noeud de texte ou un attribut, on retourne tout simplement la valeur textuelle du noeud. Finalement, la dernière règle indique que si on trouve un commentaire ou une instruction de traitement, on n\u0026rsquo;en traite pas le contenu. Un processeur XSLT représente un document XML comme un arbre et tente de le visiter de la racine vers les feuilles. Lorsqu\u0026rsquo;il rencontre un modèle pour un nœud, il l\u0026rsquo;applique et ne poursuit pas automatiquement la visite des nœuds qui y sont contenus, à moins de rencontrer un élément « xsl:apply-templates ».\nPar défaut, un traitement XSLT va extraire le contenu textuel du document XML provenant des noeuds de texte et des attributs. Le produit final sera un aggrégat de tout le contenu textuel ainsi extrait.\nRécapitulons. Le XSLT fait ce qu\u0026rsquo;on lui dit de faire, rien de plus, rien de moins. Il commence avec la racine du document et applique les règles. Il est muni de règles de base lui indiquant quoi faire avec des éléments, des attributs, etc. Vous pouvez ajouter de nouvelles règles ou remplacer les règles de base.\nSi vous utilisez la règle suivant, indiquant au XSLT de ne rien faire à partir de la racine, alors il ne fera rien (rien ne sera généré).\n\u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;/xsl:template\u0026gt; Le XSLT applique de préférence vos règles plutôt que celles par défaut. Ainsi donc, si vous ajoutez la règle suivante\u0026hellip;\n\u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;.\u0026#34;/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026hellip; alors elle s\u0026rsquo;appliquera quand l\u0026rsquo;élément-racine (ou tout autre élément) de votre document sera visité. Comme cette règle n\u0026rsquo;indique pas de visiter les sous-éléments (par l\u0026rsquo;instruction apply-templates), ceux-ci ne seront pas visités. Dans un tel cas, tout ce qui sera produit sera la valeur textuelle de l\u0026rsquo;élément-racine. Le traitement XSLT s\u0026rsquo;arrêtera alors.\nCela illustre que le XSLT ne génère pas nécessairement du XML valide. Certains moteurs XSLT s\u0026rsquo;attendent à obtenir du XML ou du HTML (si l\u0026rsquo;élément-racine est nommé en conséquence) et peuvent générer une erreur dans le cas contraire. Certains moteurs peuvent même modifier le résultat de manière à ce qu\u0026rsquo;il s\u0026rsquo;agisse de XML ou du HTML valide. D\u0026rsquo;autres processeurs vont refuser de produire autre chose que du XML ou du HTML, à moins d\u0026rsquo;indication contraire.\nLes règles s\u0026rsquo;appliquent selon un ordre de priorité. Vos règles s\u0026rsquo;appliquent avant celles par défaut. Les règles spécifiques (nommant un élément XML par son nom) s\u0026rsquo;appliquent avant les règles génériques (par exemple, celles spécifiant le type de noeud comme « * »). Une disjonction ( « | ») est traitée comme un ensemble de règles distinctes. Si deux règles ont une priorité égale, le moteur XSLT peut choisir arbitrairement un des deux règles ou générer une erreur.\nUn exemple # Dans cette section, nous illustrons le fonctionnement du XSLT avec un exemple pratique montrant l\u0026rsquo;application des règles de transformation sur un document XML simple.\nPour illustrer le fonctionnement du XSLT, prenons un example. Soit ce document XML:\n\u0026lt;racine\u0026gt; \u0026lt;element\u0026gt; \u0026lt;souselement\u0026gt; \u0026lt;/souselement\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;element2\u0026gt; \u0026lt;souselement2\u0026gt; \u0026lt;/souselement2\u0026gt; \u0026lt;/element2\u0026gt; \u0026lt;/racine\u0026gt; Soit ce document XSLT:\n\u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;element\u0026#34;\u0026gt; Transformation 1 \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;souselement\u0026#34;\u0026gt; Transformation 2 \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;souselement2\u0026#34;\u0026gt; transformation3 \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Par souci de simplicité, nous allons ignorer les noeuds de texte de cet exemple. Il n'y a donc que des éléments. Le processeur débute au noeud racine. La règle par défaut s'applique et on l'instruit (avec apply-templates) de traiter tous les noeuds qu'il contient en séquence. Le processeur trouve alors l\u0026rsquo;élément nommé « racine ». La règle par défaut s\u0026rsquo;applique encore et le processeur visite simplement les noeuds contenus. Dans ce cas, il y en a deux (deux éléments).\nLe processeur va alors traiter l\u0026rsquo;élément nommé « element ». Dans ce cas, la règle que nous avons introduite dans notre document XSLT s\u0026rsquo;applique et le processeur XSLT émet la chaîne de caractères « Transformation 1 ». Notez que l\u0026rsquo;élément nommé souselement ne sera pas traité.\nLe processeur traite alors l\u0026rsquo;élément nommé « element2 ». La règle par défaut s\u0026rsquo;applique. Il visite donc l\u0026rsquo;élément «souselement2». La règle que nous avons introduite s\u0026rsquo;applique et le processeur émet «transformation3 ».\nLe résultat produit sera donc la chaîne de caractères «Transformation 1 transformation3 ».\nVous pouvez mettre cet exemple en marche dans votre navigateur.\nDocument XML source \u0026lt;?xml version=\"1.0\" ?\u0026gt; \u0026lt;racine\u0026gt; \u0026lt;element\u0026gt; \u0026lt;souselement\u0026gt; \u0026lt;/souselement\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;element2\u0026gt; \u0026lt;souselement2\u0026gt; \u0026lt;/souselement2\u0026gt; \u0026lt;/element2\u0026gt; \u0026lt;/racine\u0026gt; Feuille de style XSLT (ex. 1.0) \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:output method=\"text\"/\u0026gt; \u0026lt;xsl:template match=\"element\" \u0026gt; Transformation 1 \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"souselement\"\u0026gt; Transformation 2 \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"souselement2\"\u0026gt; transformation3 \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Résultat Cliquez sur « Transformer ». Transformer Réinitialiser Notez que nous avons ajouté une instruction «output» spécifiant un contenu textuel. Sans cette instruction, plusieurs processeurs XSLT seront confus par le résultat généré (celui-ci n\u0026rsquo;étant pas du XML) et ils peuvent générer une erreur. Vous noterez peut-être aussi que votre navigateur met le résultat textuel dans un document HTML. C\u0026rsquo;est un cas particulier où le processeur prend sur lui d\u0026rsquo;imposer un format. Dans le cas d\u0026rsquo;un navigateur web, il est justifiable d\u0026rsquo;exiger que le document produit soit du XML ou du HTML.\nAssurez-vous de bien comprendre cet exemple avant de continuer. Vous devez avoir une bonne représentation mentale de la manière dont fonctionne un processeur XSLT.\n"},{"id":57,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/xpath_second_laboratoire/","title":"XPath : second laboratoire","section":"XPath","content":" XPath : second laboratoire Il est temps de refaire un laboratoire XPath. Utilisez ce nouveau document XML et tentez de sélectionner différents numéros de téléphones, listes de clients, etc. en utilisant des expressions XPath appropriées. Instructions : il suffit de saisir un document XML source et une expression XPath et d'appuyer sur le bouton. Le contenu textuel de chaque résultat est retourné. L'expression XPath est toujours appliquée à partir du noeud-racine. Cette petite application est limitée: elle suppose que le résultat prend une certaine forme (un ensemble de noeuds ou node set). Fichier XML: \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;listes\u0026gt; \u0026lt;vendeur nom=\"Jean\"\u0026gt; \u0026lt;client telephone=\"543-5454\"\u0026gt;\u0026lt;nom\u0026gt;Jacques\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"545-5455\"\u0026gt;\u0026lt;nom\u0026gt;Sylvain\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"443-4456\"\u0026gt;\u0026lt;nom\u0026gt;Claude\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"533-3445\"\u0026gt;\u0026lt;nom\u0026gt;Yvon\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur nom=\"Raymond\"\u0026gt; \u0026lt;client telephone=\"432-2145\"\u0026gt;\u0026lt;nom\u0026gt;Arthur\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"545-5456\"\u0026gt;\u0026lt;nom\u0026gt;Sylvain\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"443-4556\"\u0026gt;\u0026lt;nom\u0026gt;Claudette\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;client telephone=\"533-3445\"\u0026gt;\u0026lt;nom\u0026gt;Yvon\u0026lt;/nom\u0026gt;\u0026lt;/client\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/listes\u0026gt; Sélection XPath: Résultat : "},{"id":58,"href":"/orientee_donnees/docs/modules/d_module_html/css2/","title":"CSS (partie 2)","section":"Module HTML, CSS, SVG, MathML","content":" CSS (partie 2) # Mais que se passe-t-il en cas de conflit ? # Plusieurs instructions peuvent s\u0026rsquo;appliquer en même temps : un texte peut être en rouge et souligné. Il peut arriver cependant que deux instructions CSS se contredisent. Par exemple, un texte ne peut être à la fois en rouge et en bleu. Dans ce cas, la sélection la plus spécifique l’emporte. Ainsi, dans l’exemple qui suit :\n* { color: black; } montant { color: red; } montant \u0026gt; montant { color: yellow; } les éléments « montant » seront en rouge, sauf s’ils sont immédiatement contenus dans un autre élément « montant », auquel cas ils seront en jaune.\nPar ailleurs, si deux sélections de même spécificité sont rencontrées, c’est la dernière qui l’emporte. Ainsi, dans l’exemple qui suit :\nmontant { color: red; } montant { color: black; } les éléments « montant » seront en noir.\nOn peut cependant forcer le navigateur à considérer une règle qui apparaît avant une autre comme ayant tout de même priorité (à spécificité égale). Il suffit d’utiliser la mention !important :\nmontant { color: red !important; } montant { color: black; } les éléments « montant » seront en rouge.\nNotez que la mention !important permet souvent d’ignorer la spécificité de la règle : les règles avec cette mention l’emportent toujours sur les autres (sauf si une autre règle avec !important a une plus grande spécificité, elle aura alors priorité).\nLes règles par défaut utilisées par votre navigateur dans le cas du HTML ou du XHTML sont lues en premier. De cette manière, toutes les règles que vous stipulez dans vos propres fichiers CSS ou directement dans le XML/HTML ont priorité pour une même spécificité. On peut considérer que les règles avec la mention !important sont lues en dernier dans la mesure où elles l’emportent toujours sur les autres.\nCalculer la spécificité des règles n’est pas une mince affaire, mais c’est pourtant nécessaire dans certains cas difficiles. La spécificité se mesure avec une valeur à 4 chiffres (a,b,c,d). Lorsqu’on compare deux spécificités (a1,b1,c1,d1) et (a2,b2,c2,d2), on utilise l’ordre lexicographique pour déterminer laquelle est supérieure.\nLa première valeur (a) vaut 1 si et seulement si la règle apparaît dans l’attribut style de l’élément lui-même. La seconde valeur (b) est le nombre de sélecteurs ID présents dans la règle. La troisième valeur (c) est le nombre d’autres sélecteurs d’attributs et de pseudo-classes. La quatrième valeur (d) est le nombre de sélecteurs de type élément et de pseudo-éléments. Exemple concret :\nz[x] \u0026gt; a[i] { color: blue; } /* spécificité : 0,0,2,2 */ z z[x] a { text-decoration: underline; } /* 0,0,1,3 */ z \u0026gt; z a , z z z + a { color: red ; } /* deux règles : 0,0,0,3 et 0,0,0,4 */ Le modèle de boîte CSS # En CSS, on peut spécifier la hauteur et la largeur d’un objet à l’aide des propriétés width et height. Par exemple, pour indiquer qu’un paragraphe ne doit avoir que 20 pixels de largeur :\np { width: 20px; } Le CSS supporte de nombreuses unités : px, cm, in, %, em, rem, etc.\nOn peut ensuite définir une marge (margin) autour de tout objet. La marge est une zone transparente où rien ne peut apparaître ; elle ne fait pas partie de l’objet lui-même.\np { margin-top: 10px; margin-bottom: 10px; margin-right: 10px; margin-left: 10px; } On peut aussi définir une région d’espacement interne (padding). Contrairement à la marge, le padding fait partie de l’objet : si vous définissez une couleur de fond, le padding sera coloré.\np { padding-top: 10px; padding-bottom: 10px; padding-right: 10px; padding-left: 10px; } On peut enfin ajouter une bordure (border) qui se place entre le padding et la marge :\np { border-color: black; border-width: medium; } Voici un diagramme qui résume le modèle de boîte CSS (le diagramme original étant en SVG, il n’est pas reproduit ici, mais il montre les zones suivantes de l’intérieur vers l’extérieur : contenu → padding → border → margin).\n../module3/box.pdf espacement (padding): espace laissé padding-right marge (margin): rien ne peut apparaître ici largeur de l'objet (width) Contenu ici padding-top margin-left margin:bottom rmargin-right margin-top vacant hauteur de l'objet (height) bordure (border) padding-left (Comme il se doit, ce diagramme est XML par l’entremise du SVG.)\n"},{"id":59,"href":"/orientee_donnees/docs/modules/d_module_html/css3/","title":"CSS (partie 3)","section":"Module HTML, CSS, SVG, MathML","content":" CSS (partie 3) # Quand le contenu excède le contenant # Il arrive qu’une image ou qu’un texte excède la taille de l’élément dans lequel il a été placé. Par défaut, ce contenu déborde visiblement (overflow: visible). La propriété overflow: hidden permet de contrôler ce comportement :\noverflow: hidden masque la partie qui dépasse. overflow: scroll ajoute des barres de défilement (même si le contenu tient dans la boîte). overflow: auto n’ajoute les barres que si nécessaire. Encodage des caractères # Il peut être utile de préciser l’encodage utilisé dans le fichier CSS en plaçant au tout premier ligne :\n@charset \u0026#34;UTF-8\u0026#34;; ou\n@charset \u0026#34;ISO-8859-1\u0026#34;; Différentes règles pour différents médias # On peut appliquer des règles CSS différentes selon le type de média avec @media :\n@media print, handheld { img { display: none; } h1 { color: black; } } @media screen, tv { h1 { color: blue; } } Sans @media, la règle s’applique à tous les médias.\nInclure d’autres fichiers CSS # Pour une approche modulaire, on peut importer d’autres feuilles de style avec @import (à placer après un éventuel @charset) :\n@import \u0026#34;mineure.css\u0026#34;; @import \u0026#34;print-mineure.css\u0026#34; print; Indentation de la première ligne d’un paragraphe # p { text-indent: 1cm; } Modifier la casse du texte # h1 { text-transform: uppercase; } /* TOUT EN MAJUSCULES */ h2 { text-transform: capitalize; } /* Première Lettre De Chaque Mot */ p { text-transform: lowercase; } /* tout en minuscules */ Autres variantes des polices # Quelques propriétés courantes :\nfont-style: italic; ou oblique font-weight: bold;, bolder;, lighter font-family: serif;, sans-serif;, \u0026quot;Trebuchet MS\u0026quot;, Arial, sans-serif font-size: small;, large;, 120%;, 1.2em text-decoration: underline;, overline;, line-through;, blink; cursor: pointer; (main pour les liens), text, wait, etc. Ajouter des compteurs # Exemple 1 – numérotation romaine des paragraphes entre chaque \u0026lt;h1\u0026gt; :\np { counter-increment: par-num; } h1 { counter-reset: par-num; } p:before { content: counter(par-num, upper-roman) \u0026#34;. \u0026#34;; } Exemple 2 – numérotation simple des titres \u0026lt;h1\u0026gt; :\nh1 { counter-increment: h1-num; } h1:before { content: counter(h1-num, decimal) \u0026#34;. \u0026#34;; } Traitement des retours de chariot # white-space: normal → comportement par défaut (les retours à la ligne du source sont ignorés) white-space: pre → préserve tous les espaces et retours à la ligne (utile pour du code) white-space: nowrap → empêche tout retour à la ligne automatique Des nouveautés en CSS 3 # CSS 3 introduit de nombreux nouveaux sélecteurs. Voici les plus utilisés :\nSélecteur Signification Niveau CSS * tout élément 2 E un élément de nom E 1 E[foo] élément E possédant l’attribut foo 2 E[foo=\u0026ldquo;bar\u0026rdquo;] attribut foo vaut exactement « bar » 2 E[foo~=\u0026ldquo;bar\u0026rdquo;] attribut foo contient le mot « bar » (séparé par espaces) 2 E[foo^=\u0026ldquo;bar\u0026rdquo;] attribut foo commence par « bar » 3 E[foo$=\u0026ldquo;bar\u0026rdquo;] attribut foo se termine par « bar » 3 E[foo*=\u0026ldquo;bar\u0026rdquo;] attribut foo contient la chaîne « bar » 3 E[foo =\u0026ldquo;bar\u0026rdquo;] attribut foo contient le mot « bar » (séparé par tirets) E F descendant F de E 1 E \u0026gt; F enfant direct F de E 2 E + F F immédiatement après un voisin E 2 E ~ F F après un voisin quelconque E 3 Grâce à ces sélecteurs, on peut par exemple cibler tous les liens externes :\na[href^=\u0026#34;http\u0026#34;] { /* indique un lien externe */ } CSS 3 permet aussi d’arrondir les coins :\n\u0026lt;span style=\u0026#34;border: 2px solid blue; border-radius: 25px; padding: 2px;\u0026#34;\u0026gt; Entoure-moi! \u0026lt;/span\u0026gt; ou de transformer géométriquement le texte :\np.rotated { transform: rotate(180deg); } p.mirror { transform: scale(-1, 1); } Optimisation des fichiers CSS # Un même effet peut souvent s’obtenir de façon plus concise en regroupant les déclarations communes :\nmontant, nom, texte { background: white; font-style: normal; } montant { color: red; font-weight: bold; text-align: center; } nom { color: white; text-align: left; } texte { color: black; text-align: left; } Des outils comme CSSTidy peuvent automatiser ce genre d’optimisation.\nEn terminant # La syntaxe CSS est extrêmement riche. Pour aller plus loin, consultez la référence officielle :\nhttps://developer.mozilla.org/fr/docs/Web/CSS\nLivres de référence # David Sawyer McFarland, CSS: The Missing Manual, O\u0026rsquo;Reilly Media, 2015, 718 pages. "},{"id":60,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/autoevaluation_xpath/","title":"Autoévaluation","section":"XPath","content":" Autoévaluation Question 1 . Quelle est la valeur de l'expression XPath « client.nom »? Choisissez la bonne réponse parmi les suivantes. Une séquence de tous les éléments « client.nom » dans le contexte actuel. (Réponse correcte!) Effectivement. Le point « . » perd ici sa signification de « contexte actuel », car il fait partie d'une chaîne de caractères désignant un nom d'élément. Tous les éléments « nom » contenus dans les éléments « client » qui se trouvent dans le contexte actuel. (Réponse incorrecte!) Non, ce serait « nom/client ». Les éléments « client » qui précèdent le contexte actuel, ainsi que les éléments « nom » qui suivent le contexte actuel. (Réponse incorrecte!) Cette explication n'a pas de sens. Question 2 . Quelle est la valeur de l'expression XPath « ./client »? Choisissez la bonne réponse parmi les suivantes. L'élément « client » qui se trouve dans le contexte actuel. (Réponse incorrecte!) Il pourrait y avoir aucun ou plusieurs éléments « client ». Une séquence de tous les éléments « client » dans le contexte actuel. (Réponse correcte!) Effectivement, le contexte pouvant être l'élément courant, par exemple. La séquence d'éléments peut être vide. Une séquence de tous les éléments et attributs « client » dans le contexte actuel. (Réponse incorrecte!) Non. Les attributs de nom « client » s'obtiennent avec la syntaxe « @client ». Question 3 . Quelle est la valeur de l'expression XPath « client »? Choisissez la bonne réponse parmi les suivantes. L'élément « client » qui se trouve dans le contexte actuel. (Réponse incorrecte!) Il pourrait y avoir aucun ou plusieurs éléments « client ». Une séquence de tous les éléments « client » dans le contexte actuel. (Réponse correcte!) Effectivement, le contexte pouvant être l'élément courant, par exemple. La séquence d'éléments peut être vide. On note que c'est la même signification que pour l'expression XPath « ./client ». Une séquence de tous les éléments et attributs « client » dans le contexte actuel. (Réponse incorrecte!) Non. Les attributs de nom « client » s'obtiennent avec la syntaxe « @client ». Question 4 . Quelle est la valeur de l'expression XPath « /client »? Choisissez la bonne réponse parmi les suivantes. L'élément « client » voisin de l'élément courant. (Réponse incorrecte!) Non, c'est plutôt vers l'élément-racine qu'on pointe. Le premier élément « client » rencontré dans le document. (Réponse incorrecte!) Ce serait plutôt « (//client)[1] ». L'élément-racine si celui-ci se nomme « client ». (Réponse correcte!) Vrai. Il retourne un ensemble vide dans le cas contraire. Question 5 . Quelle est la valeur de l'expression XPath « //client »? Choisissez la bonne réponse parmi les suivantes. Le deuxième élément « client » rencontré. (Réponse incorrecte!) Non, ce serait plutôt « client[2] ». La séquence de tous les éléments « client » du document. (Réponse correcte!) Effectivement. S'il n'y en a pas, cela donne un ensemble vide. L'élément-racine si celui-ci se nomme « client ». (Réponse incorrecte!) Non, ce serait plutôt « /client ». Question 6 . Quelle est la valeur de l'expression XPath « client[current()/@telephone=@telephone] »? Choisissez la bonne réponse parmi les suivantes. Les éléments « client » dans l'élément courant ayant un attribut « telephone ». (Réponse incorrecte!) Non, ce serait plutôt « client[@telephone] ». Les éléments « client » dans l'élément courant dont l'attribut « telephone » a la même valeur que l'attribut « telephone » de l'élément courant. (Réponse correcte!) Effectivement. On pourrait aussi écrire cette expression « client[current()/@telephone=./@telephone] ». Il s'agit d'un exemple où « current() » n'a pas la même valeur que « . ». Les valeurs des attributs « telephone » de tous les éléments « client » dans l'élément courant. (Réponse incorrecte!) Ce serait plutôt « client/@telephone ». Question 7 . Quelle est la valeur de l'expression XPath « client/*|client/@* »? Choisissez la bonne réponse parmi les suivantes. Tous les éléments contenus dans des éléments « client » dans le contexte actuel. (Réponse incorrecte!) Ce serait alors tout simplement « client/* ». Tous les éléments et attributs contenus dans des éléments « client » dans le contexte actuel. (Réponse correcte!) Effectivement. S'il n'y a rien qui correspond, un ensemble vide est donné. L'ensemble des attributs contenus dans des éléments « client » enfant d'éléments contenus dans des éléments « client ». (Réponse incorrecte!) Ce serait alors « client/*/client/@* ». Question 8 . Quelle est la valeur de l'expression XPath « *[@telephone] »? Choisissez la bonne réponse parmi les suivantes. La valeur de l'attribut « telephone » de l'élément courant. (Réponse incorrecte!) Ce serait tout simplement « @telephone ». L'élément courant s'il contient un attribut « telephone ». (Réponse incorrecte!) Ce serait plutôt « .[@telephone] ». Tous les éléments dans le contexte courant ayant un attribut « telephone ». (Réponse correcte!) Effectivement, ou un ensemble vide si ça ne s'applique pas. Question 9 . Quelle est la valeur de l'expression XPath « (vendeur/client)[2] »? Choisissez la bonne réponse parmi les suivantes. Le deuxième élément « client » dans la liste des éléments « client » contenus dans des éléments « vendeur ». (Réponse correcte!) Effectivement. S'il n'y a pas un tel élément, un ensemble vide est donné. Le deuxième élément « vendeur » dans la liste des éléments « client » contenus dans des éléments « vendeur ». (Réponse incorrecte!) Non, un élément « client » est donné. Le deuxième élément « client » contenu dans un élément « vendeur ». (Réponse incorrecte!) Non, ce serait alors « vendeur/client[2] ». Question 10 . Quelle est la valeur de l'expression XPath « vendeur/client[2] »? Choisissez la bonne réponse parmi les suivantes. Le deuxième élément « client » dans la liste des éléments « client » contenus dans des éléments « vendeur ». (Réponse incorrecte!) Non, ce serait plutôt « (vendeur/client)[2] ». Le deuxième élément « vendeur » dans la liste des éléments « client » contenus dans des éléments « vendeur ». (Réponse incorrecte!) Non, un élément « client » est donné. Le deuxième élément « client » contenu dans un élément « vendeur ». (Réponse correcte!) Question 11 . Quelle est la valeur de l'expression XPath « vendeur[2]/client[1] »? Choisissez la bonne réponse parmi les suivantes. Le second élément « client » contenu dans le premier élément « vendeur » rencontré. (Réponse incorrecte!) Est équivalent à « vendeur/vendeur/client[1] ». (Réponse incorrecte!) Non. Ce type d'abréviation n'existe pas en XPath. Le premier élément « client » contenu dans le deuxième élément « vendeur ». (Réponse correcte!) Effectivement. Si cet élément n'existe pas, un ensemble vide est obtenu. Question 12 . Est-ce que « //p=//c » et « //c=//z » implique « //p=//z »? Choisissez la bonne réponse parmi les suivantes. Oui (Réponse incorrecte!) La première égalité est vraie s'il y a un élément p dont le contenu est égal au contenu d'un élément c, et la seconde est vraie s'il y a un élément de c qui est égal à un élément z, ce qui n'implique pas qu'il existe un élément p qui soit égal à un élément z Non. (Réponse correcte!) Effectivement. Question 13 . Que vaut « //p=//p »? Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Seulement s'il existe au moins un élément p dans le document. Faux (Réponse incorrecte!) Seulement s'il n'existe pas d'élément p dans le document. Aucune de ces réponses. (Réponse correcte!) Effectivement. L'expression //p donne une liste d'éléments. La comparaison entre deux listes est vraie s'il existe au moins un élément dans la première liste égal à un élément dans la seconde liste. Cela est vrai si et seulement s'il y a au moins un élément p. Question 14 . Est-ce que « //p!='jean' » et « not(//p='jean') » ont la même signification? Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Non. La première expression est vraie s'il y a un élément p dont le contenu est différent de 'jean', alors que la seconde est vraie seulement si tous les éléments sont est différents de 'jean'. Faux (Réponse correcte!) Effectivement. Question 15 . Est-ce qu'il y a une différence entre ces deux expressions XPath: \"vendeur/prenom = 'Jean' and vendeur/nom = 'Coutu'\" et \"vendeur[prenom = 'Jean' and nom = 'Coutu']\"? Choisissez la bonne réponse parmi les suivantes. Non aucune. (Réponse incorrecte!) Non. Oui, mais pas toujours. (Réponse incorrecte!) Non. Ils sont toujours différents, mais si on les utilise dans une expression conditionnelle (xsl:if), ils peuvent être équivalents. Oui, ils sont toujours différents. (Réponse correcte!) Concernant la première requête: vendeur/prenom = Jean est une valeur booléenne (est-ce que Jean est présent dans vendeur/prenom?) tout comme vendeur/nom = Coutu. On combine les deux valeurs booléennes avec le et logique (and). Donc, la première est vraie si on trouve un élément vendeur contenant un élément prenom contenant le texte Jean et un élément nom contenant le nom Coutu, sinon elle est fausse. La seconde expression sélectionne les éléments correspondants à ce critère s'ils existent. "},{"id":61,"href":"/orientee_donnees/docs/modules/d_module_html/laboratoire_css/","title":"Laboratoire CSS","section":"Module HTML, CSS, SVG, MathML","content":" Laboratoire CSS Il peut être fastidieux d’apprendre le CSS en manipulant des fichiers. Heureusement, on peut le faire au sein d’un navigateur. Dans ce laboratoire, nous vous demandons d’expérimenter avec les notions de CSS vue jusqu’à présent. Partez du document XML et tentez de le mettre en forme de différentes manières. Mise en Forme XML avec CSS Entrez un contenu XML et un style CSS dans les champs ci-dessous, puis cliquez sur \"Mise en forme\" pour afficher le résultat stylisé dans l'iframe. Exemples : Exemple XML : Jean Rochond 10.10 Achat d'ordinateur Madeleine Bédard 20.10 Achat d'un crayon Exemple CSS : facture { display: block; margin-bottom: 30pt; } montant { color: red; } raison { display: block; font-style: italic; margin-left: 1cm; } Document XML : \u0026lt;?xml version=\"1.0\" ?\u0026gt; \u0026lt;comptearecevoir\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d'ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Madeleine Bédard\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;20.10\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d'un crayon\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; \u0026lt;/comptearecevoir\u0026gt; Document CSS : facture { display: block; margin-bottom: 30pt; } montant { color: red; } raison { display: block; font-style: italic; margin-left: 1cm; } Résultat : "},{"id":62,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/les_fichiers_csproj_en_c/","title":"Les fichiers csproj en C#","section":"Exemples","content":" Les fichiers csproj en C# # Les fichiers csproj sont des fichiers de projet utilisés dans l\u0026rsquo;écosystème .NET pour les applications écrites en C#. Ils sont formatés en XML, ce qui permet une structure hiérarchique claire et lisible par les outils de développement comme Visual Studio ou dotnet CLI. Ces fichiers contiennent des informations essentielles sur le projet, telles que :\nles dépendances NuGet les configurations de build les versions cibles du framework les fichiers inclus dans le projet Grâce à leur format XML, ils peuvent être édités manuellement ou générés automatiquement, offrant une flexibilité pour les développeurs qui souhaitent personnaliser leur environnement de travail.\nStructure XML # La structure XML d\u0026rsquo;un fichier csproj commence généralement par l\u0026rsquo;élément racine \u0026lt;Project\u0026gt;, qui peut inclure un attribut Sdk pour spécifier le type de projet (par exemple, \u0026ldquo;Microsoft.NET.Sdk\u0026rdquo;).\nÀ l\u0026rsquo;intérieur, on trouve des groupes importants :\n\u0026lt;PropertyGroup\u0026gt; : Définit des propriétés globales telles que : TargetFramework (pour indiquer la version .NET ciblée) OutputType (pour spécifier si c\u0026rsquo;est une bibliothèque ou une exécutable) \u0026lt;ItemGroup\u0026gt; : Regroupe les inclusions de fichiers et les références : Inclusions de fichiers (comme \u0026lt;Compile Include=\u0026quot;Program.cs\u0026quot;/\u0026gt;) Références à d\u0026rsquo;autres projets ou paquets Exemple de fichier csproj # Voici un exemple simple d\u0026rsquo;un fichier csproj pour un projet console en C# ciblant .NET 8.0. Ce fichier illustre la structure XML basique, avec un groupe de propriétés et un groupe d\u0026rsquo;éléments pour les dépendances.\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;OutputType\u0026gt;Exe\u0026lt;/OutputType\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Newtonsoft.Json\u0026#34; Version=\u0026#34;13.0.3\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; Cet exemple montre comment le XML organise les configurations : l\u0026rsquo;élément \u0026lt;Project\u0026gt; encapsule tout, \u0026lt;PropertyGroup\u0026gt; définit les paramètres du projet, et \u0026lt;ItemGroup\u0026gt; ajoute des références à des paquets NuGet. Vous pouvez l\u0026rsquo;éditer pour ajouter plus de fichiers ou de conditions.\n"},{"id":63,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/rss/","title":"Les formats RSS et Atom","section":"Exemples","content":" Les formats RSS et Atom # RSS (Really Simple Syndication) et Atom sont deux formats de syndication de contenu web qui permettent de diffuser automatiquement des mises à jour (articles, billets de blog, balados, vidéos, etc.) sans avoir à visiter manuellement chaque site. Ils sont nés au début des années 2000, à une époque où les blogs explosaient et où les lecteurs voulaient centraliser leurs sources d’information.\nRSS : l’original # La première version de RSS est apparue en 1999 (Netscape), mais c’est la version RSS 2.0 (2002, publiée par Dave Winer sous licence Creative Commons) qui s’est imposée comme le standard le plus utilisé.\nUn flux RSS est un fichier XML structuré contenant :\nles métadonnées du site (titre, description, lien, langue) une liste d’« items » (articles) avec titre, lien, description, date de publication, et souvent un GUID unique. Atom : le successeur normalisé # Atom 1.0 a été standardisé en 2005 par l’IETF (RFC 4287). Il corrige les ambiguïtés de RSS et apporte :\nune séparation claire entre le flux (feed) et les entrées (entry) un support natif des résumés et du contenu complet une gestion plus rigoureuse des dates, des auteurs, des identifiants permanents un protocole de publication (AtomPub, RFC 5023) qui permet aussi de créer ou modifier du contenu à distance. Atom est un peu plus verbeux que RSS, mais plus propre et plus extensible.\nQuelques exemples # Prenez le temps de consulter les sources suivantes.\nLe Devoir – format RSS 2.0\nhttps://www.ledevoir.com/flux-rss\nIci Radio-Canada Infos – format Atom 1.0\nhttps://ici.radio-canada.ca/rss/4159\nLa Presse – format RSS 2.0\nhttps://www.lapresse.ca/rss.php\n(flux généraux et par section, par exemple : https://www.lapresse.ca/actualites/rss.xml)\nJournal de Montréal (groupe Quebecor) – format RSS 2.0\nhttps://www.journaldemontreal.com/rss\nExemple Java (Radio-Canada) # Prenez quelques secondes pour exécuter ce programme qui charge les dernières nouvelles de Radio-Canada en utilisant le XML. N\u0026rsquo;essayez pas de comprendre le code en détail, nous reviendrons plus tard sur ces notions.\nRadioCanadaCinqDernieres.java import java.io.InputStream; import java.net.URL; import javax.xml.stream.XMLInputFactory; import javax.xml.stream.XMLStreamConstants; import javax.xml.stream.XMLStreamReader; public class RadioCanadaCinqDernieres { public static void main(String[] args) { String rssUrl = \u0026#34;https://ici.radio-canada.ca/info/rss/info/a-la-une\u0026#34;; try { System.out.println(\u0026#34;Les 5 dernières nouvelles de Radio-Canada :\\n\u0026#34;); URL url = new URL(rssUrl); try (InputStream in = url.openStream()) { XMLInputFactory factory = XMLInputFactory.newInstance(); XMLStreamReader reader = factory.createXMLStreamReader(in, \u0026#34;UTF-8\u0026#34;); int compteur = 0; StringBuilder titreBuilder = null; boolean dansTitle = false; while (reader.hasNext() \u0026\u0026 compteur \u0026lt; 5) { int event = reader.next(); if (event == XMLStreamConstants.START_ELEMENT) { String localName = reader.getLocalName(); if (\u0026#34;title\u0026#34;.equals(localName)) { dansTitle = true; titreBuilder = new StringBuilder(); } } else if (event == XMLStreamConstants.CHARACTERS || event == XMLStreamConstants.CDATA) { if (dansTitle \u0026\u0026 titreBuilder != null) { titreBuilder.append(reader.getText()); } } else if (event == XMLStreamConstants.END_ELEMENT) { String localName = reader.getLocalName(); if (\u0026#34;title\u0026#34;.equals(localName)) { dansTitle = false; } else if (\u0026#34;item\u0026#34;.equals(localName) \u0026\u0026 titreBuilder != null) { String titre = titreBuilder.toString().trim(); if (!titre.isEmpty()) { compteur\u0026#43;\u0026#43;; System.out.println(compteur \u0026#43; \u0026#34;. \u0026#34; \u0026#43; titre); } titreBuilder = null; } } } reader.close(); } } catch (Exception e) { System.err.println(\u0026#34;Erreur lors du chargement du flux : \u0026#34; \u0026#43; e.toString()); e.printStackTrace(); } } } Exécuter Exemple Java (Blogue de Daniel Lemire) # Prenez quelques secondes pour exécuter ce programme qui charge les dernières nouvelles du blogue de Daniel Lemire en utilisant le XML. N\u0026rsquo;essayez pas de comprendre le code en détail, nous reviendrons plus tard sur ces notions.\nRssFeedReader.java import java.io.InputStream; import java.net.URL; import java.net.HttpURLConnection; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.NodeList; public class RssFeedReader { public static void main(String[] args) { try { // Connexion au flux RSS String rssUrl = \u0026#34;https://lemire.me/blog/feed/\u0026#34;; URL url = new URL(rssUrl); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); // Vérification de la réponse int responseCode = connection.getResponseCode(); if (responseCode != HttpURLConnection.HTTP_OK) { System.out.println(\u0026#34;Erreur : Code de réponse \u0026#34; \u0026#43; responseCode); return; } // Parsing du XML DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); InputStream inputStream = connection.getInputStream(); Document doc = builder.parse(inputStream); doc.getDocumentElement().normalize(); // Extraction des informations du channel NodeList channelList = doc.getElementsByTagName(\u0026#34;channel\u0026#34;); if (channelList.getLength() \u0026gt; 0) { Element channel = (Element) channelList.item(0); String channelTitle = getElementValue(channel, \u0026#34;title\u0026#34;); String channelDescription = getElementValue(channel, \u0026#34;description\u0026#34;); String channelLink = getElementValue(channel, \u0026#34;link\u0026#34;); System.out.println(\u0026#34;Flux RSS : \u0026#34; \u0026#43; channelTitle); System.out.println(\u0026#34;Description : \u0026#34; \u0026#43; channelDescription); System.out.println(\u0026#34;Lien : \u0026#34; \u0026#43; channelLink); System.out.println(\u0026#34;Articles :\u0026#34;); } // Extraction des items (articles) NodeList itemList = doc.getElementsByTagName(\u0026#34;item\u0026#34;); for (int i = 0; i \u0026lt; itemList.getLength(); i\u0026#43;\u0026#43;) { Element item = (Element) itemList.item(i); String title = getElementValue(item, \u0026#34;title\u0026#34;); String link = getElementValue(item, \u0026#34;link\u0026#34;); String pubDate = getElementValue(item, \u0026#34;pubDate\u0026#34;); System.out.println(\u0026#34;Article \u0026#34; \u0026#43; (i \u0026#43; 1) \u0026#43; \u0026#34;:\u0026#34;); System.out.println(\u0026#34; Titre : \u0026#34; \u0026#43; title); System.out.println(\u0026#34; Lien : \u0026#34; \u0026#43; link); System.out.println(\u0026#34; Date de publication : \u0026#34; \u0026#43; pubDate); System.out.println(); } inputStream.close(); connection.disconnect(); } catch (Exception e) { System.out.println(\u0026#34;Erreur lors de la récupération du flux RSS : \u0026#34; \u0026#43; e.getMessage()); e.printStackTrace(); } } // Méthode utilitaire pour extraire la valeur d\u0026#39;un élément private static String getElementValue(Element parent, String tagName) { NodeList nodeList = parent.getElementsByTagName(tagName); if (nodeList.getLength() \u0026gt; 0 \u0026\u0026 nodeList.item(0).getFirstChild() != null) { return nodeList.item(0).getFirstChild().getNodeValue(); } return \u0026#34;\u0026#34;; } } Exécuter Exemple d\u0026rsquo;application # Créez un fichier nommé LemireBlogReader.java, faites javac LemireBlogReader.java puis java LemireBlogReader. Vous devriez voir une application apparaître sur votre ordinateur. Vous pourrez consulter les billets du blogue de Daniel Lemire (en anglais). N\u0026rsquo;essayez pas de comprendre le code en détail.\nimport java.io.InputStream; import java.net.URI; import java.net.URL; import java.net.HttpURLConnection; import java.util.ArrayList; import java.util.List; import javax.swing.JFrame; import javax.swing.JList; import javax.swing.JScrollPane; import javax.swing.JEditorPane; import javax.swing.JSplitPane; import javax.swing.ListSelectionModel; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import javax.swing.event.HyperlinkEvent; import javax.swing.event.HyperlinkListener; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.NodeList; import java.awt.Desktop; import java.awt.image.BufferedImage; import java.awt.Graphics; import java.awt.Color; public class LemireBlogReader extends JFrame { private static class Post { String title; String link; String pubDate; String content; Post(String title, String link, String pubDate, String content) { this.title = title; this.link = link; this.pubDate = pubDate; this.content = content; } @Override public String toString() { return \u0026#34;\u0026lt;html\u0026gt;\u0026lt;b\u0026gt;\u0026#34; + title + \u0026#34;\u0026lt;/b\u0026gt;\u0026lt;br\u0026gt;\u0026lt;font color=\\\u0026#34;gray\\\u0026#34;\u0026gt;\u0026#34; + pubDate + \u0026#34;\u0026lt;/font\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; } } private JList\u0026lt;Post\u0026gt; postList; private JEditorPane contentPane; private List\u0026lt;Post\u0026gt; posts; public LemireBlogReader() { setTitle(\u0026#34;Daniel Lemire\u0026#39;s Blog Reader\u0026#34;); setSize(1000, 700); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); posts = new ArrayList\u0026lt;\u0026gt;(); fetchPosts(); postList = new JList\u0026lt;\u0026gt;(posts.toArray(new Post[0])); postList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); contentPane = new JEditorPane(); contentPane.setContentType(\u0026#34;text/html\u0026#34;); contentPane.setEditable(false); contentPane.addHyperlinkListener(new HyperlinkListener() { @Override public void hyperlinkUpdate(HyperlinkEvent e) { if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) { try { Desktop.getDesktop().browse(e.getURL().toURI()); } catch (Exception ex) { ex.printStackTrace(); } } } }); postList.addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent e) { if (!e.getValueIsAdjusting()) { Post selected = postList.getSelectedValue(); if (selected != null) { contentPane.setText(selected.content); } } } }); JScrollPane listScroll = new JScrollPane(postList); JScrollPane contentScroll = new JScrollPane(contentPane); JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, listScroll, contentScroll); splitPane.setDividerLocation(300); add(splitPane); } private void fetchPosts() { try { String rssUrl = \u0026#34;https://lemire.me/blog/feed/\u0026#34;; URL url = new URI(rssUrl).toURL(); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); int responseCode = connection.getResponseCode(); if (responseCode != HttpURLConnection.HTTP_OK) { System.err.println(\u0026#34;Error: HTTP response code \u0026#34; + responseCode); return; } DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); InputStream inputStream = connection.getInputStream(); Document doc = builder.parse(inputStream); doc.getDocumentElement().normalize(); NodeList itemList = doc.getElementsByTagName(\u0026#34;item\u0026#34;); for (int i = 0; i \u0026lt; itemList.getLength(); i++) { Element item = (Element) itemList.item(i); String title = getElementValue(item, \u0026#34;title\u0026#34;); String link = getElementValue(item, \u0026#34;link\u0026#34;); String pubDate = getElementValue(item, \u0026#34;pubDate\u0026#34;); String content = getElementValue(item, \u0026#34;description\u0026#34;); posts.add(new Post(title, link, pubDate, content)); } inputStream.close(); connection.disconnect(); } catch (Exception e) { System.err.println(\u0026#34;Error fetching RSS: \u0026#34; + e.getMessage()); e.printStackTrace(); } } private static String getElementValue(Element parent, String tagName) { NodeList nodeList = parent.getElementsByTagName(tagName); if (nodeList.getLength() \u0026gt; 0 \u0026amp;\u0026amp; nodeList.item(0).getFirstChild() != null) { return nodeList.item(0).getFirstChild().getNodeValue().trim(); } return \u0026#34;\u0026#34;; } public static void main(String[] args) { javax.swing.SwingUtilities.invokeLater(() -\u0026gt; { new LemireBlogReader().setVisible(true); }); } } "},{"id":64,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/les_valeurs_dattribut/","title":"Les valeurs d’attribut","section":"XSLT","content":" Les valeurs d’attribut # Spécifier les valeurs d\u0026rsquo;attributs # Nous savons maintenant comment aller chercher la valeur d\u0026rsquo;un attribut en utilisant une expression XPath contenant le symbole « @ ». Cependant, qu\u0026rsquo;en est-il de la spécification des valeurs d\u0026rsquo;attributs? Supposons le document suivant :\n\u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;/facture\u0026gt; Nous voulons le simplifier pour n\u0026rsquo;avoir que :\n\u0026lt;facture montant=\u0026#34;10.10\u0026#34; /\u0026gt; Nous pouvons obtenir ce résultat en utilisant les accolades, pour indiquer une valeur XPath comme valeur d\u0026rsquo;attribut, de la façon suivante :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;facture montant=\u0026#34;{montant}\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; "},{"id":65,"href":"/orientee_donnees/docs/modules/e_module_services/","title":"Module Services et YAML","section":"Modules","content":" Module Services et YAML # Ce module traite des services web et des technologies associées : introduction aux services web, AJAX pour les requêtes asynchrones en JavaScript, mise en place de serveurs web, encodage Base64, et YAML comme format de données. Il explore les principes des API REST, les communications client-serveur, et les bonnes pratiques pour le développement d\u0026rsquo;applications web interactives.\nUn problème ou une suggestion ? # Vous pouvez à tout moment soumettre un commentaire anonyme concernant le cours via ce formulaire dédié. Cela nous permet de réagir rapidement en cas de problème. Vous pouvez également en discuter directement avec la personne qui vous encadre.\nNous accordons une grande importance à vos retours et travaillons continuellement à l\u0026rsquo;amélioration du cours.\n"},{"id":66,"href":"/orientee_donnees/legacy/semaine_12/solutions_aux_problemes_resolus/","title":"Solutions aux problèmes résolus","section":"Semaine 12","content":" Solutions aux problèmes résolus Solution du problème 1 Voici une solution possible (affichage récursif de l’arbre DOM avec indentation) : import org.w3c.dom.*; import javax.xml.parsers.*; public class Arbre { public static void traite(Node node, int niveau) { String indent = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; niveau; i++) { indent += \u0026#34; \u0026#34;; // 4 spaces per level } System.out.println(indent + \u0026#34;Nom : \u0026#34; + node.getNodeName() + \u0026#34; | Valeur : \u0026#34; + node.getNodeValue()); NodeList enfants = node.getChildNodes(); if (enfants != null) { for (int i = 0; i \u0026lt; enfants.getLength(); i++) { traite(enfants.item(i), niveau + 2); } } } public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(args[0]); traite(doc, 0); } } Solution du problème 2 import org.w3c.dom.*; import java.io.*; import javax.xml.parsers.*; import javax.xml.transform.*; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; public class Bottin { public static void main(String[] args) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(true); DocumentBuilder parser = factory.newDocumentBuilder(); Document doc = parser.parse(\u0026#34;bottin.xml\u0026#34;); Element racine = doc.getDocumentElement(); NodeList personnes = racine.getChildNodes(); if (args[0].equals(\u0026#34;efface\u0026#34;)) { for (int i = 0; i \u0026lt; personnes.getLength(); i++) { Node n = personnes.item(i); if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; if (e.getAttribute(\u0026#34;nom\u0026#34;).equals(args[1])) { e.getParentNode().removeChild(e); } } } } else if (args[0].equals(\u0026#34;cherche\u0026#34;)) { for (int i = 0; i \u0026lt; personnes.getLength(); i++) { Node n = personnes.item(i); if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; if (e.getAttribute(\u0026#34;nom\u0026#34;).equals(args[1])) { System.out.println(e.getAttribute(\u0026#34;téléphone\u0026#34;)); } } } } else if (args[0].equals(\u0026#34;ajoute\u0026#34;)) { boolean existe = false; for (int i = 0; i \u0026lt; personnes.getLength(); i++) { Node n = personnes.item(i); if (n.getNodeType() == Node.ELEMENT_NODE) { Element e = (Element) n; if (e.getAttribute(\u0026#34;nom\u0026#34;).equals(args[1])) { e.setAttribute(\u0026#34;téléphone\u0026#34;, args[2]); existe = true; } } } if (!existe) { Element p = doc.createElement(\u0026#34;personne\u0026#34;); p.setAttribute(\u0026#34;nom\u0026#34;, args[1]); p.setAttribute(\u0026#34;téléphone\u0026#34;, args[2]); racine.appendChild(p); } } // Sauvegarde du fichier modifié TransformerFactory tf = TransformerFactory.newInstance(); Transformer t = tf.newTransformer(); t.setOutputProperty(OutputKeys.ENCODING, \u0026#34;ISO-8859-1\u0026#34;); DOMSource source = new DOMSource(doc); StreamResult result = new StreamResult(new FileWriter(\u0026#34;bottin.xml\u0026#34;)); t.transform(source, result); } } Utilisation : java Bottin cherche Dupont → affiche le téléphone java Bottin ajoute Martin 555-1234 → ajoute ou met à jour java Bottin efface Martin → supprime la personne "},{"id":67,"href":"/orientee_donnees/docs/modules/d_module_html/svg/","title":"SVG","section":"Module HTML, CSS, SVG, MathML","content":" SVG Le Scalar Vector Graphics (SVG) est un format d'image vectorielle basé sur le langage XML, permettant de créer des graphiques évolutifs qui s'adaptent sans perte de qualité à toutes les tailles d'écran. Contrairement aux images matricielles (comme PNG ou JPEG), les SVG sont définis par des instructions textuelles décrivant des formes, des couleurs et des transformations, ce qui les rend légers, modifiables et idéaux pour le web. Grâce à leur intégration dans le HTML, les SVG peuvent être manipulés dynamiquement avec CSS ou JavaScript pour créer des animations ou des graphiques interactifs. On utilise de plus en plus la norme Scalar Vector Graphics (SVG) pour dessiner des figures en utilisant le XML. Vous pouvez déjà utiliser le format SVG avec plusieurs logiciels de bureautique ou tout simplement insérer un élément « svg » dans un document HTML comme nous allons le voir. La syntaxe SVG (Scalable Vector Graphics) repose sur un langage basé sur XML pour décrire des graphiques vectoriels bidimensionnels. Les principaux concepts incluent les éléments graphiques comme rect, circle, line, polygon ou path, qui définissent des formes géométriques. Ces éléments sont configurés via des attributs tels que x, y pour la position, width, height pour les dimensions, ou fill et stroke pour les couleurs et contours. Les transformations (via transform) permettent de déplacer, faire pivoter ou mettre à l’échelle les formes. SVG utilise un système de coordonnées où l’origine (0,0) est en haut à gauche, et les unités peuvent être absolues (px, cm) ou relatives (%). Enfin, les groupes (g) et les styles (via CSS ou l’attribut style) facilitent l’organisation et la personnalisation des éléments, rendant SVG flexible pour des graphiques interactifs et adaptatifs. Les attributs en SVG jouent un rôle clé pour définir les propriétés des éléments graphiques et contrôler leur apparence ou comportement. Parmi les attributs géométriques, on trouve x et y pour positionner un élément, width et height pour ses dimensions, ou cx et cy pour le centre d’un cercle. Les attributs de présentation comme fill déterminent la couleur de remplissage, stroke la couleur et stroke-width l’épaisseur du contour, tandis que opacity ajuste la transparence. Pour les formes complexes, path utilise l’attribut d pour décrire des trajectoires via des commandes comme M (move to), L (line to) ou C (courbe de Bézier). Les attributs de transformation, comme transform avec translate, rotate ou scale, modifient la position ou l’orientation. Enfin, des attributs comme id et class permettent d’identifier ou de styliser via CSS, et viewBox contrôle le cadre de visualisation pour un rendu adaptatif. Ces attributs offrent une grande précision pour personnaliser les graphiques SVG. Principales balises et éléments SVG Voici les éléments les plus couramment utilisés, avec leur rôle et un exemple simple. Élément Description Exemple d’utilisation Rendu approximatif \u0026lt;svg\u0026gt; Conteneur racine obligatoire. Définit la zone de dessin avec width , height et viewBox . \u0026lt;svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\"\u0026gt;\u0026lt;/svg\u0026gt; Zone carrée 200×200 \u0026lt;rect\u0026gt; Rectangle (coins éventuellement arrondis avec rx et ry ). \u0026lt;rect x=\"10\" y=\"10\" width=\"100\" height=\"60\" rx=\"10\"/\u0026gt; Rectangle arrondi \u0026lt;circle\u0026gt; Cercle défini par centre ( cx , cy ) et rayon r . \u0026lt;circle cx=\"100\" cy=\"100\" r=\"80\"/\u0026gt; Cercle centré \u0026lt;ellipse\u0026gt; Ellipse avec rayons horizontal rx et vertical ry . \u0026lt;ellipse cx=\"100\" cy=\"70\" rx=\"80\" ry=\"40\"/\u0026gt; Ovale \u0026lt;line\u0026gt; Segment de droite entre deux points. \u0026lt;line x1=\"0\" y1=\"0\" x2=\"200\" y2=\"100\"/\u0026gt; Diagonale \u0026lt;polyline\u0026gt; Série de segments connectés (liste de points). \u0026lt;polyline points=\"0,100 50,20 100,80 150,10 200,100\"/\u0026gt; Ligne brisée \u0026lt;polygon\u0026gt; Polygone fermé (le dernier point est relié au premier). \u0026lt;polygon points=\"100,10 160,90 40,90\"/\u0026gt; Triangle \u0026lt;path\u0026gt; Forme la plus puissante : courbes de Bézier, arcs, etc. via l’attribut d . \u0026lt;path d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\"/\u0026gt; Courbe cubique symétrique \u0026lt;text\u0026gt; Texte. Position avec x , y ; rotation avec transform ou rotate . \u0026lt;text x=\"100\" y=\"50\" text-anchor=\"middle\"\u0026gt;Bonjour\u0026lt;/text\u0026gt; Texte centré \u0026lt;tspan\u0026gt; Sous-élément de \u0026lt;text\u0026gt; pour changer de style ou position à l’intérieur d’un même texte. \u0026lt;text\u0026gt;\u0026lt;tspan font-weight=\"bold\"\u0026gt;Gras\u0026lt;/tspan\u0026gt; normal\u0026lt;/text\u0026gt; Partie en gras \u0026lt;g\u0026gt; Groupe d’éléments. Permet d’appliquer des attributs ou transformations communes. \u0026lt;g fill=\"red\"\u0026gt;\u0026lt;circle …/\u0026gt;\u0026lt;rect …/\u0026gt;\u0026lt;/g\u0026gt; Tous les enfants en rouge \u0026lt;defs\u0026gt; Définit des éléments réutilisables (gradients, patterns, symboles, clipPath…). \u0026lt;defs\u0026gt;\u0026lt;linearGradient id=\"grad\"\u0026gt;…\u0026lt;/linearGradient\u0026gt;\u0026lt;/defs\u0026gt; — \u0026lt;use\u0026gt; Réutilise un élément défini dans \u0026lt;defs\u0026gt; ou ailleurs. \u0026lt;use href=\"#monSymbole\" x=\"50\" y=\"50\"/\u0026gt; Instance du symbole \u0026lt;linearGradient\u0026gt; \u0026amp; \u0026lt;radialGradient\u0026gt; Dégradés linéaire ou radial. \u0026lt;linearGradient id=\"g1\"\u0026gt;\u0026lt;stop offset=\"0%\" stop-color=\"gold\"/\u0026gt;\u0026lt;stop offset=\"100%\" stop-color=\"red\"/\u0026gt;\u0026lt;/linearGradient\u0026gt; Dégradé or → rouge \u0026lt;pattern\u0026gt; Motif répétitif (carreaux, rayures, images…). \u0026lt;pattern id=\"dots\" …\u0026gt;\u0026lt;circle cx=\"5\" cy=\"5\" r=\"3\"/\u0026gt;\u0026lt;/pattern\u0026gt; Points répétés \u0026lt;marker\u0026gt; Flèches ou symboles aux extrémités de \u0026lt;path\u0026gt; , \u0026lt;line\u0026gt; , etc. \u0026lt;marker id=\"fleche\"\u0026gt;\u0026lt;path d=\"M0,0 L0,6 L9,3 z\"/\u0026gt;\u0026lt;/marker\u0026gt; Flèche à la fin du trait \u0026lt;clipPath\u0026gt; Masque de découpage. \u0026lt;clipPath id=\"cercleClip\"\u0026gt;\u0026lt;circle cx=\"100\" cy=\"100\" r=\"80\"/\u0026gt;\u0026lt;/clipPath\u0026gt; Ne montre que l’intérieur du cercle \u0026lt;filter\u0026gt; + primitives ( \u0026lt;feGaussianBlur\u0026gt; , \u0026lt;feOffset\u0026gt; , etc.) Effets graphiques (ombre portée, flou, glow…). \u0026lt;filter id=\"ombre\"\u0026gt;\u0026lt;feGaussianBlur stdDeviation=\"4\"/\u0026gt;\u0026lt;/filter\u0026gt; Ombre floue Ces éléments couvrent la très grande majorité des besoins en illustration vectorielle, diagrammes, icônes animées et graphiques interactifs dans les pages web modernes. SVG est entièrement stylisable avec CSS et animable avec SMIL ou JavaScript. L'élément foreignObject L'élément \u0026lt;foreignObject\u0026gt; permet d'intégrer du contenu HTML ou d'autres langages XML à l'intérieur d'un SVG. Cela est particulièrement utile pour combiner des éléments vectoriels avec du texte riche, des formulaires ou d'autres contenus HTML qui ne sont pas nativement supportés par SVG. L'élément \u0026lt;foreignObject\u0026gt; définit une région rectangulaire dans le SVG où le contenu étranger peut être rendu. Les attributs principaux de \u0026lt;foreignObject\u0026gt; sont : x et y : position du coin supérieur gauche de la région. width et height : dimensions de la région. À l'intérieur de \u0026lt;foreignObject\u0026gt;, vous pouvez utiliser des éléments HTML comme \u0026lt;div\u0026gt;, \u0026lt;p\u0026gt;, \u0026lt;input\u0026gt;, etc. Notez que le contenu HTML doit être bien formé et que les styles CSS peuvent être appliqués normalement. Exemple d'utilisation : \u0026lt;svg width=\"400\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"\u0026gt; \u0026lt;rect x=\"10\" y=\"10\" width=\"380\" height=\"180\" fill=\"lightblue\"/\u0026gt; \u0026lt;foreignObject x=\"20\" y=\"20\" width=\"360\" height=\"160\"\u0026gt; \u0026lt;body xmlns=\"http://www.w3.org/1999/xhtml\"\u0026gt; \u0026lt;p style=\"color: darkblue; font-family: Arial;\"\u0026gt;Ceci est du texte HTML dans un SVG !\u0026lt;/p\u0026gt; \u0026lt;input type=\"text\" placeholder=\"Entrez quelque chose\" /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/foreignObject\u0026gt; \u0026lt;/svg\u0026gt; Dans cet exemple, un rectangle SVG contient un paragraphe HTML et un champ de saisie. Le contenu HTML est rendu dans la région définie par \u0026lt;foreignObject\u0026gt;. \u0026lt;foreignObject\u0026gt; est particulièrement utile pour créer des graphiques hybrides, des infobulles riches ou des interfaces utilisateur complexes intégrant SVG et HTML. Laboratoire Je vous invite à éditer le code SVG au sein de la boîte suivante pour observer le résultat. Le SVG est notamment mis en forme à l'aide du CSS. Code SVG \u0026lt;svg width=\"300\" height=\"200\" viewBox=\"0 0 300 200\" xmlns=\"http://www.w3.org/2000/svg\"\u0026gt; \u0026lt;rect x=\"20\" y=\"20\" width=\"100\" height=\"60\" style=\"fill: #3498db; stroke: #2c3e50; stroke-width: 2;\" /\u0026gt; \u0026lt;circle cx=\"200\" cy=\"50\" r=\"30\" style=\"fill: #e74c3c; stroke: #2c3e50; stroke-width: 2;\" /\u0026gt; \u0026lt;line x1=\"20\" y1=\"120\" x2=\"280\" y2=\"180\" style=\"stroke: #27ae60; stroke-width: 4;\" /\u0026gt; \u0026lt;/svg\u0026gt; Rendu SVG Pour approfondir votre compréhension du SVG, essayez les activités suivantes dans la boîte de code ci-dessus : Changez la couleur du rectangle (par exemple, remplacez fill: #3498db par fill: #f1c40f ) ou ajustez le rayon du cercle (modifiez r=\"30\" à r=\"50\" ). Insérez un triangle en utilisant l'élément \u0026lt;polygon points=\"150,100 200,150 100,150\" style=\"fill: #8e44ad; stroke: #2c3e50; stroke-width: 2;\" /\u0026gt; à l'intérieur de la balise \u0026lt;svg\u0026gt; . Appliquez une rotation au rectangle en ajoutant transform=\"rotate(45 70 50)\" à l'élément \u0026lt;rect\u0026gt; pour le faire pivoter autour de son centre. Combinez plusieurs formes (cercles, rectangles, lignes) pour dessiner une maison simple ou un autre objet de votre choix. Testez des propriétés CSS comme fill-opacity: 0.5 ou stroke-dasharray: 5,5 pour créer des effets de transparence ou de pointillés. On peut utiliser la norme SVG pour générer des graphiques dynamiques au sein de pages web scriptées. "},{"id":68,"href":"/orientee_donnees/legacy/semaine_6/travail_2/","title":"Travail 2","section":"Semaine 6","content":" Travail 2 Vous avez créé votre premier EPUB intitulé « Mon premier livre » et vous l’avez consulté avec un lecteur de EPUB comme Readium. Vous êtes maintenant prêt pour le travail noté ! Vous allez maintenant faire le deuxième travail noté. Vous devez transmettre votre travail en utilisant l’outil de dépôt de l’Université. Comme le premier travail du cours, ce travail n’est ni long ni très compliqué et vise simplement à s’assurer que vous être familier avec le XHTML et les livres électroniques. Nous espérons que le travail puisse être un peu amusant. Nous aborderons des problèmes plus difficiles de programmation dans les semaines qui viennent. Voici le travail à faire : Choisissez un EPUB au sein du Projet Gutenberg. Vous ne devez pas choisir Eugénie Grandet... soyez original ! Préparez un court questionnaire comportant au moins 3 questions sur le livre en question. On ne vous évalue pas sur le choix de questions, mais pour être acceptable, les questions doivent être pertinentes au livre choisi. Rendez ce questionnaire interactif en utilisant JavaScript. Par exemple, utilisez à cette fin l’exemple où nous demandions l’année de naissance de Balzac. Si vous maîtrisez bien le JavaScript, vous pouvez aussi innover ! Notez que votre questionnaire doit obligatoirement être du XHTML valable ! Vous pouvez valider votre document XHTML en ligne. Ouvrez le EPUB dans Sigil. Ajoutez votre questionnaire au livre électronique et créez une nouvelle version du document. Ouvrez le fichier EPUB nouvellement créé dans un logiciel approprié. Avec un peu de chance, vous venez de créer un livre électronique interactif ! Transmettez votre fichier à la personne qui vous encadre pour correction. Certains lecteurs EPUB ne supportent pas JavaScript. Par contre, le JavaScript est supporté par iBooks (Apple), Readium, etc. Important : Si vous utilisez l’outil de dépôt, il est possible que celui-ci n’accepte pas les fichiers EPUB. Si vous devez mettre votre travail dans une archive compressée, optez pour le format universel ZIP . Notez que vous pouvez maintenant partager votre EPUB avec le monde entier (en respectant la license du Projet Gutenberg qui est plutôt permissive ). Vous pourriez même revendre un tel EPUB ! Cette activité notée compte pour 10 % de la note globale. "},{"id":69,"href":"/orientee_donnees/docs/modules/d_module_html/mathml/","title":"MathML","section":"Module HTML, CSS, SVG, MathML","content":" MathML Le Mathematical Markup Language (MathML) est un langage basé sur XML conçu pour représenter et afficher des expressions mathématiques de manière structurée sur le web. Contrairement aux images statiques ou aux approximations textuelles, MathML permet de décrire la sémantique et la présentation des formules mathématiques, offrant une accessibilité accrue et une intégration dynamique avec HTML. Il est particulièrement utilisé dans les contextes éducatifs, scientifiques et techniques pour rendre des équations complexes de façon précise et adaptable. MathML gagne en popularité pour afficher des formules mathématiques dans des documents web ou des logiciels spécialisés. Vous pouvez intégrer des éléments MathML directement dans un document HTML, comme nous allons le voir. La syntaxe MathML repose sur deux approches principales : la présentation (pour l’affichage visuel) et le contenu (pour la sémantique). Les éléments de présentation, comme mrow, mfrac, msup ou msqrt, organisent visuellement les expressions, tandis que les éléments de contenu, comme apply ou plus, décrivent leur structure logique. Les formules sont construites à partir d’éléments comme mi (identifiants), mn (nombres) et mo (opérateurs), placés dans une balise math. Les attributs comme display (block ou inline) contrôlent le rendu, et les styles CSS peuvent personnaliser l’apparence. MathML utilise un modèle arborescent où chaque élément imbriqué définit une partie de l’expression, garantissant une grande précision pour des formules complexes. Les attributs en MathML jouent un rôle essentiel pour ajuster l’apparence et le comportement des expressions. Par exemple, l’attribut mathvariant permet de définir le style des identifiants (par exemple, italic pour les variables). Les attributs comme numalign ou denomalign dans mfrac contrôlent l’alignement des fractions. Pour les exposants ou indices (msup, msub), l’attribut scriptlevel ajuste la taille du texte. Les éléments de présentation comme mtable permettent de créer des matrices avec des attributs comme rowspacing ou columnalign pour l’espacement et l’alignement. Enfin, l’attribut id facilite l’interaction avec CSS ou JavaScript, et xmlns garantit la compatibilité XML. Ces attributs offrent une flexibilité pour un rendu précis et accessible. Principales balises de présentation MathML Voici une description détaillée des balises les plus couramment utilisées en MathML de présentation (MathML-Presentation). Toutes ces balises doivent être placées à l’intérieur de l’élément racine \u0026lt;math\u0026gt; . Balise Description Exemple d’utilisation Rendu approximatif \u0026lt;math\u0026gt; Élément racine obligatoire de toute expression MathML. L’attribut display=\"block\" ou \"inline\" contrôle le mode d’affichage. \u0026lt;math display=\"block\"\u0026gt;…\u0026lt;/math\u0026gt; — \u0026lt;mi\u0026gt; Identifiant (variable, constante, fonction). Par défaut en italique. \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; ou \u0026lt;mi mathvariant=\"normal\"\u0026gt;sin\u0026lt;/mi\u0026gt; x, sin \u0026lt;mn\u0026gt; Nombre. \u0026lt;mn\u0026gt;123.45\u0026lt;/mn\u0026gt; 123.45 \u0026lt;mo\u0026gt; Opérateur, symbole ou séparateur (+, −, ×, =, (, etc.). L’espacement est géré automatiquement. \u0026lt;mo\u0026gt;+\u0026lt;/mo\u0026gt; ou \u0026lt;mo fence=\"true\"\u0026gt;(\u0026lt;/mo\u0026gt; + , ( \u0026lt;mtext\u0026gt; Texte brut (non mathématique), utile pour les unités ou commentaires. \u0026lt;mtext\u0026gt;kg\u0026lt;/mtext\u0026gt; kg \u0026lt;mrow\u0026gt; Groupe horizontal d’éléments. Sert à structurer l’arbre sans effet visuel particulier. \u0026lt;mrow\u0026gt;\u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt;\u0026lt;mo\u0026gt;+\u0026lt;/mo\u0026gt;\u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt;\u0026lt;/mrow\u0026gt; a + b \u0026lt;mfrac\u0026gt; Fraction. Attributs utiles : bevelled=\"true\" , numalign , denomalign . \u0026lt;mfrac\u0026gt;\u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt;\u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt;\u0026lt;/mfrac\u0026gt; a/b \u0026lt;msqrt\u0026gt; Racine carrée. \u0026lt;msqrt\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;/msqrt\u0026gt; √x \u0026lt;mroot\u0026gt; Racine n-ième (indice en premier enfant). \u0026lt;mroot\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mn\u0026gt;3\u0026lt;/mn\u0026gt;\u0026lt;/mroot\u0026gt; ³√x \u0026lt;msup\u0026gt; Exposant. \u0026lt;msup\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt;\u0026lt;/msup\u0026gt; x² \u0026lt;msub\u0026gt; Indice. \u0026lt;msub\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mn\u0026gt;1\u0026lt;/mn\u0026gt;\u0026lt;/msub\u0026gt; x₁ \u0026lt;msubsup\u0026gt; Indice et exposant simultanés. \u0026lt;msubsup\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mn\u0026gt;1\u0026lt;/mn\u0026gt;\u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt;\u0026lt;/msubsup\u0026gt; x₁² \u0026lt;munder\u0026gt; Élément placé sous le premier enfant (ex. limite). \u0026lt;munder\u0026gt;\u0026lt;mi\u0026gt;lim\u0026lt;/mi\u0026gt;\u0026lt;mrow\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mo\u0026gt;→\u0026lt;/mo\u0026gt;\u0026lt;mn\u0026gt;0\u0026lt;/mn\u0026gt;\u0026lt;/mrow\u0026gt;\u0026lt;/munder\u0026gt; lim sous x→0 \u0026lt;mover\u0026gt; Élément placé au-dessus (ex. barre, vecteur). \u0026lt;mover\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;mo\u0026gt;→\u0026lt;/mo\u0026gt;\u0026lt;/mover\u0026gt; x avec flèche au-dessus \u0026lt;munderover\u0026gt; Sous et au-dessus (ex. somme, intégrale). \u0026lt;munderover\u0026gt;\u0026lt;mo\u0026gt;∑\u0026lt;/mo\u0026gt;\u0026lt;mrow\u0026gt;\u0026lt;mi\u0026gt;i\u0026lt;/mi\u0026gt;\u0026lt;mo\u0026gt;=\u0026lt;/mo\u0026gt;\u0026lt;mn\u0026gt;1\u0026lt;/mn\u0026gt;\u0026lt;/mrow\u0026gt;\u0026lt;mi\u0026gt;n\u0026lt;/mi\u0026gt;\u0026lt;/munderover\u0026gt; ∑ avec i=1 en bas et n en haut \u0026lt;mtable\u0026gt;, \u0026lt;mtr\u0026gt;, \u0026lt;mtd\u0026gt; Tableau ou matrice. Fonctionne comme un tableau HTML. \u0026lt;mtable\u0026gt;\u0026lt;mtr\u0026gt;\u0026lt;mtd\u0026gt;\u0026lt;mn\u0026gt;1\u0026lt;/mn\u0026gt;\u0026lt;/mtd\u0026gt;\u0026lt;mtd\u0026gt;\u0026lt;/mtr\u0026gt;\u0026lt;/mtable\u0026gt; Matrice \u0026lt;mspace\u0026gt; Espace vide personnalisé (attributs width, height, depth). \u0026lt;mspace width=\"1em\"/\u0026gt; — \u0026lt;menclose\u0026gt; Encadre ou décore une expression (longdiv, circle, box, etc.). \u0026lt;menclose notation=\"box\"\u0026gt;\u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt;\u0026lt;/menclose\u0026gt; x encadré Cette liste couvre environ 90 % des besoins courants en MathML de présentation. Pour des cas plus avancés (opérateurs extensibles, annotations sémantiques, MathML-Content), il existe de nombreuses autres balises, mais celles-ci constituent la base indispensable pour commencer à écrire des formules complexes directement dans une page web. Laboratoire en ligne Je vous invite à éditer le code MathML dans la boîte suivante pour observer le résultat. Code MathML \u0026lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;=\u0026lt;/mo\u0026gt; \u0026lt;mfrac\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mo\u0026gt;-\u0026lt;/mo\u0026gt; \u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;±\u0026lt;/mo\u0026gt; \u0026lt;msqrt\u0026gt; \u0026lt;msup\u0026gt;\u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt;\u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt;\u0026lt;/msup\u0026gt; \u0026lt;mo\u0026gt;-\u0026lt;/mo\u0026gt; \u0026lt;mn\u0026gt;4\u0026lt;/mn\u0026gt; \u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt; \u0026lt;mi\u0026gt;c\u0026lt;/mi\u0026gt; \u0026lt;/msqrt\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;/mfrac\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;/math\u0026gt; Rendu MathML x = - b ± b 2 - 4 a c 2 a MathML et SVG # Vous pouvez insérer du MathML dans un document SVG.\nx y y = x 2 Code.\n\u0026lt;svg width=\u0026#34;400\u0026#34; height=\u0026#34;300\u0026#34; viewBox=\u0026#34;0 0 400 300\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; fill=\u0026#34;#f0f0f0\u0026#34;/\u0026gt; \u0026lt;line x1=\u0026#34;50\u0026#34; y1=\u0026#34;250\u0026#34; x2=\u0026#34;350\u0026#34; y2=\u0026#34;250\u0026#34; stroke=\u0026#34;black\u0026#34; stroke-width=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;line x1=\u0026#34;200\u0026#34; y1=\u0026#34;50\u0026#34; x2=\u0026#34;200\u0026#34; y2=\u0026#34;250\u0026#34; stroke=\u0026#34;black\u0026#34; stroke-width=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;polygon points=\u0026#34;350,250 340,245 340,255\u0026#34; fill=\u0026#34;black\u0026#34;/\u0026gt; \u0026lt;polygon points=\u0026#34;200,50 195,60 205,60\u0026#34; fill=\u0026#34;black\u0026#34;/\u0026gt; \u0026lt;text x=\u0026#34;340\u0026#34; y=\u0026#34;270\u0026#34; font-size=\u0026#34;14\u0026#34;\u0026gt;x\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;210\u0026#34; y=\u0026#34;65\u0026#34; font-size=\u0026#34;14\u0026#34;\u0026gt;y\u0026lt;/text\u0026gt; \u0026lt;foreignObject x=\u0026#34;220\u0026#34; y=\u0026#34;80\u0026#34; width=\u0026#34;160\u0026#34; height=\u0026#34;60\u0026#34;\u0026gt; \u0026lt;math xmlns=\u0026#34;http://www.w3.org/1998/Math/MathML\u0026#34; display=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;mi\u0026gt;y\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;=\u0026lt;/mo\u0026gt; \u0026lt;msup\u0026gt; \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;/msup\u0026gt; \u0026lt;/math\u0026gt; \u0026lt;/foreignObject\u0026gt; \u0026lt;path d=\u0026#34;M100,250 Q200,50 300,250\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;blue\u0026#34; stroke-width=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; "},{"id":70,"href":"/orientee_donnees/docs/modules/d_module_html/cssmathml/","title":"Laboratoire CSS/MathML","section":"Module HTML, CSS, SVG, MathML","content":" Laboratoire CSS/MathML # Vous pouvez utiliser CSS pour modifier l\u0026rsquo;apparence du contenu MathML dans votre navigateur. Je vous invite à éditer le code MathML dans la boîte suivante pour observer le résultat.\nCode MathML # \u0026lt;math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mi style=\"color: red; font-style: italic;\"\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mo style=\"color: purple;\"\u0026gt;=\u0026lt;/mo\u0026gt; \u0026lt;mfrac\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mn style=\"color: green;\"\u0026gt;−1\u0026lt;/mn\u0026gt; \u0026lt;mo style=\"color: purple;\"\u0026gt;±\u0026lt;/mo\u0026gt; \u0026lt;msqrt\u0026gt; \u0026lt;mn style=\"color: green;\"\u0026gt;1\u0026lt;/mn\u0026gt; \u0026lt;mo style=\"color: purple;\"\u0026gt;−\u0026lt;/mo\u0026gt; \u0026lt;mn style=\"color: green;\"\u0026gt;4\u0026lt;/mn\u0026gt; \u0026lt;/msqrt\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;mn style=\"color: green;\"\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;/mfrac\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;/math\u0026gt; Rendu MathML x = −1 ± 1 − 4 2 "},{"id":71,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/three/","title":"X3D","section":"Exemples","content":" X3D # X3D, ou Extensible 3D, est un standard international ISO/IEC ouvert pour la représentation et la communication de graphiques 3D interactifs sur le web. Ce format XML facilite la création de contenus 3D portables, visualisables dans des navigateurs, sans plugins supplémentaires. Maintenu par le Web3D Consortium, X3D évolue continuellement pour répondre aux besoins en visualisation scientifique, en éducation, et en réalité virtuelle/augmentée sur le web.\nPrenons un exemple classique d\u0026rsquo;une scène X3D simple affichant un cône rouge tournant sur lui-même.\n\u0026lt;X3D profile=\u0026#39;Immersive\u0026#39; version=\u0026#39;4.0\u0026#39; xmlns:xsd=\u0026#39;http://www.w3.org/2001/XMLSchema-instance\u0026#39; xsd:noNamespaceSchemaLocation=\u0026#39;http://www.web3d.org/specifications/x3d-4.0.xsd\u0026#39;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#39;title\u0026#39; content=\u0026#39;Simple Cone\u0026#39;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;Scene\u0026gt; \u0026lt;WorldInfo title=\u0026#39;Simple rotating cone\u0026#39;/\u0026gt; \u0026lt;Background skyColor=\u0026#39;0 0.5 1\u0026#39;/\u0026gt; \u0026lt;Viewpoint position=\u0026#39;0 0 5\u0026#39;/\u0026gt; \u0026lt;DirectionalLight/\u0026gt; \u0026lt;TimeSensor DEF=\u0026#39;Clock\u0026#39; cycleInterval=\u0026#39;4\u0026#39; loop=\u0026#39;true\u0026#39;/\u0026gt; \u0026lt;Transform DEF=\u0026#39;Spinner\u0026#39;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Cone bottomRadius=\u0026#39;1\u0026#39; height=\u0026#39;2\u0026#39;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#39;1 0 0\u0026#39;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;OrientationInterpolator DEF=\u0026#39;SpinPath\u0026#39; key=\u0026#39;0 0.5 1\u0026#39; keyValue=\u0026#39;0 1 0 0, 0 1 0 3.14159, 0 1 0 6.28318\u0026#39;/\u0026gt; \u0026lt;ROUTE fromNode=\u0026#39;Clock\u0026#39; fromField=\u0026#39;fraction_changed\u0026#39; toNode=\u0026#39;SpinPath\u0026#39; toField=\u0026#39;set_fraction\u0026#39;/\u0026gt; \u0026lt;ROUTE fromNode=\u0026#39;SpinPath\u0026#39; fromField=\u0026#39;value_changed\u0026#39; toNode=\u0026#39;Spinner\u0026#39; toField=\u0026#39;rotation\u0026#39;/\u0026gt; \u0026lt;/Scene\u0026gt; \u0026lt;/X3D\u0026gt; Ce code définit une scène basique dans le profil Immersive de X3D version 4.0. La balise \u0026lt;Background\u0026gt; crée un ciel bleu clair, \u0026lt;Viewpoint\u0026gt; positionne la caméra à 5 unités sur l\u0026rsquo;axe Z pour voir l\u0026rsquo;origine, et \u0026lt;DirectionalLight\u0026gt; ajoute un éclairage directionnel par défaut. Le cône est créé via \u0026lt;Cone\u0026gt; avec un rayon de base de 1 et une hauteur de 2, coloré en rouge (\u0026lt;Material diffuseColor=\u0026lsquo;1 0 0\u0026rsquo;\u0026gt;). Un \u0026lt;TimeSensor\u0026gt; nommé Clock génère un cycle de 4 secondes en boucle, envoyant une fraction (de 0 à 1) via une ROUTE à l\u0026rsquo;\u0026lt;OrientationInterpolator\u0026gt; SpinPath, qui interpole une rotation autour de l\u0026rsquo;axe Y de 0 à deux tours complets (en radians). Cette valeur est routée vers la rotation du \u0026lt;Transform\u0026gt; Spinner contenant le cône, produisant une animation de rotation continue. L\u0026rsquo;ensemble forme un exemple pédagogique démontrant géométrie primitive, apparence, éclairage et animation par interpolation temporelle.\n\u0026lt;X3D profile='Immersive' version='4.0' xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='http://www.web3d.org/specifications/x3d-4.0.xsd'\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name='title' content='Simple Cone'/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;Scene\u0026gt; \u0026lt;WorldInfo title='Simple rotating cone'/\u0026gt; \u0026lt;Background skyColor='0 0.5 1'/\u0026gt; \u0026lt;Viewpoint position='0 0 5'/\u0026gt; \u0026lt;DirectionalLight/\u0026gt; \u0026lt;TimeSensor DEF='Clock' cycleInterval='4' loop='true'/\u0026gt; \u0026lt;Transform DEF='Spinner'\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Cone bottomRadius='1' height='2'/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor='1 0 0'/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;OrientationInterpolator DEF='SpinPath' key='0 0.5 1' keyValue='0 1 0 0, 0 1 0 3.14159, 0 1 0 6.28318'/\u0026gt; \u0026lt;ROUTE fromNode='Clock' fromField='fraction_changed' toNode='SpinPath' toField='set_fraction'/\u0026gt; \u0026lt;ROUTE fromNode='SpinPath' fromField='value_changed' toNode='Spinner' toField='rotation'/\u0026gt; \u0026lt;/Scene\u0026gt; \u0026lt;/X3D\u0026gt; Mise à jour du rendu 3D Essayez les exemples suivants.\nSphère rouge avec un fond bleu ciel. # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE X3D PUBLIC \u0026#34;ISO//Web3D//DTD X3D 4.0//EN\u0026#34; \u0026#34;https://www.web3d.org/specifications/x3d-4.0.dtd\u0026#34;\u0026gt; \u0026lt;X3D profile=\u0026#34;Immersive\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;title\u0026#34; content=\u0026#34;Sphère rouge\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;Scene\u0026gt; \u0026lt;Background skyColor=\u0026#34;0.5 0.8 1\u0026#34;/\u0026gt; \u0026lt;Viewpoint position=\u0026#34;0 0 5\u0026#34; description=\u0026#34;Vue initiale\u0026#34;/\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Sphere radius=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;1 0 0\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Scene\u0026gt; \u0026lt;/X3D\u0026gt; Un cube bleu et une sphère rouge côte à côte # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE X3D PUBLIC \u0026#34;ISO//Web3D//DTD X3D 4.0//EN\u0026#34; \u0026#34;https://www.web3d.org/specifications/x3d-4.0.dtd\u0026#34;\u0026gt; \u0026lt;X3D profile=\u0026#34;Immersive\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;title\u0026#34; content=\u0026#34;Cube et sphère\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;Scene\u0026gt; \u0026lt;Background skyColor=\u0026#34;1 1 1\u0026#34;/\u0026gt; \u0026lt;Viewpoint position=\u0026#34;0 0 10\u0026#34;/\u0026gt; \u0026lt;Transform translation=\u0026#34;-2 0 0\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Box size=\u0026#34;2 2 2\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;0 0 1\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;Transform translation=\u0026#34;2 0 0\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Sphere radius=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;1 0 0\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;/Scene\u0026gt; \u0026lt;/X3D\u0026gt; un cylindre vert et texte en 3D # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE X3D PUBLIC \u0026#34;ISO//Web3D//DTD X3D 4.0//EN\u0026#34; \u0026#34;https://www.web3d.org/specifications/x3d-4.0.dtd\u0026#34;\u0026gt; \u0026lt;X3D profile=\u0026#34;Immersive\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;title\u0026#34; content=\u0026#34;Formes basiques avec texte\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;Scene\u0026gt; \u0026lt;Background skyColor=\u0026#34;0 0 0\u0026#34;/\u0026gt; \u0026lt;Viewpoint position=\u0026#34;0 5 15\u0026#34;/\u0026gt; \u0026lt;Transform translation=\u0026#34;-3 0 0\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Box size=\u0026#34;3 3 3\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;0 0 1\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;Transform translation=\u0026#34;0 0 0\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Cylinder radius=\u0026#34;1.5\u0026#34; height=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;0 1 0\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;Transform translation=\u0026#34;3 0 0\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Sphere radius=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material diffuseColor=\u0026#34;1 0 0\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;Transform translation=\u0026#34;0 -4 0\u0026#34; rotation=\u0026#34;1 0 0 -1.57\u0026#34;\u0026gt; \u0026lt;Shape\u0026gt; \u0026lt;Text string=\u0026#39;\u0026#34;Exemple X3D\u0026#34;\u0026#39;\u0026gt; \u0026lt;FontStyle size=\u0026#34;2\u0026#34; justify=\u0026#39;\u0026#34;MIDDLE\u0026#34;\u0026#39;/\u0026gt; \u0026lt;/Text\u0026gt; \u0026lt;Appearance\u0026gt; \u0026lt;Material emissiveColor=\u0026#34;1 1 0\u0026#34;/\u0026gt; \u0026lt;/Appearance\u0026gt; \u0026lt;/Shape\u0026gt; \u0026lt;/Transform\u0026gt; \u0026lt;/Scene\u0026gt; \u0026lt;/X3D\u0026gt; "},{"id":72,"href":"/orientee_donnees/docs/modules/d_module_html/autoevaluation_css/","title":"Autoévaluation CSS","section":"Module HTML, CSS, SVG, MathML","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Quelle affirmation décrit le mieux un document CSS? Choisissez la bonne réponse parmi les suivantes. Un document CSS doit être un document XML valable. (Réponse incorrecte!) Non. En fait, un document CSS n'est pas du XML. Un document CSS doit spécifier le document XML auquel il se rattache. (Réponse incorrecte!) Non. En général, un document CSS peut être utilisé par plusieurs documents XML. Un document CSS précise une façon de présenter certains éléments XML. (Réponse correcte!) Oui, c'est une façon de décrire ce qu'est un document CSS. Question 2 . Supposons que j'applique un fichier CSS vide au document XML suivant... \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Marc Popowich\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;1010.24\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d'ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; Qu'est-ce que le navigateur devrait afficher? Choisissez la bonne réponse parmi les suivantes. Rien. (Réponse incorrecte!) Non. Par défaut, un texte devrait s'afficher. Marc Popowich 1010.24 Achat d'ordinateur (Réponse correcte!) Exact. La présentation par défaut affiche le texte en ligne, normalement. Marc Popowich 1010.24 Achat d'ordinateur (Réponse incorrecte!) Non. Marc Popowich 1010.24 Achat d'ordinateur (Réponse incorrecte!) Non, il n'y a aucune raison pour que le texte soit en italique. Marc Popowich (Réponse incorrecte!) Non. Question 3 . Supposons que j'applique le fichier CSS suivant... * { font-style: italic; } montant { text-decoration: underline; } au document XML suivant... \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt;Marc Popowich\u0026lt;/personne\u0026gt; \u0026lt;montant\u0026gt;1010.24\u0026lt;/montant\u0026gt; \u0026lt;raison\u0026gt;Achat d'ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; Qu'est-ce que le navigateur devrait afficher? Choisissez la bonne réponse parmi les suivantes. Rien. (Réponse incorrecte!) Non. Marc Popowich 1010.24 Achat d'ordinateur (Réponse incorrecte!) Non. Marc Popowich 1010.24 Achat d'ordinateur (Réponse correcte!) Exact. Tous les éléments sont en italique et l'élément « montant » est souligné. Marc Popowich 1010.24 Achat d'ordinateur (Réponse incorrecte!) Non, l'élément montant est en italique, mais il n'est pas souligné. Marc Popowich (Réponse incorrecte!) Non. Question 4 . Étant donné le document XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt; \u0026lt;prenom\u0026gt;Marc\u0026lt;/prenom\u0026gt; \u0026lt;prenom\u0026gt;Antoine\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Popowich\u0026lt;/nom\u0026gt; \u0026lt;/personne\u0026gt; \u0026lt;/facture\u0026gt; Quels documents CSS mettront « Marc » et « Antoine » en rouge, et rien d'autre. Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». personne prenom { color: red; } Correct. Ce code met en rouge tous les éléments « prenom » contenus dans des éléments « personne ». prenom personne { color: red; } Non. Ce code ne met en rouge que les éléments « personne » qui suivent des éléments « prenom », ce qui ne se produit pas dans le document XML fourni. facture prenom { color: red; } Correct. Ce code met en rouge tous les éléments « prenom » contenus dans des éléments « facture », même si c'est au deuxième niveau, par l'élément « personne ». facture \u0026gt; prenom { color: red; } Non. Ce code ne met en rouge que les éléments « prenom » contenus au premier niveau, soit dans l'élément « facture », mais pas dans un autre élément. personne \u0026gt; prenom { color: red; } Oui. Ce code ne met en rouge que les éléments « prenom » contenus au premier niveau, soit dans l'élément « personne », mais pas dans un autre élément. prenom + prenom { color: red; } Non. Dans ce cas, seul le second élément « prenom » rencontré sera en rouge. En effet, le symbole « + » fonctionne de la manière suivante : si on a « \u0026lt;A\u0026gt;a\u0026lt;/A\u0026gt;\u0026lt;B\u0026gt;b\u0026lt;/B\u0026gt; », alors la clause CSS « A+B {propriete: valeur} » ne s'applique qu'à l'élément « B ». Question 5 . Étant donné le document XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;personne\u0026gt; \u0026lt;prenom num=\"1\"\u0026gt;Marc\u0026lt;/prenom\u0026gt; \u0026lt;prenom num=\"2\" special=\"vrai\"\u0026gt;Antoine\u0026lt;/prenom\u0026gt; \u0026lt;nom lang=\"inconnu\"\u0026gt;Popowich\u0026lt;/nom\u0026gt; \u0026lt;/personne\u0026gt; \u0026lt;/facture\u0026gt; Quels documents CSS permettent d'afficher uniquement « Marc Popowich »? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». prenom { display: none; } Non. Si on utilise ce fichier CSS, seulement le nom « Popowich » s'affichera. prenom[special] { display: none; } Oui. Seuls les éléments « prenom » avec un attribut ayant pour nom « special » seront cachés. prenom[num] { display: none; } Non. Si on utilise ce fichier CSS, on n'affichera que le nom Popowich *[special] { display: none; } Oui. Seuls les éléments avec un attribut ayant pour nom « special » seront cachés. *[num=\"2\"] { display: none; } Oui. Seuls les éléments avec l'attribut « num=\"2\" » seront cachés. Question 6 . Quelle instruction CSS sélectionnera les éléments « facture » et « montant »? Choisissez la bonne réponse parmi les suivantes. facture | montant {} (Réponse incorrecte!) Le symbole « | » n'est pas permis. facture \u0026gt; montant {} (Réponse incorrecte!) Cette instruction ne sélectionne que les éléments « montant » qui sont immédiatement contenus dans un élément « facture ». facture + montant {} (Réponse incorrecte!) Cette instruction ne sélectionne que les éléments « montant » qui suivent immédiatement un élément « facture ». facture, montant {} (Réponse correcte!) Effectivement. Cela est équivalent à deux instructions : l'une avec « facture » et l'autre avec « montant ». Question 7 . Quelle instruction CSS ne sélectionnera que les éléments nommés « racine »? Choisissez la bonne réponse parmi les suivantes. racine {} (Réponse correcte!) C'est juste. Seuls les éléments « racine » sont sélectionnés. * racine { } (Réponse incorrecte!) Cette syntaxe sélectionne tous les éléments « racine », sauf s'ils sont un élément-racine. #racine {} (Réponse incorrecte!) Dans le contexte du XHTML, cette instruction sélectionne tous les éléments qui ont un attribut « id=\"racine\" ». racine () (Réponse incorrecte!) Cette instruction n'est pas valable en CSS. Question 8 . Quelle instruction CSS ne sélectionnera que les éléments « input » avec l'attribut « type=\"text\" »? Choisissez la bonne réponse parmi les suivantes. input[type=\"text\"] {} (Réponse correcte!) Oui. input[.text] {} (Réponse incorrecte!) Cette instruction n'est pas valable : elle sélectionnerait les éléments « input » ayant un attribut nommé « .text », mais ce nom n'est pas permis pour les attributs. input.text {} (Réponse incorrecte!) Dans le contexte du XHTML, cette instruction sélectionnera les éléments « input » ayant un attribut « class=\"text\" ». input[type:\"text\"] {} (Réponse incorrecte!) Cette syntaxe n'est pas valable en CSS. Question 9 . Quelle instruction CSS ne sélectionnera que les éléments « a », « b » et « c »? Choisissez la bonne réponse parmi les suivantes. a | b | c {} (Réponse incorrecte!) Le symbole « | » n'est pas permis. a, b, c {} (Réponse correcte!) Oui. En effet, on peut combiner plus de deux éléments avec des virgules. a b c {} (Réponse incorrecte!) Bien qu'il s'agisse de CSS valable, cette instruction ne sélectionnerait que les éléments « c », à certaines conditions (« c » contenu dans « b », lui-même contenu dans « a »). a + b + c {} (Réponse incorrecte!) Bien qu'il s'agisse de CSS valable, cette instruction ne sélectionnerait que les éléments « c », à certaines conditions (« c » qui suit « b » qui suit « a »). Question 10 . Quelle instruction CSS sélectionnera les éléments « p » qui sont contenus dans un élément « li »? Choisissez la bonne réponse parmi les suivantes. li \u0026lt; p {} (Réponse incorrecte!) Le symbole « \u0026lt; » n'est pas permis. li p {} (Réponse correcte!) Oui. li.p {} (Réponse incorrecte!) Dans le contexte du XHTML, cette instruction sélectionnerait les éléments « li » ayant l'attribut « class=\"p\" ». Question 11 . Quelle instruction CSS sélectionnera les éléments « p » directement contenus dans un élément « li » (« p » est un enfant immédiat de « li »)? Choisissez la bonne réponse parmi les suivantes. li p {} (Réponse incorrecte!) Non. Elle ne requiert pas que « p » soit immédiatement dans « li ». li \u0026gt; p {} (Réponse correcte!) Oui. li \u0026lt; p {} (Réponse incorrecte!) Le symbole « \u0026lt; » n'est pas permis. li.p {} (Réponse incorrecte!) Dans le contexte du XHTML, cette instruction sélectionnerait les éléments « li » ayant l'attribut « class=\"p\" ». "},{"id":73,"href":"/orientee_donnees/docs/modules/e_module_services/base64/","title":"Base64","section":"Module Services et YAML","content":" Le Base64 : comment intégrer des images et des fichiers binaires directement dans du texte # Le Base64 est un système d’encodage qui permet de transformer n’importe quelles données binaires (images, sons, polices, PDF, etc.) en une chaîne de caractères composée uniquement des lettres A-Z, a-z, des chiffres 0-9 et des symboles + et /. Cet encodage a été créé à l’origine pour transmettre des pièces jointes dans les emails, car à l’époque les corps de message ne supportaient que du texte ASCII. Aujourd’hui, il reste très utile dès qu’on veut inclure des données binaires dans un format qui n’accepte que du texte pur. Le principe est simple : on prend les données binaires par groupes de 3 octets (24 bits), on les divise en 4 groupes de 6 bits, puis chaque groupe de 6 bits est converti en un caractère parmi les 64 possibles de la table Base64. Si les derniers octets ne remplissent pas un groupe complet, on ajoute des caractères = en fin de chaîne pour indiquer le remplissage. Le résultat est environ 33 % plus volumineux que les données d’origine, mais totalement transportable dans du texte. Dans un fichier XML, il est fréquent d’avoir besoin d’insérer une image ou un fichier binaire sans créer de référence externe. Grâce au Base64, on peut placer directement les données dans un nœud ou un attribut. Par exemple, un fichier SVG ou un document XML personnalisé peut contenir une balise \u0026lt;image\u0026gt; dont le contenu est la chaîne Base64 de l’image PNG ou JPEG. Cela rend le fichier XML totalement autonome : plus besoin de joindre l’image séparément. En HTML, l’application la plus connue du Base64 est l’intégration directe d’images via les data URI . Au lieu d’écrire \u0026lt;img src=\"photo.jpg\"\u0026gt;, on peut écrire \u0026lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...\"\u0026gt;. Le navigateur décode immédiatement la chaîne et affiche l’image sans requête supplémentaire au serveur. C’est particulièrement pratique pour les petites icônes, les logos, ou pour créer des pages HTML uniques (par exemple des signatures email ou des fichiers exportés). Voici un exemple concret : l’image ci-dessous est une petite icône de 64×64 pixels entièrement intégrée en Base64 dans ce fichier HTML, sans aucun fichier externe : "},{"id":74,"href":"/orientee_donnees/legacy/semaine_12/dom_javascript_et_autres_langages/","title":"DOM : JavaScript et autres langages","section":"Semaine 12","content":" DOM : JavaScript et autres langages # DOM et JavaScript # JavaScript est un langage similaire au Java quant à sa syntaxe de base et qui s\u0026rsquo;exécute souvent dans un navigateur. Les implémentations JavaScript supportent bien l\u0026rsquo;API DOM en général. La principale différence entre DOM en JavaScript et DOM en Java est que certaines méthodes en Java deviennent des attributs ou des propriétés en JavaScript (getNodeValue() devient nodeValue).\nJavaScript peut donc lire et traiter des documents XML avec l\u0026rsquo;API DOM. En particulier, si JavaScript est utilisé au sein d\u0026rsquo;une page XHTML, le script peut modifier la page dynamiquement en utilisant l\u0026rsquo;API DOM. La principale différence entre l\u0026rsquo;utilisation de DOM en Java et JavaScript est qu\u0026rsquo;à l\u0026rsquo;exception des méthodes getAttribute, setAttribute, getAttributeNS, setAttributeNS, getAttributeNode, setAttributeNode, getAttributeNodeNS, setAttributeNodeNS, getElementsByTagName et getElementById, toutes les méthodes dont le nom commence par « get » ou « set » sont remplacées par un attribut de l\u0026rsquo;objet (ou « property » en anglais). Au lieu d\u0026rsquo;écrire « e.getChildNodes(); », on écrit « e.childNodes; », au lieu d\u0026rsquo;écrire « e.setNodeValue(\u0026ldquo;texte\u0026rdquo;); », on écrit « e.nodeValue=\u0026ldquo;texte\u0026rdquo;; », et ainsi de suite.\nPar exemple, le script suivant va ajouter du texte lorsque la souris passera sur l\u0026rsquo;élément ayant un attribut « id=\u0026lsquo;javatest\u0026rsquo; ».\nmonele=document.getElementById(\u0026#39;javatest\u0026#39;); monele.childNodes.item(0).nodeValue+=\u0026#39; (passage de souris) \u0026#39;; Ce petit script illustre plusieurs points importants. D\u0026rsquo;abord, document.getElementById('javatest') recherche dans le document l\u0026rsquo;élément qui porte l\u0026rsquo;attribut id=\u0026quot;javatest\u0026quot; et retourne une référence à cet élément (ou null si aucun élément n\u0026rsquo;est trouvé). C\u0026rsquo;est l\u0026rsquo;un des moyens les plus rapides et les plus courants pour cibler un élément unique dans la page.\nEnsuite, monele.childNodes.item(0).nodeValue accède au premier nœud enfant de l\u0026rsquo;élément — souvent un nœud Text contenant le texte interne — et en modifie la valeur. Cette approche fonctionne si le premier nœud enfant est bien un nœud de texte ; dans le cas contraire (par exemple si l\u0026rsquo;élément contient d\u0026rsquo;autres éléments enfants), il faudra tester le type du nœud ou préférer textContent pour manipuler tout le texte intérieur.\nConcernant les événements, l\u0026rsquo;exemple suppose implicitement qu\u0026rsquo;une gestion d\u0026rsquo;événement a été définie ailleurs. En pratique on préfère attacher explicitement un écouteur d\u0026rsquo;événement moderne :\nconst el = document.getElementById(\u0026#39;javatest\u0026#39;); el.addEventListener(\u0026#39;mouseover\u0026#39;, () =\u0026gt; { el.textContent += \u0026#39; (passage de souris)\u0026#39;; }); Cette version utilise addEventListener (plus flexible) et textContent (moins fragile que la manipulation directe de nodeValue). Enfin, pour des interactions fréquentes (mousemove) pensez à limiter la fréquence des mises à jour (throttling/debouncing) et évitez innerHTML pour insérer du texte fourni par l\u0026rsquo;utilisateur afin de prévenir des failles XSS.\nDOM et autres langages # L\u0026rsquo;API DOM est supportée en C++ (voir Xerces-C), en Python (paquetage xml.dom), en Perl (voir Xerces-P), en JavaScript, etc. C\u0026rsquo;est d\u0026rsquo;ailleurs la principale force de cette API : peu importe le contexte, il y a fort à parier que vous aurez accès à l\u0026rsquo;API DOM. Ce n\u0026rsquo;est sans doute pas la meilleure API possible, mais son ubiquité fait en sorte qu\u0026rsquo;il vaut la peine d\u0026rsquo;apprendre à la connaître.\n"},{"id":75,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/le_fichier_androidmanifestxml/","title":"Le fichier AndroidManifest.xml","section":"Exemples","content":" Le fichier AndroidManifest.xml # Le fichier AndroidManifest.xml est le cœur de toute application Android. Il s\u0026rsquo;agit d\u0026rsquo;un fichier XML obligatoire situé à la racine du projet qui décrit les composants essentiels de l\u0026rsquo;application au système Android. Il déclare notamment le package de l\u0026rsquo;application, les activités (Activity), services, récepteurs de diffusion (Broadcast Receiver) et fournisseurs de contenu (Content Provider). Sans ce fichier correctement configuré, l\u0026rsquo;application ne peut pas être installée ni exécutée sur un appareil ou un émulateur. Ce manifeste sert également à déclarer les permissions nécessaires (par exemple l\u0026rsquo;accès à Internet, à la caméra, au stockage), les fonctionnalités matérielles requises (comme la présence d\u0026rsquo;un capteur GPS ou d\u0026rsquo;une caméra), la version minimale et cible de l\u0026rsquo;API Android, ainsi que des métadonnées comme l\u0026rsquo;icône de l\u0026rsquo;application, le label affiché dans le launcher, le thème, ou encore si l\u0026rsquo;application supporte le mode portrait/seulement paysage. Depuis Android 12 et plus, certaines déclarations comme les activités exportées doivent être explicites pour des raisons de sécurité. Voici un exemple simple d\u0026rsquo;un AndroidManifest.xml pour une application basique contenant une seule activité :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.example.monapplication\u0026#34;\u0026gt; \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:theme=\u0026#34;@style/Theme.MonApplication\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; Dans cet exemple, l\u0026rsquo;activité MainActivity est déclarée comme point d\u0026rsquo;entrée principal grâce au filtre d\u0026rsquo;intention MAIN et LAUNCHER, et android:exported=\u0026ldquo;true\u0026rdquo; est obligatoire lorsqu\u0026rsquo;il y a un intent-filter (règle de sécurité à partir d\u0026rsquo;Android 12).\n"},{"id":76,"href":"/orientee_donnees/docs/modules/c_module_xslt/xpath/xpath_20_et_30/","title":"XPath 2.0 et 3.0","section":"XPath","content":" XPath 2.0 et 3.0 # Jusqu'à présent, nous avons présenté XPath 1.0. Il s'agit de la version la plus largement supportée. Elle est la seule version supportée dans tous les grands navigateurs. XPath 2.0 ajoute de nombreuses fonctions et opérateurs qui simplifient la vie du programmeur tels que empty, exists, intersect, except (pour calculer le complément), deep-equal (pour tester l'égalité entre deux séquences), index-of, reverse, subsequence, insert-before, remove, distinct-values, avg, max, min, etc. Alors que XPath 1.0 ne traite que des nombres, des chaînes de caractères, des valeurs booléennes et des ensembles de nœuds, XPath 2.0 introduit la notion de séquence et plusieurs autres types de données pour noter les notes, la durée, les entiers, les nombres à virgule flottante, etc. XPath 2.0 supporte aussi les expressions régulières avec les fonctions matches, replace, et tokenize. XPath 2.0 intègre maintenant la fonction « document » qui était une fonction XSLT. XPath 2.0 comprend maintenant un syntaxe if/then/else comme dans cet exemple : « if ( @sexe eq 'm' ) then 'Monsieur' else 'Madame' ». On peut aussi utiliser des boucles : « for $i in //etudiant return $i/note ». On peut vérifier si au moins un (some) ou tous (every) les éléments d'une séquence satisfont une condition: « every $i in //etudiant satisfies $i/note \u0026gt; 0 » ou « some $i in //etudiant satisfies $i/note \u0026lt; 100 ». En somme, XPath 2.0 permet d'effectuer plusieurs traitement qui n'étaient possible qu'avec des instructions XSLT auparavant. XPath 3.0 quant à lui renforce la notion de fonction en XPath. On peut définir et exécuter ses propres fonctions. Par exemple, on peut définir (en XPath 3.0) une fonction qui ajoute 10 à un nombre: « let $ajoute := function($n) {$n+10} ». XPath 2.0 et 3.0 en Java # Nous pouvons utiliser la librairie Saxon en Java pour illustrer les fonctions propres à XPath 2.0 et 3.0.\nIllustrationXPathSaxon.java import net.sf.saxon.s9api.*; import javax.xml.transform.stream.StreamSource; import java.io.StringReader; import java.util.Iterator; public class IllustrationXPathSaxon { public static void main(String[] args) throws SaxonApiException { // Création du Processor (configuration Saxon) Processor processor = new Processor(false); // false pour édition HE // Chargement du document XML depuis une chaîne String xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;classe\u0026gt; \u0026lt;etudiant sexe=\u0026#34;m\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Jean\u0026lt;/nom\u0026gt; \u0026lt;note\u0026gt;85\u0026lt;/note\u0026gt; \u0026lt;note\u0026gt;92\u0026lt;/note\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant sexe=\u0026#34;f\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Marie\u0026lt;/nom\u0026gt; \u0026lt;note\u0026gt;78\u0026lt;/note\u0026gt; \u0026lt;note\u0026gt;95\u0026lt;/note\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant sexe=\u0026#34;m\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Paul\u0026lt;/nom\u0026gt; \u0026lt;note\u0026gt;88\u0026lt;/note\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;/classe\u0026gt; \u0026#34;\u0026#34;\u0026#34;; XdmNode document = processor.newDocumentBuilder().build( new StreamSource(new StringReader(xml)) ); // Création du compilateur XPath XPathCompiler xpathCompiler = processor.newXPathCompiler(); // Démonstration des fonctionnalités XPath 2.0 System.out.println(\u0026#34;Fonctions agrégates (avg, max, min) :\u0026#34;); XPathExecutable execAvg = xpathCompiler.compile(\u0026#34;avg(//note)\u0026#34;); XPathSelector selectorAvg = execAvg.load(); selectorAvg.setContextItem(document); XdmValue resultAvg = selectorAvg.evaluate(); System.out.println(\u0026#34;Moyenne de toutes les notes : \u0026#34; \u0026#43; resultAvg); XPathExecutable execMax = xpathCompiler.compile(\u0026#34;max(//note)\u0026#34;); XPathSelector selectorMax = execMax.load(); selectorMax.setContextItem(document); System.out.println(\u0026#34;Note maximale : \u0026#34; \u0026#43; selectorMax.evaluate()); XPathExecutable execMin = xpathCompiler.compile(\u0026#34;min(//note)\u0026#34;); XPathSelector selectorMin = execMin.load(); selectorMin.setContextItem(document); System.out.println(\u0026#34;Note minimale : \u0026#34; \u0026#43; selectorMin.evaluate()); System.out.println(\u0026#34;\\nExpression conditionnelle if/then/else :\u0026#34;); XPathExecutable execIf = xpathCompiler.compile(\u0026#34;//etudiant ! ((if (@sexe eq \u0026#39;m\u0026#39;) then \u0026#39;Monsieur\u0026#39; else \u0026#39;Madame\u0026#39;) || \u0026#39; \u0026#39; || nom)\u0026#34;); XPathSelector selectorIf = execIf.load(); selectorIf.setContextItem(document); XdmValue resultIf = selectorIf.evaluate(); Iterator\u0026lt;XdmItem\u0026gt; itIf = resultIf.iterator(); while (itIf.hasNext()) { System.out.println(\u0026#34;Salutation : \u0026#34; \u0026#43; itIf.next()); } System.out.println(\u0026#34;\\nBoucle for (retourner les notes) :\u0026#34;); XPathExecutable execFor = xpathCompiler.compile(\u0026#34;for $i in //etudiant return $i/note\u0026#34;); XPathSelector selectorFor = execFor.load(); selectorFor.setContextItem(document); XdmValue resultFor = selectorFor.evaluate(); System.out.println(\u0026#34;Toutes les notes (séquences aplaties) : \u0026#34; \u0026#43; resultFor); System.out.println(\u0026#34;\\nQuantificateurs some et every :\u0026#34;); XPathExecutable execSome = xpathCompiler.compile(\u0026#34;some $i in //etudiant satisfies $i/note \u0026lt; 80\u0026#34;); XPathSelector selectorSome = execSome.load(); selectorSome.setContextItem(document); System.out.println(\u0026#34;Au moins un étudiant a une note \u0026lt; 80 : \u0026#34; \u0026#43; selectorSome.evaluate()); XPathExecutable execEvery = xpathCompiler.compile(\u0026#34;every $i in //etudiant satisfies $i/note \u0026gt; 0\u0026#34;); XPathSelector selectorEvery = execEvery.load(); selectorEvery.setContextItem(document); System.out.println(\u0026#34;Tous les étudiants ont une note \u0026gt; 0 : \u0026#34; \u0026#43; selectorEvery.evaluate()); System.out.println(\u0026#34;\\nExpressions régulières (matches) :\u0026#34;); XPathExecutable execMatches = xpathCompiler.compile(\u0026#34;//etudiant[matches(nom, \u0026#39;^M\u0026#39;)] ! nom\u0026#34;); XPathSelector selectorMatches = execMatches.load(); selectorMatches.setContextItem(document); XdmValue resultMatches = selectorMatches.evaluate(); System.out.println(\u0026#34;Noms commençant par M : \u0026#34; \u0026#43; resultMatches); // Démonstration XPath 3.0 : fonction inline System.out.println(\u0026#34;\\nFonction inline XPath 3.0 (ajoute 10 à une note) :\u0026#34;); XPathExecutable execFunc = xpathCompiler.compile(\u0026#34;\u0026#34;\u0026#34; let $ajoute10 := function($n as xs:integer) as xs:integer { $n \u0026#43; 10 } return //note ! $ajoute10(.) \u0026#34;\u0026#34;\u0026#34;); XPathSelector selectorFunc = execFunc.load(); selectorFunc.setContextItem(document); XdmValue resultFunc = selectorFunc.evaluate(); System.out.println(\u0026#34;Notes \u0026#43; 10 : \u0026#34; \u0026#43; resultFunc); } } Exécuter "},{"id":77,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/xslt_modulaire/","title":"XSLT modulaire","section":"XSLT","content":" XSLT modulaire # Modularité avec les éléments « xsl:apply-templates » # Cette section explique comment utiliser l\u0026rsquo;élément xsl:apply-templates pour rendre les feuilles de style XSLT plus modulaires et réutilisables, en évitant la répétition de code.\nNotre fichier « xslt.xml » se complexifie et devient plus difficile à comprendre. Tout est dans un seul modèle, le modèle facture. Pour simuler un problème probable, imaginons que notre XML est plus complexe et prend la forme :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;xslt.xml\u0026#34; type=\u0026#34;application/xml\u0026#34;?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;recipiendaire\u0026gt; \u0026lt;personne\u0026gt; \u0026lt;sexe\u0026gt;M\u0026lt;/sexe\u0026gt; \u0026lt;nom\u0026gt;Rochond\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;/personne\u0026gt; \u0026lt;/recipiendaire\u0026gt; \u0026lt;commercant\u0026gt; \u0026lt;personne\u0026gt; \u0026lt;sexe\u0026gt;F\u0026lt;/sexe\u0026gt; \u0026lt;nom\u0026gt;Ladouce\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Jeanne\u0026lt;/prenom\u0026gt; \u0026lt;/personne\u0026gt; \u0026lt;/commercant\u0026gt; \u0026lt;raison\u0026gt;Achat d\u0026#39;ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; Dans ce nouveau document XML, se trouvent deux éléments « personne ». Il serait bête, dans le document XSLT, de répéter le travail chaque fois qu\u0026rsquo;on veut afficher un élément « personne ». Regardons ce que cela pourrait donner en pratique :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Ceci est une facture pour \u0026lt;xsl:value-of select=\u0026#34;recipiendaire/personne/prenom\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;recipiendaire/personne/nom\u0026#34; /\u0026gt; de \u0026lt;xsl:value-of select=\u0026#34;montant\u0026#34; /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\u0026#34;raison\u0026#34; /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Votre commerçant: \u0026lt;xsl:value-of select=\u0026#34;commercant/personne/prenom\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;commercant/personne/nom\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Observez comment on répète le texte suivant à deux reprises :\n\u0026lt;xsl:value-of select=\u0026#34;recipiendaire/personne/prenom\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;recipiendaire/personne/nom\u0026#34; /\u0026gt; Voici une autre solution, plus élégante, qui donne le même résultat :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;!-- d\u0026#39;abord un modèle pour les éléments facture --\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\u0026#34;recipiendaire/personne\u0026#34; /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Ceci est une facture pour \u0026lt;xsl:apply-templates select=\u0026#34;recipiendaire\u0026#34; /\u0026gt; de \u0026lt;xsl:value-of select=\u0026#34;montant\u0026#34; /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\u0026#34;raison\u0026#34; /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Votre commerçant: \u0026lt;xsl:apply-templates select=\u0026#34;commercant\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;!-- le modèle pour les éléments facture utilise un modèle pour les éléments personne --\u0026gt; \u0026lt;xsl:template match=\u0026#34;personne\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;prenom\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Quelques éléments « xsl:value-of » ont été remplacés par des éléments « xsl:apply-templates ». Un élément « xsl:apply-templates » prend le contenu et, au lieu d\u0026rsquo;insérer le contenu textuel comme le fait « xsl:value-of » à l\u0026rsquo;endroit prévu, il insère plutôt le résultat obtenu par l\u0026rsquo;application de modèles (éléments « xsl:template »). Ainsi, dans l\u0026rsquo;exemple que nous venons de voir, chaque fois que le processeur XSLT rencontre l\u0026rsquo;instruction « \u0026lt;xsl:apply-templates select=\u0026ldquo;recipiendaire\u0026rdquo; /\u0026gt; », il prend l\u0026rsquo;élément « recipiendaire » et essaie d\u0026rsquo;appliquer ses modèles. Comme il n\u0026rsquo;a pas de modèle pour les éléments « recipiendaire », il explore le contenu de l\u0026rsquo;élément et y trouve immédiatement un élément « personne ». Puisqu\u0026rsquo;il dispose d\u0026rsquo;un modèle pour ce type d\u0026rsquo;élément, il va l\u0026rsquo;appliquer. Par ailleurs, comme les éléments « recipiendaire » et « commercant » ne contiennent qu\u0026rsquo;un élément « personne », c\u0026rsquo;est donc le modèle défini pour les éléments « personne » qui s\u0026rsquo;appliquera dans les deux cas.\nNormalement, les éléments « xsl:apply-templates » sont utilisés au sein des éléments « xsl:template ». On peut aussi les utiliser au sein d\u0026rsquo;autres éléments que nous discuterons prochainement, « xsl:param » et « xsl:variable ».\nNotre fichier « xslt.xml » est maintenant plus modulaire, parce qu\u0026rsquo;il contient deux modèles (éléments « xsl:template »).\nEn résumé, il est souvent préférable d\u0026rsquo;utiliser un élément « xsl:apply-templates » qu\u0026rsquo;un élément « xsl:value-of » quand la complexité du modèle augmente; ceci permet d\u0026rsquo;assurer la modularité et de garder la simplicité du document XSLT.\nPar défaut, l\u0026rsquo;instruction apply-templates traite les nœuds dans l\u0026rsquo;ordre où ils se présentent dans le document original. On peut forcer le XSLT à trier les éléments avant de le traiter avec l\u0026rsquo;instruction xsl:sort. Dans notre exemple, on peut remplacer l\u0026rsquo;élément \u0026lt;xsl:apply-templates select=\u0026ldquo;recipiendaire\u0026rdquo; /\u0026gt; par cet élément si on veut que les individus soient triés par leur nom de famille.\n\u0026lt;xsl:apply-templates select=\u0026#34;étudiant\u0026#34; \u0026gt; \u0026lt;xsl:sort select=\u0026#34;personne/nom\u0026#34; order=\u0026#34;ascending\u0026#34; data-type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/xsl:apply-templates\u0026gt; Si on souhaite un tri sur la valeur numérique d\u0026rsquo;une expression, on remplacera data-type=\u0026ldquo;text\u0026rdquo; par data-type=\u0026ldquo;number\u0026rdquo;.\nOn peut aussi importer un autre fichier XSLT avec l\u0026rsquo;instruction xsl:import. Celle-ci doit apparaître au tout début du fichier XSLT comme premier sous-élément de l\u0026rsquo;élément xsl:stylesheet comme dans cet exemple :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:import href=\u0026#34;mesregles.xsl\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;facture\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\u0026#34;personne\u0026#34; /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; En cas de conflit entre les règles de fichier XSLT principal et celles du fichier importé, les règles du fichier XSLT principal l\u0026rsquo;emporte.\n"},{"id":78,"href":"/orientee_donnees/docs/modules/b_module_xml/espaces/autoevaluation_adv/","title":"Autoévaluation","section":"Espaces de nom","content":" Autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Choisissez l'expression qui décrit le mieux un espace de noms XML. Choisissez la bonne réponse parmi les suivantes. Un espace de noms XML est décrit par une DTD. (Réponse incorrecte!) Une DTD peut être utilisée, mais ce n'est pas la seule possibilité. Un espace de noms XML est un ensemble de balises et d'attributs auquel peut correspondre un URI. (Réponse correcte!) En effet. Un espace de noms XML est décrit par un URI qui est une adresse web pointant vers un document. (Réponse incorrecte!) Un URI est une adresse symbolique qui ne pointe pas nécessairement vers un document. Question 2 . Les espaces de noms font partie de la spécification XML originale (version 1.0) au même titre que les DTD. Choisissez la bonne réponse parmi les suivantes. Faux. (Réponse correcte!) Bien que compatible avec la norme XML, les espaces de noms n'en font pas partie. Vrai. (Réponse incorrecte!) Bien que compatible avec la norme 1.0, les espaces de noms furent introduits plus tard, environ un an après. Question 3 . Les espaces de noms permettent d'utiliser deux DTD en même temps. Choisissez la bonne réponse parmi les suivantes. Faux. (Réponse correcte!) On peut utiliser une DTD ou ne pas en utiliser, mais on ne peut pas en utiliser deux. Vrai. (Réponse incorrecte!) Les espaces de noms ne changent rien à la validation des documents : il faut toujours avoir une seule DTD. Question 4 . Les espaces de noms permettent d'utiliser deux vocabulaires XML en même temps. Choisissez la bonne réponse parmi les suivantes. Faux. (Réponse incorrecte!) Les espaces de noms permettent effectivement d'utiliser plus d'un vocabulaire XML en même temps. Vrai. (Réponse correcte!) On peut en fait combiner autant de vocabulaires XML que l'on veut. Question 5 . Dans le document XML suivant, qu'est-ce qui décrit le mieux l'espace de noms de l'élément « B »? \u0026lt;A xmlns:foo=\"http://www.foo.org/\" xmlns=\"http://www.bar.org/\"\u0026gt; \u0026lt;B\u0026gt;abcd\u0026lt;/B\u0026gt; \u0026lt;/A\u0026gt; Choisissez la bonne réponse parmi les suivantes. B (Réponse incorrecte!) Non. Il s'agit du nom de l'élément. A (Réponse incorrecte!) Non. Il s'agit d'un nom d'élément. foo (Réponse incorrecte!) Non. « foo » est un préfixe d'espace de noms qui n'est pas utilisé dans le document par un élément. http://www.bar.org/ (Réponse correcte!) Effectivement. L'élément « B » appartient à l'espace de noms par défaut qui est associé à l'URI « http://www.bar.org/ ». Question 6 . Quelle est la différence entre ces deux documents XML? \u0026lt;foo:A xmlns:foo=\"http://www.foo.org/\"\u0026gt; \u0026lt;foo:B\u0026gt;abcd\u0026lt;/foo:B\u0026gt; \u0026lt;/foo:A\u0026gt; \u0026lt;A xmlns:foo=\"http://www.foo.org/\"\u0026gt; \u0026lt;foo:B\u0026gt;abcd\u0026lt;/foo:B\u0026gt; \u0026lt;/A\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il n'y a aucune différence puisque l'élément « A » est associé par défaut à l'URI « http://www.foo.org/ ». (Réponse incorrecte!) Non. Dans le premier cas, l'élément « A » est dans l'espace de noms « foo », alors que dans le second, « A » est dans l'espace de noms par défaut. (Réponse correcte!) Effectivement. Question 7 . Quel est l'espace de noms de l'élément « B » dans ce document? \u0026lt;bou:A xmlns:bou=\"http://www.mondomaine.org/\"\u0026gt; \u0026lt;bou:B xmlns:bou=\"http://www.monsite.org/\"\u0026gt; \u0026lt;bou:C\u0026gt;abcd\u0026lt;/bou:C\u0026gt; \u0026lt;/bou:B\u0026gt; \u0026lt;/bou:A\u0026gt; Choisissez la bonne réponse parmi les suivantes. http://www.mondomaine.org/ (Réponse incorrecte!) Non. L'espace de noms a été redéfini. http://www.monsite.org/ (Réponse correcte!) Effectivement. Question 8 . Quels sont les documents XML respectant les conventions des espaces de noms? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;bou:A xmlns:bou=\"http://www.foo.org/\"\u0026gt; \u0026lt;bou:B\u0026gt; \u0026lt;bou:C xmlns:bou=\"http://www.bar.org/\"\u0026gt; \u0026lt;bou:D\u0026gt;abcd\u0026lt;/bou:D\u0026gt; \u0026lt;/bou:C\u0026gt; \u0026lt;/bou:B\u0026gt; \u0026lt;/bou:A\u0026gt; Il n'y a rien qui nous empêche de redéfinir un espace de noms. \u0026lt;A xmlns=\"http://www.mondomaine.org/\"\u0026gt; \u0026lt;B xmlns=\"http://www.monsite.org/\"\u0026gt;abcd\u0026lt;/B\u0026gt; \u0026lt;C xmlns=\"http://www.mondomaine.org/\"\u0026gt;efgh\u0026lt;/C\u0026gt; \u0026lt;D xmlns=\"http://www.monsite.org/\"\u0026gt; \u0026lt;E xmlns=\"http://www.mondomaine.org/\"\u0026gt;1234\u0026lt;/E\u0026gt; \u0026lt;F xmlns=\"http://www.monsite.org/\"\u0026gt;5678\u0026lt;/F\u0026gt; \u0026lt;/D\u0026gt; \u0026lt;G xmlns=\"http://www.mondomaine.org/\"\u0026gt;ijkl\u0026lt;/G\u0026gt; \u0026lt;/A\u0026gt; Ce document est conforme. \u0026lt;pre:A\u0026gt; \u0026lt;pre:B /\u0026gt; \u0026lt;/pre:A\u0026gt; Ce document est bien formé, mais pas conforme aux conventions d'espace de noms. Le préfixe « pre: » n'a pas été déclaré. Question 9 . Dans quels espaces de noms sont les attributs du document suivant : \u0026lt;Personne xmlns='urn:exemple1' xmlns:c='urn:exemple2'\u0026gt; \u0026lt;nom\u0026gt;\u0026lt;/nom\u0026gt; \u0026lt;age base='10' c:unite='annee'\u0026gt;33\u0026lt;/age\u0026gt; \u0026lt;/Personne\u0026gt; Choisissez la bonne réponse parmi les suivantes. « base='10' » est dans l'espace de noms « urn:exemple1 », alors que « c:unite='annee' » est dans l'espace de noms « urn:exemple2 » (Réponse incorrecte!) Non, « base » n'est dans aucun espace de noms, car il n'a pas de préfixe. « base='10' » est dans l'espace de noms « \"\" » (vide), alors que « c:unite='annee' » est dans l'espace de noms « urn:exemple2 » (Réponse incorrecte!) Il n'y a pas de raison que « base » soit dans l'espace de noms «\"\"». « base='10' » n'est dans aucun espace de noms, alors que « c:unite='annee' » est dans l'espace de noms « urn:exemple2 » (Réponse correcte!) Effectivement, un attribut sans préfixe n'est pas dans un espace de noms. Question 10 . Un parseur XML charge les URI associés aux espaces de nom qu'il rencontre. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Non, l'URI n'est qu'un identifiant. Faux (Réponse correcte!) Effectivement, l'URI peut ne pas pointer vers un véritable site web. Vous avez maintenant terminé votre autoévaluation. "},{"id":79,"href":"/orientee_donnees/docs/modules/e_module_services/asynchronous_javascript_and_xml_ajax/","title":"Chargement XML/JSON en JavaScript","section":"Module Services et YAML","content":" Chargement XML/JSON en JavaScript # La programmation asynchrone permet d\u0026rsquo;exécuter des tâches en arrière-plan sans bloquer l\u0026rsquo;exécution du programme principal. Contrairement à la programmation synchrone où les opérations se déroulent séquentiellement (une après l\u0026rsquo;autre), l\u0026rsquo;asynchrone permet de lancer une opération longue, comme une requête réseau ou la lecture d\u0026rsquo;un fichier, et de continuer à exécuter d\u0026rsquo;autres tâches pendant que cette opération se déroule. Lorsque l\u0026rsquo;opération asynchrone se termine, un mécanisme de notification (callback, Promise, ou async/await) permet de traiter le résultat sans interrompre le flux principal du programme.\nEn JavaScript, il n\u0026rsquo;y a qu\u0026rsquo;un fil d\u0026rsquo;exécution. Si une fonction devait attendre la réponse d\u0026rsquo;un serveur d\u0026rsquo;une manière synchrone, aucune autre opération JavaScript ne serait possible. Au lieu de cela, nous préférons une exécution asynchrone.\nUne Promise est un objet en JavaScript qui représente la complétion (ou l\u0026rsquo;échec) éventuelle d\u0026rsquo;une opération asynchrone et sa valeur résultante. Elle agit comme un proxy pour une valeur qui n\u0026rsquo;est pas nécessairement connue au moment de sa création. Une Promise peut être dans l\u0026rsquo;un des trois états : en attente (pending), résolue (fulfilled) avec une valeur, ou rejetée (rejected) avec une raison d\u0026rsquo;erreur.\nconst maPromise = new Promise((resolve, reject) =\u0026gt; { // Opération asynchrone setTimeout(() =\u0026gt; { if (Math.random() \u0026gt; 0.5) { resolve(\u0026#34;Succès !\u0026#34;); } else { reject(\u0026#34;Erreur !\u0026#34;); } }, 1000); }); maPromise .then(resultat =\u0026gt; console.log(resultat)) .catch(erreur =\u0026gt; console.error(erreur)); Les Promises permettent de gérer les opérations asynchrones de manière plus élégante que les callbacks traditionnels. Elles peuvent être chaînées avec .then() pour traiter les résultats successifs, et .catch() pour gérer les erreurs. Les Promises sont la base d\u0026rsquo;APIs modernes comme fetch(), et elles sont essentielles pour comprendre async/await qui en est un sucre syntaxique.\nEn JavaScript, le mot-clé async devant une fonction indique qu\u0026rsquo;elle retourne une Promise. Le mot-clé await est utilisé à l\u0026rsquo;intérieur d\u0026rsquo;une fonction async pour attendre la résolution d\u0026rsquo;une Promise.\nasync function maFonction() { const resultat = await unePromise(); return resultat; } Un fonction async ne bloque pas l\u0026rsquo;exécution du JavaScript dans la page. Elle est asynchrone.\nCela permet d\u0026rsquo;écrire du code asynchrone de manière synchrone, facilitant la lecture et la gestion des erreurs. Sans async/await, il faudrait utiliser des callbacks ou chaîner des .then(), ce qui peut rapidement devenir complexe et difficile à déboguer. L\u0026rsquo;avantage principal est que le code ressemble à du code synchrone tout en restant non-bloquant, améliorant considérablement la lisibilité et la maintenabilité des applications JavaScript modernes.\nL\u0026rsquo;API fetch() est l\u0026rsquo;API moderne pour effectuer des requêtes HTTP en JavaScript.\nfetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(error)); fetch() retourne un objet Promise qui résout en un objet Response. Cet objet Response contient des méthodes pour accéder au corps de la réponse (text(), json(), blob(), etc.) et des propriétés comme status (code HTTP), ok (booléen indiquant si la requête a réussi), et headers (les en-têtes HTTP).\nUne expression comme const response = await fetch(uri); effectue une requête HTTP asynchrone vers l\u0026rsquo;URI spécifiée. fetch(uri) envoie une requête GET par défaut et retourne immédiatement une Promise. Le mot-clé await met en pause l\u0026rsquo;exécution de la fonction jusqu\u0026rsquo;à ce que cette Promise se résolve, c\u0026rsquo;est-à-dire jusqu\u0026rsquo;à ce que la réponse HTTP soit reçue du serveur.\nLa variable response contient alors un objet Response qui encapsule la réponse HTTP complète : le code de statut (200, 404, etc.), les en-têtes, et le corps de la réponse. Cet objet fournit des méthodes comme response.ok (booléen indiquant le succès), response.status (code numérique), et response.text() ou response.json() pour accéder au contenu.\nAsynchronous JavaScript And XML (AJAX) # Normalement, pour récupérer des données sur le serveur (description d’un produit, horaire, etc.), il faut recharger une nouvelle page. Avec AJAX (Asynchronous JavaScript And XML), un script JavaScript peut charger un fichier XML (ou JSON) en arrière-plan, sans recharger la page. L’utilisateur a l’impression que l’application est beaucoup plus rapide.\nExemples célèbres : Gmail, Google Maps, Facebook (à l’époque), etc.\nExemple simple : charger et afficher le titre d’un document XHTML # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Exemple AJAX\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; // Charge un document XML/XHTML et appelle afficheTitre() async function chargeDocument(uri) { try { const response = await fetch(uri); if (!response.ok) { throw new Error(`Erreur HTTP: ${response.status}`); } const text = await response.text(); // Sans await, text serait une Promise, pas le contenu texte de la réponse. // Cela causerait une erreur lors de l\u0026#39;utilisation de text dans DOMParser.parseFromString(), // car parseFromString attend une chaîne, pas une Promise. const parser = new DOMParser(); const doc = parser.parseFromString(text, \u0026#34;application/xml\u0026#34;); afficheTitre(doc); } catch (error) { console.error(\u0026#39;Erreur lors du chargement:\u0026#39;, error); } } // La fonction chargeDocument déclarée async car elle utilise le mot-clé await à l\u0026#39;intérieur. // Sans async, await ne pourrait pas être utilisé, et la fonction retournerait immédiatement // sans attendre la résolution des Promises. async transforme la fonction en une fonction // qui retourne une Promise, permettant ainsi l\u0026#39;utilisation d\u0026#39;await pour une exécution séquentielle apparente. // Affiche le contenu de l\u0026#39;élément \u0026lt;title\u0026gt; function afficheTitre(doc) { var titre = doc.getElementsByTagName(\u0026#34;title\u0026#34;)[0]; var texte = titre.firstChild ? titre.firstChild.nodeValue : \u0026#34;\u0026#34;; var p = document.createElement(\u0026#34;p\u0026#34;); p.appendChild(document.createTextNode(texte)); document.getElementsByTagName(\u0026#34;body\u0026#34;)[0].appendChild(p); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Cliquez plusieurs fois sur les liens ci-dessous :\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:chargeDocument(\u0026#39;domtutoriel.xhtml\u0026#39;)\u0026#34;\u0026gt;domtutoriel.xhtml\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:chargeDocument(\u0026#39;travail5.xhtml\u0026#39;)\u0026#34;\u0026gt;travail5.xhtml\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Dans cet exemple, la fonction chargeDocument utilise XMLHttpRequest pour effectuer une requête GET asynchrone vers une URI. Lorsque la réponse est reçue (readyState === 4 et status === 200), elle appelle afficheTitre qui extrait le contenu de l\u0026rsquo;élément \u0026lt;title\u0026gt; du document XML chargé et l\u0026rsquo;ajoute dynamiquement à la page.\nExemple avancé : afficher les titres d’un flux RSS (Le Devoir) # Sélectionnez un fichier XML RSS pour afficher ses titres.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Exemple AJAX – Flux RSS\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; function chargeDocumentFromFile(input) { var file = input.files[0]; if (file) { var reader = new FileReader(); reader.onload = function(e) { var doc = new DOMParser().parseFromString(e.target.result, \u0026#34;application/xml\u0026#34;); afficheTitres(doc); }; reader.readAsText(file); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;.xml\u0026#34; onchange=\u0026#34;chargeDocumentFromFile(this)\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cet exemple avancé montre comment parser un fichier XML RSS sélectionné localement. L\u0026rsquo;utilisateur choisit un fichier via un input de type file, qui est lu avec FileReader, puis parsé avec DOMParser. La fonction afficheTitres récupère tous les éléments \u0026lt;title\u0026gt; et les affiche dans une liste ordonnée. Cela illustre comment AJAX peut être utilisé pour traiter des fichiers locaux sans serveur.\nUtiliser importNode() pour insérer tout un fragment XML # function afficheListe(doc) { var ul = doc.getElementsByTagName(\u0026#34;ul\u0026#34;)[0]; var copie = document.importNode(ul, true); // true = copie profonde document.body.appendChild(copie); } La méthode importNode() permet d\u0026rsquo;importer un nœud d\u0026rsquo;un document XML externe vers le document HTML courant. Le paramètre true indique une copie profonde, incluant tous les nœuds enfants. Cela est utile pour éviter les conflits d\u0026rsquo;espaces de noms et pour intégrer des fragments XML complexes sans altérer le document source.\nChargement de fichiers locaux (Chrome, Edge, etc.) # La plupart du temps, les pages web ne peuvent pas charger du contenu provenant d\u0026rsquo;un autre serveur. Il est donc pratique de demander à l\u0026rsquo;utilisateur de charger un fichier qui se trouve sur son disque.\n\u0026lt;input type=\u0026#34;file\u0026#34; onchange=\u0026#34;chargeFichier(this.files[0])\u0026#34;\u0026gt; function chargeFichier(fichier) { var lecteur = new FileReader(); lecteur.onload = function(e) { var doc = new DOMParser().parseFromString(e.target.result, \u0026#34;application/xml\u0026#34;); afficheTitres(doc); }; lecteur.readAsText(fichier); } Ce code permet de charger un fichier XML local sélectionné par l\u0026rsquo;utilisateur via un input de type file. Il utilise FileReader pour lire le contenu du fichier en texte, puis DOMParser pour le parser en document XML. Cela évite les restrictions de sécurité des navigateurs qui empêchent le chargement direct de fichiers locaux via XMLHttpRequest.\nAJAX permet de créer des applications web plus interactives en chargeant des données en arrière-plan sans recharger la page entière. L\u0026rsquo;objet XMLHttpRequest est au cœur de cette technologie, permettant d\u0026rsquo;envoyer des requêtes HTTP asynchrones. Combiné avec l\u0026rsquo;API DOM pour manipuler le contenu de la page, AJAX offre une expérience utilisateur fluide.\nL\u0026rsquo;exemple simple montre comment charger un document XHTML et extraire son titre pour l\u0026rsquo;afficher dynamiquement. L\u0026rsquo;exemple avancé démontre le parsing d\u0026rsquo;un flux RSS pour afficher une liste de titres. La méthode importNode() permet d\u0026rsquo;importer des fragments XML d\u0026rsquo;un document à un autre, utile pour intégrer du contenu externe sans conflits d\u0026rsquo;espaces de noms.\nJSON # Nous pouvons aussi utiliser la même technique en remplaçant le XML par JSON.\nfetch(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) .then(response =\u0026gt; response.json()) .then(donnees =\u0026gt; { console.log(donnees); // Traiter les données ici afficheDonnees(donnees); }) .catch(error =\u0026gt; console.error(\u0026#39;Erreur:\u0026#39;, error)); L\u0026rsquo;API fetch() est plus moderne et basée sur les promesses que XMLHttpRequest. Elle permet de charger des données JSON de manière asynchrone et de les traiter facilement.\nFonction d\u0026rsquo;affichage des données # function afficheDonnees(donnees) { var div = document.createElement(\u0026#34;div\u0026#34;); div.innerHTML = \u0026#34;\u0026lt;h2\u0026gt;\u0026#34; + donnees.titre + \u0026#34;\u0026lt;/h2\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Auteur: \u0026#34; + donnees.auteur + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; + \u0026#34;\u0026lt;p\u0026gt;Description: \u0026#34; + donnees.description + \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; document.body.appendChild(div); } Exemple complet avec JSON # Voici un exemple complet d\u0026rsquo;une page HTML utilisant AJAX avec JSON pour charger et afficher des données :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Exemple AJAX avec JSON\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; margin: 20px; } .donnees { border: 1px solid #ccc; padding: 10px; margin: 10px 0; border-radius: 5px; } button { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; } button:hover { background-color: #0056b3; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Chargement de données JSON avec AJAX\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;chargerDonnees()\u0026#34;\u0026gt;Charger les données\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;contenu\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; async function chargerDonnees() { try { const response = await fetch(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;); if (!response.ok) { throw new Error(`Erreur HTTP: ${response.status}`); } const donnees = await response.json(); afficherDonnees(donnees); } catch (error) { console.error(\u0026#39;Erreur lors du chargement:\u0026#39;, error); document.getElementById(\u0026#39;contenu\u0026#39;).innerHTML = \u0026#39;\u0026lt;p style=\u0026#34;color: red;\u0026#34;\u0026gt;Erreur lors du chargement des données.\u0026lt;/p\u0026gt;\u0026#39;; } } function afficherDonnees(donnees) { const contenu = document.getElementById(\u0026#39;contenu\u0026#39;); contenu.innerHTML = \u0026#39;\u0026#39;; // Vider le contenu précédent const div = document.createElement(\u0026#39;div\u0026#39;); div.className = \u0026#39;donnees\u0026#39;; div.innerHTML = ` \u0026lt;h3\u0026gt;${donnees.title}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;ID:\u0026lt;/strong\u0026gt; ${donnees.id}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;User ID:\u0026lt;/strong\u0026gt; ${donnees.userId}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Contenu:\u0026lt;/strong\u0026gt; ${donnees.body}\u0026lt;/p\u0026gt; `; contenu.appendChild(div); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Cet exemple montre comment :\nUtiliser fetch() pour effectuer une requête GET à une API REST Gérer les erreurs avec try/catch Parser automatiquement le JSON avec response.json() Afficher dynamiquement les données dans le DOM L\u0026rsquo;exemple utilise l\u0026rsquo;API publique JSONPlaceholder pour démontrer une vraie requête HTTP GET. JSON offre une alternative moderne et légère à XML pour l\u0026rsquo;échange de données en AJAX.\nTrucs pour le développement JavaScript dans un navigateur # Tous les navigateurs modernes (Chrome, Firefox, Edge, Safari) disposent d\u0026rsquo;outils de développement intégrés. Ouvrez-les avec F12 ou Ctrl+Shift+I (Cmd+Option+I sur Mac).\nConsole : Pour les logs (console.log()), erreurs, et exécuter du code en direct Network : Pour inspecter les requêtes HTTP, voir les réponses AJAX, et déboguer les appels API Sources : Pour déboguer le code JavaScript avec des points d\u0026rsquo;arrêt Application : Pour inspecter le stockage local, les cookies, et les données de session Lorsque vous faites des requêtes AJAX vers des domaines différents, vous pouvez rencontrer des erreurs. Utilisez un serveur local (comme ExempleServeurFichiersSimple.java).\n"},{"id":80,"href":"/orientee_donnees/docs/modules/a_module_json/encodage_des_caracteres_unicode/","title":"Encodage des caractères Unicode","section":"Module JSON","content":" Encodage des caractères Unicode # Les fichier texte sont stockés un encodage Unicode (soit UTF-16, soit UTF-8).\nQu\u0026rsquo;est-ce qu\u0026rsquo;Unicode ? # Unicode est un standard international qui attribue un numéro unique, appelé point de code, à chaque caractère utilisé dans les écritures du monde entier. Contrairement aux anciens systèmes d\u0026rsquo;encodage comme ASCII qui ne supportaient que 128 caractères (principalement l\u0026rsquo;anglais), Unicode peut représenter plus de 140 000 caractères, incluant des lettres, des symboles, des émojis, des caractères de contrôle et des scripts anciens. Par exemple, le caractère \u0026ldquo;A\u0026rdquo; a le point de code U+0041, tandis que l\u0026rsquo;émoji \u0026ldquo;😀\u0026rdquo; a U+1F600. Unicode assure l\u0026rsquo;interopérabilité entre différentes langues et plateformes, permettant à un document de mélanger du texte en français, chinois, arabe et emoji sans problèmes de compatibilité.\nL\u0026rsquo;adoption d\u0026rsquo;Unicode a résolu les problèmes d\u0026rsquo;encodage multiples qui causaient des erreurs d\u0026rsquo;affichage, comme les caractères \u0026ldquo;�\u0026rdquo; (replacement character) lorsqu\u0026rsquo;un fichier était ouvert avec un mauvais encodage. Unicode définit également des règles pour la normalisation des caractères, comme la décomposition des caractères accentués (par exemple, \u0026ldquo;é\u0026rdquo; peut être représenté comme \u0026ldquo;e\u0026rdquo; + \u0026ldquo;´\u0026rdquo; ou comme un seul caractère U+00E9).\nUTF-8 : L\u0026rsquo;encodage variable le plus populaire # UTF-8 est l\u0026rsquo;encodage Unicode le plus largement utilisé sur le web et dans les systèmes modernes. Contrairement à UTF-16 qui utilise une taille fixe de 2 octets par caractère, UTF-8 utilise un nombre variable d\u0026rsquo;octets : 1 octet pour les caractères ASCII (U+0000 à U+007F), 2 octets pour la plupart des caractères latins accentués et cyrilliques, 3 octets pour la plupart des caractères asiatiques, et 4 octets pour les émojis et caractères rares. Cette conception permet à UTF-8 d\u0026rsquo;être rétrocompatible avec ASCII : tout fichier ASCII valide est aussi un fichier UTF-8 valide.\nPar exemple, le caractère \u0026ldquo;A\u0026rdquo; (U+0041) s\u0026rsquo;encode en un seul octet : 41 en hexadécimal. Le caractère \u0026ldquo;é\u0026rdquo; (U+00E9) s\u0026rsquo;encode en deux octets : C3 A9. Le caractère chinois \u0026ldquo;中\u0026rdquo; (U+4E2D) s\u0026rsquo;encode en trois octets : E4 B8 AD. Cette variabilité rend UTF-8 efficace pour les textes principalement en anglais (économie d\u0026rsquo;espace) tout en supportant pleinement Unicode.\nUn avantage majeur de UTF-8 est son absence d\u0026rsquo;endianness (ordre des octets) : les octets sont toujours dans le même ordre, éliminant les problèmes de big-endian vs little-endian. Cependant, certains systèmes ajoutent un BOM (Byte Order Mark, U+FEFF) au début des fichiers pour indiquer explicitement l\u0026rsquo;encodage UTF-8, bien que ce ne soit pas obligatoire.\nUTF-16 : L\u0026rsquo;encodage à largeur fixe # UTF-16 utilise 2 octets (16 bits) pour la plupart des caractères courants, mais peut utiliser des paires de substituts (4 octets au total) pour les caractères au-delà du Plan Multilingue de Base (BMP), comme les émojis. Par exemple, \u0026ldquo;A\u0026rdquo; s\u0026rsquo;encode en 00 41 (en little-endian) ou 41 00 (en big-endian). Le caractère \u0026ldquo;中\u0026rdquo; s\u0026rsquo;encode en 2D 4E. Pour un émoji comme \u0026ldquo;😀\u0026rdquo; (U+1F600), qui est au-delà du BMP, UTF-16 utilise deux unités de code : D8 3D DE 00 (little-endian).\nL\u0026rsquo;endianness est cruciale en UTF-16 : les systèmes Intel (little-endian) stockent les octets dans l\u0026rsquo;ordre inverse des systèmes Motorola (big-endian). Pour éviter les confusions, un BOM peut être ajouté : FE FF pour big-endian, FF FE pour little-endian. UTF-16 était populaire dans les systèmes Windows anciens, mais UTF-8 l\u0026rsquo;a largement surpassé pour sa compatibilité web.\nComparé à UTF-8, UTF-16 peut être plus efficace pour les textes asiatiques (moins d\u0026rsquo;octets par caractère), mais il consomme plus d\u0026rsquo;espace pour les textes occidentaux. De plus, les paires de substituts compliquent le traitement des chaînes.\nExemples d\u0026rsquo;encodage # Voici quelques exemples concrets d\u0026rsquo;encodage de caractères en UTF-8 et UTF-16 :\nCaractère \u0026ldquo;A\u0026rdquo; (U+0041) :\nUTF-8 : 41 UTF-16 LE : 41 00 UTF-16 BE : 00 41 Caractère \u0026ldquo;é\u0026rdquo; (U+00E9) :\nUTF-8 : C3 A9 UTF-16 LE : E9 00 UTF-16 BE : 00 E9 Caractère \u0026ldquo;中\u0026rdquo; (U+4E2D) :\nUTF-8 : E4 B8 AD UTF-16 LE : 2D 4E UTF-16 BE : 4E 2D Émoji \u0026ldquo;😀\u0026rdquo; (U+1F600) :\nUTF-8 : F0 9F 98 80 UTF-16 LE : 3D D8 00 DE UTF-16 BE : D8 3D DE 00 Pour le texte \u0026ldquo;Hello 😀\u0026rdquo;, l\u0026rsquo;encodage complet serait :\nUTF-8 : 48 65 6C 6C 6F 20 F0 9F 98 80 UTF-16 LE : 48 00 65 00 6C 00 6C 00 6F 00 20 00 3D D8 00 DE Ces exemples montrent comment UTF-8 économise de l\u0026rsquo;espace pour les caractères simples tandis que UTF-16 est plus prévisible en taille pour certains scripts.\nChoix de l\u0026rsquo;encodage # Le choix entre UTF-8 et UTF-16 dépend du contexte : UTF-8 est recommandé pour le web, les fichiers texte et la compatibilité maximale. UTF-16 peut être préféré dans des environnements où les caractères non-ASCII sont dominants. Dans tous les cas, spécifier l\u0026rsquo;encodage dans les déclarations (comme \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; en XML) évite les ambiguïtés.\nIl peut être intéressant de voir comment le texte est converti en données binaires sur votre disque. Saisissez du texte. Voyez les octets en UTF-8 et UTF-16. Pour distinguer les encodages, il arrive que les systèmes ajoutent quelques octets au début du contenu (appelé BOM pour Byte-Order-Mask). Le format UTF-16 comporte deux variantes : LE (little endian) et BE (big endian).\nTexte UTF-16 LE BE Inclure BOM Les valeurs sont affichées en hexadécimal (octets). UTF-8 0 octet — UTF-16 LE , sans BOM 0 octet — Conseils: les émojis et caractères hors BMP utilisent des paires de substituts en UTF‑16. Le comptage d’octets inclut le BOM si coché. Pour en savoir plus... UTF-8 (wikipédia); UTF-16 (wikipédia); "},{"id":81,"href":"/orientee_donnees/legacy/semaine_10/les_langages_declaratifs/","title":"Les langages déclaratifs","section":"Semaine 10","content":" Les langages déclaratifs Un langage comme Java est orienté objet et procédural. Ce n'est pas, par contre, un langage déclaratif et on dit donc qu'il est impératif. Les langages déclaratifs sont des langages qui définissent le problème au lieu d'en définir la solution . On les reconnaît souvent parce qu'ils énoncent des règles au lieu d'énoncer des procédures. Le langage Prolog est un exemple de langage déclaratif parce que le programmeur ne fait que saisir des relations sans définir comment l'ordinateur doit combiner ses relations: pere(X,Y) :- parent(X,Y),homme(X). freresoeur(X,Y) :- parent(Z,X), parent(Z,Y). Le SQL est aussi déclaratif parce qu'on spécifie à l'ordinateur quelles informations on veut sans pour autant spécifier comment l'information doit être trouvée: SELECT age FROM table WHERE age \u0026gt; 25; Le XSLT et XQuery sont des exemples plus récents de langages déclaratifs. On affirme souvent que les langages déclaratifs sont plus lents que les langages impératifs parce que le logiciel doit lui-même trouver la meilleure stratégie pour évaluer le programme sans recevoir beaucoup d'indices de la part de l'humain. Le contraire peut aussi être vrai: comme le logiciel peut optimiser à sa guise l'exécution du programme étant donné l'absence de structure imposée par l'humain, il est possible pour un langage déclaratif de surpasser en vitesse un langage impératif. En pratique, personne ne se plaint vraiment de la lenteur relative du XSLT, de SQL ou de Prolog. Cependant, pour le programmeur habitué à la programmation impérative, la programmation déclarative peut être source de confusion. Avec l'expérience, on se rend compte que, pour bien des problèmes, la programmation déclarative est préférable surtout lorsqu'on ne veut pas se soucier des détails techniques comme la façon dont le fichier XML est lu et comment il est stocké en mémoire. Le XSLT peut aussi être considéré comme un langage fonctionnel (voir FXSL ou The Functional Programming Language XSLT - A proof through examples par Dimitre Navatchev) au même titre que APL, Lisp, Haskell, Maple, Mathematica, Ocaml ou Scheme. On peut dire la même chose du XPath 3.0. "},{"id":82,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/les_noms_delements/","title":"Les noms d’éléments","section":"XSLT","content":" Les noms d’éléments # Capturer le nom d\u0026rsquo;un élément # Dans cette section, nous apprenons à capturer et afficher les noms des éléments XML en utilisant les fonctions XPath name, local-name et namespace-uri.\nSupposons que nous voulions afficher uniquement les noms des éléments (sans leur contenu). Nous pouvons obtenir ce résultat avec la fonction XPath « name » qui donne le nom de l\u0026rsquo;élément. La fonction name inclut le préfixe de l\u0026rsquo;espace de noms. Si on souhaite le nom de l\u0026rsquo;élément sans le préfixe, on peut utiliser la fonction « local-name ». La fonction « namespace-uri » donne l\u0026rsquo;URI de l\u0026rsquo;espace de noms de l\u0026rsquo;élément.\nAinsi, le document XSLT suivant permet d\u0026rsquo;afficher tous les noms des éléments XML, sans le contenu textuel de ces éléments.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;name(.)\u0026#34; /\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Nous pourrions aussi vouloir afficher non seulement le nom de l\u0026rsquo;élément courant, mais aussi le nom de l\u0026rsquo;élément-parent, ce qu\u0026rsquo;on peut faire avec le document XSLT suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;name(..)\u0026#34; /\u0026gt; / \u0026lt;xsl:value-of select=\u0026#34;name(.)\u0026#34; /\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; "},{"id":83,"href":"/orientee_donnees/docs/modules/e_module_services/introservicesweb/","title":"Introduction aux services web","section":"Module Services et YAML","content":" Introduction aux services web # Les services web sont des applications ou des ressources accessibles via Internet qui permettent à des programmes (clients) de communiquer avec des serveurs distants pour échanger des données ou exécuter des fonctionnalités. Ils reposent principalement sur le protocole HTTP (HyperText Transfer Protocol), un protocole de communication client-serveur sans état : chaque requête est traitée indépendamment, sans mémoire des échanges précédents. Un client envoie une requête comportant une méthode (comme GET ou POST), une adresse (URI), des en-têtes et éventuellement un corps, tandis que le serveur répond avec un code de statut, des en-têtes et un corps contenant les données demandées.\nDans le contexte moderne, la grande majorité des services web sont des API (interfaces de programmation applicatives) qui exposent des fonctionnalités sous forme de points d’accès (endpoints). Ces API permettent à une application Java, par exemple, de récupérer des informations (prévisions météo, profils utilisateurs) ou d’envoyer des données (création de ressources) sans connaître les détails d’implémentation du serveur. Le format d’échange le plus répandu est JSON (JavaScript Object Notation), un format texte léger, lisible par l’homme et la machine, composé de paires clé-valeur, de tableaux et d’objets imbriqués. JSON est devenu le standard pour les services web car il est simple, flexible et supporté nativement par la plupart des langages.\nExemple de structure JSON typique renvoyée par un service web :\n{ \u0026#34;nom\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;estEtudiant\u0026#34;: false, \u0026#34;competences\u0026#34;: [\u0026#34;Java\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;JavaScript\u0026#34;] } Exemple avec l’API Open-Meteo (requête GET et traitement JSON manuel) # Le programme suivant récupère et affiche les prévisions météo horaires pour Montréal en interrogeant l’API Open-Meteo. Il illustre l’utilisation de l’API HttpClient, la construction d’une requête GET, la gestion des réponses JSON de manière manuelle (sans bibliothèque externe), ainsi que le traitement des dates avec java.time.\nWeatherForecast.java import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; public class WeatherForecast { public static void main(String[] args) { // Coordonnées de Montréal double latitude = 45.5017; double longitude = -73.5673; String url = \u0026#34;https://api.open-meteo.com/v1/forecast?latitude=\u0026#34; \u0026#43; latitude \u0026#43; \u0026#34;\u0026longitude=\u0026#34; \u0026#43; longitude \u0026#43; \u0026#34;\u0026hourly=temperature_2m,precipitation\u0026#34;; try { // Créer un client HTTP HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(url)) .GET() .build(); // Envoyer la requête et obtenir la réponse HttpResponse\u0026lt;String\u0026gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); String json = response.body(); // Extraire les tableaux horaires String hourly = json.substring(json.indexOf(\u0026#34;\\\u0026#34;hourly\\\u0026#34;:{\u0026#34;)); String times = extractArray(hourly, \u0026#34;\\\u0026#34;time\\\u0026#34;:\u0026#34;); String temperatures = extractArray(hourly, \u0026#34;\\\u0026#34;temperature_2m\\\u0026#34;:\u0026#34;); String precipitations = extractArray(hourly, \u0026#34;\\\u0026#34;precipitation\\\u0026#34;:\u0026#34;); // Formatter pour les dates DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm\u0026#34;); // Afficher les prévisions pour les 12 prochaines heures System.out.println(\u0026#34;Prévisions météo pour Montréal (prochaines 12 heures) :\u0026#34;); LocalDateTime now = LocalDateTime.now(); String[] timeArray = times.split(\u0026#34;,\u0026#34;); String[] tempArray = temperatures.split(\u0026#34;,\u0026#34;); String[] precipArray = precipitations.split(\u0026#34;,\u0026#34;); int count = 0; for (int i = 0; i \u0026lt; timeArray.length \u0026\u0026 count \u0026lt; 12; i\u0026#43;\u0026#43;) { String time = timeArray[i].replace(\u0026#34;[\\\u0026#34;\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;\\\u0026#34;]\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;\\\u0026#34;\u0026#34;,\u0026#34;\u0026#34;); LocalDateTime forecastTime = LocalDateTime.parse(time, formatter); if (forecastTime.isAfter(now)) { double temp = Double.parseDouble(tempArray[i].replace(\u0026#34;[\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;]\u0026#34;,\u0026#34;\u0026#34;)); double precip = Double.parseDouble(precipArray[i].replace(\u0026#34;[\u0026#34;,\u0026#34;\u0026#34;).replace(\u0026#34;]\u0026#34;,\u0026#34;\u0026#34;)); System.out.printf(\u0026#34;%s : %.1f°C, Précipitations : %.1f mm%n\u0026#34;, forecastTime.format(DateTimeFormatter.ofPattern(\u0026#34;dd/MM/yyyy HH:mm\u0026#34;)), temp, precip); count\u0026#43;\u0026#43;; } } } catch (Exception e) { System.err.println(\u0026#34;Erreur lors de la récupération des données : \u0026#34; \u0026#43; e.getMessage()); } } // Méthode pour extraire un tableau JSON spécifique private static String extractArray(String json, String key) { int start = json.indexOf(key) \u0026#43; key.length(); int end = json.indexOf(\u0026#34;]\u0026#34;, start) \u0026#43; 1; return json.substring(start, end); } } Exécuter Ce programme Java récupère les prévisions météo horaires pour Montréal en interrogeant l’API publique Open-Meteo via une requête HTTP GET construite avec l’API HttpClient de Java 11. Il définit d’abord les coordonnées géographiques de la ville et assemble l’URL de requête demandant spécifiquement les températures à 2 mètres et les précipitations. Dans un bloc try-catch pour gérer les erreurs réseau ou de traitement, il crée un client HTTP, bâtit et envoie la requête, puis récupère la réponse sous forme de chaîne JSON. Le parsing du JSON est réalisé manuellement : une sous-chaîne isole la section \u0026ldquo;hourly\u0026rdquo;, et une méthode auxiliaire extractArray extrait les tableaux correspondants aux horaires, températures et précipitations en repérant les crochets. Les dates au format ISO sont ensuite parsées avec DateTimeFormatter pour comparer chaque prévision à l’heure actuelle (via LocalDateTime.now()), filtrant ainsi les entrées futures. Enfin, une boucle affiche les 12 prochaines heures valides au format lisible, avec température en degrés Celsius et précipitations en millimètres, en nettoyant les chaînes pour convertir les valeurs numériques.\nExemple avec l’API Open-Meteo (requête GET et traitement JSON avec Jackson) # Le programme suivant récupère et affiche les prévisions météo horaires pour Montréal en interrogeant l’API Open-Meteo. Contrairement à la version manuelle, il utilise la bibliothèque Jackson pour parser la réponse JSON de manière robuste et structurée. Jackson permet de mapper directement le JSON vers des classes Java dédiées, évitant ainsi le parsing fragile basé sur des chaînes de caractères. Cela rend le code plus lisible, plus maintenable et moins sujet aux erreurs en cas de modifications mineures dans la structure du JSON.\nPour utiliser Jackson, ajoutez la dépendance suivante à votre projet (par exemple via Maven) :\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Le programme définit deux classes internes : Hourly pour représenter la section \u0026ldquo;hourly\u0026rdquo; contenant les listes de données, et ForecastResponse pour l\u0026rsquo;objet racine de la réponse. Jackson désérialise automatiquement les tableaux en listes Java, et nous pouvons ensuite itérer facilement sur les données synchronisées (les indices correspondent entre time, temperature_2m et precipitation).\nWeatherForecastJackson.java import com.fasterxml.jackson.annotation.JsonIgnoreProperties; import com.fasterxml.jackson.databind.ObjectMapper; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; import java.util.List; public class WeatherForecastJackson { // Ignore extra fields in the JSON response to avoid crashes @JsonIgnoreProperties(ignoreUnknown = true) public static class Hourly { public List\u0026lt;String\u0026gt; time; public List\u0026lt;Double\u0026gt; temperature_2m; public List\u0026lt;Double\u0026gt; precipitation; } @JsonIgnoreProperties(ignoreUnknown = true) public static class ForecastResponse { public Hourly hourly; } public static void main(String[] args) { double latitude = 45.5017; double longitude = -73.5673; String url = \u0026#34;https://api.open-meteo.com/v1/forecast?latitude=\u0026#34; \u0026#43; latitude \u0026#43; \u0026#34;\u0026longitude=\u0026#34; \u0026#43; longitude \u0026#43; \u0026#34;\u0026hourly=temperature_2m,precipitation\u0026#34;; try { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(url)) .GET() .build(); HttpResponse\u0026lt;String\u0026gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); // Jackson Mapper ObjectMapper mapper = new ObjectMapper(); ForecastResponse forecast = mapper.readValue(response.body(), ForecastResponse.class); // Formatters DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm\u0026#34;); DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern(\u0026#34;dd/MM/yyyy HH:mm\u0026#34;); System.out.println(\u0026#34;Prévisions météo pour Montréal (prochaines 12 heures) :\u0026#34;); LocalDateTime now = LocalDateTime.now(); if (forecast.hourly != null) { List\u0026lt;String\u0026gt; times = forecast.hourly.time; List\u0026lt;Double\u0026gt; temperatures = forecast.hourly.temperature_2m; List\u0026lt;Double\u0026gt; precipitations = forecast.hourly.precipitation; int count = 0; for (int i = 0; i \u0026lt; times.size() \u0026\u0026 count \u0026lt; 12; i\u0026#43;\u0026#43;) { LocalDateTime forecastTime = LocalDateTime.parse(times.get(i), inputFormatter); // Filter for future forecasts if (forecastTime.isAfter(now)) { System.out.printf(\u0026#34;%s : %.1f°C, Précipitations : %.1f mm%n\u0026#34;, forecastTime.format(outputFormatter), temperatures.get(i), precipitations.get(i)); count\u0026#43;\u0026#43;; } } } } catch (Exception e) { System.err.println(\u0026#34;Erreur : \u0026#34; \u0026#43; e.getMessage()); e.printStackTrace(); } } } Exécuter Cette approche avec Jackson est nettement plus élégante que le parsing manuel : elle gère automatiquement les structures imbriquées et les tableaux, tolère mieux les champs supplémentaires dans le JSON, et facilite l’extension du programme (par exemple, ajouter d’autres variables météo). En production, il est recommandé d’utiliser une bibliothèque comme Jackson ou Gson plutôt qu’un parsing texte maison.\nExemple avec requêtes GET et POST (HttpClientExample) # Ce second programme montre deux usages classiques : une requête GET pour récupérer des données publiques depuis l’API GitHub, et une requête POST pour simuler l’envoi de données JSON vers une API de test. Il met en évidence la construction des en-têtes, du corps de requête et la gestion des réponses.\nHttpClientExample.java import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.nio.charset.StandardCharsets; public class HttpClientExample { public static void main(String[] args) { // Création du client HTTP HttpClient client = HttpClient.newBuilder() .build(); try { // Exemple de requête GET HttpRequest getRequest = HttpRequest.newBuilder() .uri(URI.create(\u0026#34;https://api.github.com/users/octocat\u0026#34;)) .header(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;) .GET() .build(); HttpResponse\u0026lt;String\u0026gt; getResponse = client.send(getRequest, HttpResponse.BodyHandlers.ofString()); System.out.println(\u0026#34;GET Response Status: \u0026#34; \u0026#43; getResponse.statusCode()); System.out.println(\u0026#34;GET Response Body: \u0026#34; \u0026#43; getResponse.body()); // Exemple de requête POST String jsonPayload = \u0026#34;{\\\u0026#34;title\\\u0026#34;: \\\u0026#34;Test\\\u0026#34;, \\\u0026#34;body\\\u0026#34;: \\\u0026#34;Test request\\\u0026#34;}\u0026#34;; HttpRequest postRequest = HttpRequest.newBuilder() .uri(URI.create(\u0026#34;https://jsonplaceholder.typicode.com/posts\u0026#34;)) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .POST(HttpRequest.BodyPublishers.ofString(jsonPayload, StandardCharsets.UTF_8)) .build(); HttpResponse\u0026lt;String\u0026gt; postResponse = client.send(postRequest, HttpResponse.BodyHandlers.ofString()); System.out.println(\u0026#34;\\nPOST Response Status: \u0026#34; \u0026#43; postResponse.statusCode()); System.out.println(\u0026#34;POST Response Body: \u0026#34; \u0026#43; postResponse.body()); } catch (Exception e) { e.printStackTrace(); } } } Exécuter Ce programme Java démontre l’utilisation de l’API HttpClient introduite en Java 11 pour effectuer des requêtes HTTP synchrones, en illustrant deux méthodes courantes : GET pour récupérer des données et POST pour en envoyer. Il commence par créer un client HTTP configurable via HttpClient.newBuilder(), ici avec les paramètres par défaut. Dans un bloc try-catch capturant les exceptions potentielles (erreurs réseau, interruptions ou problèmes de réponse), il construit et envoie d’abord une requête GET vers l’API GitHub pour obtenir les informations publiques de l’utilisateur \u0026ldquo;octocat\u0026rdquo;, en spécifiant l’en-tête \u0026ldquo;Accept: application/json\u0026rdquo; pour demander une réponse au format JSON ; le code de statut (généralement 200 en cas de succès) et le corps de la réponse (un objet JSON décrivant l’utilisateur) sont ensuite affichés. La seconde partie concerne une requête POST vers l’API de test jsonplaceholder.typicode.com, où un corps JSON simple est préparé comme payload, encodé en UTF-8, et envoyé avec l’en-tête \u0026ldquo;Content-Type: application/json\u0026rdquo; pour indiquer le format des données ; le serveur simule la création d’une ressource et renvoie un code de statut (typiquement 201 pour création) accompagné d’un corps JSON enrichi (par exemple avec un ID généré), qui est également affiché. Ce code met en évidence la simplicité de construction des requêtes (via un builder), la gestion des en-têtes et du corps, ainsi que le traitement basique des réponses, tout en soulignant l’importance de la gestion d’exceptions dans les communications réseau.\n"},{"id":84,"href":"/orientee_donnees/docs/modules/e_module_services/serviceweb/","title":"Création d'un service web","section":"Module Services et YAML","content":" Projet de création d\u0026rsquo;un service web # Dans ce projet, le serveur utilise la notion de \u0026ldquo;contexte\u0026rdquo; ou \u0026ldquo;route\u0026rdquo; pour diriger les requêtes vers différents gestionnaires. Un contexte est défini par un chemin d\u0026rsquo;URL, comme \u0026ldquo;/\u0026rdquo; pour la racine du site ou \u0026ldquo;/heure\u0026rdquo; pour une ressource spécifique. Chaque contexte est associé à une fonction qui gère les requêtes entrantes, permettant au serveur de servir différents contenus ou d\u0026rsquo;exécuter différentes actions en fonction de l\u0026rsquo;URL demandée.\nCe projet est un serveur simple en Java qui sert une page HTML sur la racine (/) et fournit l\u0026rsquo;heure actuelle en XML sur /heure.\nFichiers # Copiez ces fichiers dans un répertoire.\nServeurHeure.java :\nimport com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.HttpExchange; import javax.xml.stream.XMLOutputFactory; import javax.xml.stream.XMLStreamWriter; import java.io.IOException; import java.io.OutputStream; import java.io.StringWriter; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; public class ServeurHeure { private static final XMLOutputFactory xmlFactory = XMLOutputFactory.newFactory(); private static String genererXmlHeure() throws Exception { StringWriter stringWriter = new StringWriter(); XMLStreamWriter xml = xmlFactory.createXMLStreamWriter(stringWriter); xml.writeStartDocument(\u0026#34;UTF-8\u0026#34;, \u0026#34;1.0\u0026#34;); xml.writeStartElement(\u0026#34;heure\u0026#34;); xml.writeCharacters(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())); xml.writeEndElement(); xml.writeEndDocument(); xml.flush(); xml.close(); return stringWriter.toString(); } public static void main(String[] args) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\u0026#34;/\u0026#34;, exchange -\u0026gt; { if (\u0026#34;GET\u0026#34;.equals(exchange.getRequestMethod())) { try { String html = new String(Files.readAllBytes(Paths.get(\u0026#34;index.html\u0026#34;)), \u0026#34;UTF-8\u0026#34;); byte[] response = html.getBytes(\u0026#34;UTF-8\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, response.length); try (OutputStream os = exchange.getResponseBody()) { os.write(response); } } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else { exchange.sendResponseHeaders(405, -1); } }); server.createContext(\u0026#34;/heure\u0026#34;, exchange -\u0026gt; { if (\u0026#34;GET\u0026#34;.equals(exchange.getRequestMethod())) { try { String xml = genererXmlHeure(); byte[] response = xml.getBytes(\u0026#34;UTF-8\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/xml; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, response.length); try (OutputStream os = exchange.getResponseBody()) { os.write(response); } } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else { exchange.sendResponseHeaders(405, -1); } }); server.setExecutor(null); server.start(); System.out.println(\u0026#34;Serveur démarré sur http://localhost:8000/\u0026#34;); } } index.html :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Serveur d\u0026#39;Heure\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Serveur d\u0026#39;heure\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Heure actuelle: \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;fetchBtn\u0026#34;\u0026gt;Obtenir l\u0026#39;heure\u0026lt;/button\u0026gt; \u0026lt;h2\u0026gt;XML brut:\u0026lt;/h2\u0026gt; \u0026lt;pre id=\u0026#34;rawXml\u0026#34;\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#39;fetchBtn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function() { fetch(\u0026#39;/heure\u0026#39;) .then(response =\u0026gt; response.text()) .then(xmlString =\u0026gt; { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, \u0026#39;application/xml\u0026#39;); const time = xmlDoc.getElementsByTagName(\u0026#39;heure\u0026#39;)[0].textContent; document.getElementById(\u0026#39;time\u0026#39;).textContent = time; document.getElementById(\u0026#39;rawXml\u0026#39;).textContent = xmlString; }) .catch(error =\u0026gt; console.error(\u0026#39;Erreur:\u0026#39;, error)); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Utilisation # Compilez le programme Java :\njavac ServeurHeureStax.java Lancez le serveur :\njava ServeurHeureStax Attention. Si un autre serveur sur votre machine utilise le port 8000, le serveur ne pourra pas démarrer correctement. Vous pouvez changer le port dans le programme ou mettre fin à l\u0026rsquo;autre serveur.\nOuvrez un navigateur et allez à http://localhost:8000/. Cliquez sur le bouton \u0026ldquo;Obtenir l\u0026rsquo;heure\u0026rdquo; pour récupérer et afficher l\u0026rsquo;heure actuelle. Le XML brut est également affiché en bas de la page.\nVous pouvez également accéder directement à http://localhost:8000/heure pour obtenir l\u0026rsquo;XML de l\u0026rsquo;heure.\nDescription du code # ServeurHeureStax.java # Ce fichier contient la classe principale ServeurHeureStax. Il utilise l\u0026rsquo;API HttpServer de Java pour créer un serveur HTTP simple écoutant sur le port 8000.\nImports : Inclut les classes nécessaires pour le serveur HTTP, la génération XML avec StAX, la lecture de fichiers, et la manipulation des dates. Méthode genererXmlHeure() : Génère un document XML simple avec l\u0026rsquo;heure actuelle au format ISO. Utilise XMLOutputFactory et XMLStreamWriter pour construire le XML de manière programmatique. Méthode main() : Crée une instance d\u0026rsquo;HttpServer. Définit deux contextes de gestion des requêtes : Pour / : Lit le fichier index.html et le sert avec le type MIME text/html. Pour /heure : Appelle genererXmlHeure() et sert le XML avec le type MIME application/xml. Démarre le serveur et affiche un message de confirmation. index.html # Page web statique servie par le serveur.\nStructure HTML : Titre, paragraphe pour afficher l\u0026rsquo;heure, bouton pour déclencher la requête, et section pour afficher le XML brut. JavaScript : Écouteur d\u0026rsquo;événement sur le bouton qui effectue une requête fetch vers /heure. Analyse la réponse XML avec DOMParser. Extrait le contenu de l\u0026rsquo;élément \u0026lt;heure\u0026gt; pour l\u0026rsquo;afficher. Affiche également le XML brut dans un élément \u0026lt;pre\u0026gt;. Activités suggérées # Modifier le format XML : Changez la structure du XML généré (par exemple, ajoutez des éléments pour la date et l\u0026rsquo;heure séparément) et mettez à jour le JavaScript pour analyser la nouvelle structure.\nAjouter un endpoint pour la date : Créez un nouveau contexte /date qui retourne la date actuelle en JSON, et ajoutez un bouton dans l\u0026rsquo;HTML pour le récupérer et l\u0026rsquo;afficher.\nAméliorer l\u0026rsquo;interface utilisateur : Ajoutez du CSS pour styliser la page (par exemple, centrer le contenu, changer les couleurs) et peut-être une fonctionnalité pour rafraîchir l\u0026rsquo;heure automatiquement toutes les minutes.\nConvertissez le service en JSON : Pouvez-vous remplacer le serveur basé sur XML par un serveur basé sur JSON?\n"},{"id":85,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/attribut_mode/","title":"Attribut mode","section":"XSLT","content":" Attribut mode # Utilisation de l\u0026rsquo;attribut « mode » # Dans cette section, nous explorons l\u0026rsquo;utilisation de l\u0026rsquo;attribut mode en XSLT, qui permet de définir plusieurs modèles pour le même élément et de les appliquer sélectivement pour créer des vues différentes du document XML.\nIl arrive que nous voulions définir plus d\u0026rsquo;un modèle pour un élément donné. Nous pouvons ajouter des modèles en utilisant l\u0026rsquo;attribut « mode » qui s\u0026rsquo;applique aux éléments « xsl:apply-templates » et « xsl:template ». La règle est très simple : si votre élément « xsl:apply-templates » a une valeur d\u0026rsquo;attribut pour « mode », alors seuls les éléments « xsl:template » ayant la même valeur d\u0026rsquo;attribut pour « mode » s\u0026rsquo;appliquent. On utilise souvent l\u0026rsquo;attribut « mode » pour faire des tables des matières.\nPrenons, par exemple, la liste de cours suivants :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;universite\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 102 Introduction avancée\u0026lt;/nom\u0026gt; \u0026lt;description\u0026gt;Un cours d\u0026#39;introduction à l\u0026#39;informatique pour futurs ingénieurs.\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 101 Introduction\u0026lt;/nom\u0026gt; \u0026lt;description\u0026gt;Un cours d\u0026#39;introduction à l\u0026#39;informatique pour les étudiants en éducation.\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 103 Java\u0026lt;/nom\u0026gt; \u0026lt;description\u0026gt;Un cours d\u0026#39;introduction au Java\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;/universite\u0026gt; Nous pourrions vouloir que s\u0026rsquo;affiche d\u0026rsquo;abord seulement la liste des noms de cours et que cette dernière soit suivie d\u0026rsquo;une liste détaillée comprenant le nom et la description du cours :\nLa liste des cours en bref:\nINF 102 Introduction avancée INF 101 Introduction INF 103 Java La liste détaillée des cours:\nINF 102 Introduction avancée: Un cours d\u0026rsquo;introduction à l\u0026rsquo;informatique pour futurs ingénieurs. INF 101 Introduction: Un cours d\u0026rsquo;introduction à l\u0026rsquo;informatique pour les étudiants en éducation. INF 103 Java: Un cours d\u0026rsquo;introduction au Java Nous pouvons obtenir ce résultat avec le document XSLT suivant qui utilise l\u0026rsquo;attribut « mode » :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;universite\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;p\u0026gt;La liste des cours en bref:\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;cours\u0026#34; mode=\u0026#34;initial\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;La liste détaillée des cours:\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;cours\u0026#34; mode=\u0026#34;complet\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;cours\u0026#34; mode=\u0026#34;initial\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;cours\u0026#34; mode=\u0026#34;complet\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt; : \u0026lt;xsl:value-of select=\u0026#34;description\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; "},{"id":86,"href":"/orientee_donnees/docs/modules/b_module_xml/base/mise_en_forme_du_xml/","title":"Mise en forme du XML","section":"Les fondements","content":" Si vous utilisez un traitement de texte pour préparer votre travaux et que vous souhaitez présenter le code XML, vous pouvez utiliser cette application pour le mettre en forme. Saisissez votre code XML et copiez la version mise en forme. Vous pouvez ensuite la copier dans votre logiciel de traitement de texte. Attention : Une ou plusieurs lignes dépassent 80 caractères ! Écrivez ou collez du code XML ici Résultat formaté Copier "},{"id":87,"href":"/orientee_donnees/legacy/semaine_3/travail_1/","title":"Travail 1","section":"Semaine 3","content":" Travail 1 Attention ! Le cours comprend quelques consignes simples pour la remise des travaux. Si vous choisissez de ne pas en tenir compte, il est possible que vous deviez subir des délais supplémentaires. Consignes Lorsque vous aurez terminé le travail, transmettez à votre personne tutrice, un seul document (Word 97/2000/XP, ODF , PDF, RTF ou en format texte). Ne transmettez pas vos solutions en plusieurs fichiers. Ne transmettez pas une archive compressée (zip ou autre). Il s’agit d’un travail personnel et vous ne devez pas partager vos solutions. Vous devez transmettre votre travail en utilisant l’outil de dépôt de l’Université. Rappel : Ne transmettez pas vos travaux dans ce cours sous la forme d’une archive compressée (zip, rar ou autre). D’une part, cela est inutile. D’autre part, cela engendre des manipulations supplémentaires. Les travaux transmis sous la forme d’archive compressée pourront être considéré comme n’ayant pas été reçu. Il est de votre responsabilité de lire et de suivre les consignes. Les archives RAR ne sont jamais acceptées. Précision : Nous n’offrons pas d’accusé de réception. C’est inutile, car il n’y a pas de pénalité pour les remises de travail en retard dans ce cours. Gardez toujours une copie de chacun de vos travaux jusqu’à la fin du cours. Cette activité notée compte pour 10% de la note globale. 1. Combien y a-t-il d’éléments dans le document XML suivant ? \u0026lt;conf xml :space=\"preserve\"\u0026gt; \u0026lt;unite groupe=\"universite\" temps=\"1086585433\" maison=\"Jean\" \u0026gt; Davantage l’an prochain. \u0026lt;/unite\u0026gt; \u0026lt;maison/\u0026gt; \u0026lt;/conf\u0026gt; 2. Toujours avec le même document XML, quel est le nom de l’élément-racine ? 3. Quel est le contenu de l’élément « president » dans le document XML suivant ? \u0026lt; ?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?\u0026gt; \u0026lt; !DOCTYPE _ [ \u0026lt; !ENTITY % administration \"Jeanne Perron\" \u0026gt; \u0026lt; !ENTITY administration \"Jean Boudin\"\u0026gt; \u0026lt; !ELEMENT _ (president,comptable,adjoint)*\u0026gt; \u0026lt; !ELEMENT president (#PCDATA)\u0026gt; \u0026lt; !ELEMENT comptable (#PCDATA)\u0026gt; \u0026lt; !ELEMENT adjoint (#PCDATA)\u0026gt; ]\u0026gt; \u0026lt;_\u0026gt; \u0026lt;president\u0026gt;\u0026amp;administration ;\u0026lt;/president\u0026gt; \u0026lt;comptable\u0026gt;\u0026amp;administration ;\u0026lt;/comptable\u0026gt; \u0026lt;adjoint\u0026gt;Marion Lepage\u0026lt;/adjoint\u0026gt; \u0026lt;/_\u0026gt; 4. À quel espace de noms, identifié par son URI, est-ce que l’élément « mots-clefs » appartient dans le document suivant ? https://gist.github.com/lemire/7a51885a8671bc3d5eff (Suivez l’hyperlien.) 5. Toujours avec le même document XML, combien y a-t-il d’espaces de noms dans ce document à l’exception de l’espace de noms par défaut ? 6. Le document XML suivant n’est pas valide : https://gist.github.com/lemire/66d0a7905443fdd220c1 Combien comptez-vous d’erreurs ? Expliquez chacune des erreurs identifiées. Rappel : Les archives RAR ne sont pas acceptées lors de la remise des travaux. "},{"id":88,"href":"/orientee_donnees/legacy/semaine_10/travail_3/","title":"Travail 3","section":"Semaine 10","content":" Travail 3 Consignes Faites les exercices et répondez aux questions en utilisant Chrome comme moteur XSLT et comme navigateur. En effectuant les exercices, n'utilisez que des fonctions disponibles dans Chrome . Une fois votre travail terminé, transmettez à votre personne tutrice, un document (Word 97/2000/XP, ODF , PDF, RTF ou en format texte) en fichier attaché. Il s'agit d'un travail personnel et vous ne devez pas partager vos solutions. Cette activité notée compte pour 15% de la note globale. Vous devez transmettre votre travail en utilisant l'outil de dépôt de l'Université. Bon travail! Exercice 1 Étant donné le document XML suivant, rédigez le contenu du document CSS « test.css », de telle sorte que les mots « Rouge » s'affichent en rouge, les mots « Noir » s'affichent en noir, les mots « majuscule » s'affichent en majuscule et ainsi de suite. Votre document CSS doit contenir au plus 5 instructions CSS de la forme « quelque chose {autre chose} ». Indice : Vous pouvez utiliser « color:red », « color:olive », « color:black », « color:blue », et ainsi de suite pour fixer la couleur du texte. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;?xml-stylesheet type=\"text/css\" href=\"test.css\"?\u0026gt; \u0026lt;a\u0026gt; \u0026lt;b\u0026gt;Rouge\u0026lt;/b\u0026gt; \u0026lt;c\u0026gt;\u0026lt;a\u0026gt;Olive\u0026lt;/a\u0026gt; \u0026lt;b\u0026gt;Bleu\u0026lt;/b\u0026gt; \u0026lt;a\u0026gt;\u0026lt;a\u0026gt;Noir\u0026lt;/a\u0026gt; Olive \u0026lt;b\u0026gt;Bleu\u0026lt;/b\u0026gt; \u0026lt;a\u0026gt;Rouge\u0026lt;/a\u0026gt; \u0026lt;a\u0026gt;Noir\u0026lt;/a\u0026gt; \u0026lt;/a\u0026gt;\u0026lt;/c\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a\u0026gt;Rouge\u0026lt;/a\u0026gt; \u0026lt;b\u0026gt;Noir\u0026lt;/b\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;d\u0026gt;majuscule\u0026lt;/d\u0026gt; \u0026lt;/a\u0026gt; Vous pouvez tester votre solution en ligne: \u0026lt;?xml version=\"1.0\" ?\u0026gt; \u0026lt;a\u0026gt; \u0026lt;b\u0026gt;Rouge\u0026lt;/b\u0026gt; \u0026lt;c\u0026gt;\u0026lt;a\u0026gt;Olive\u0026lt;/a\u0026gt; \u0026lt;b\u0026gt;Bleu\u0026lt;/b\u0026gt; \u0026lt;a\u0026gt;\u0026lt;a\u0026gt;Noir\u0026lt;/a\u0026gt; Olive \u0026lt;b\u0026gt;Bleu\u0026lt;/b\u0026gt; \u0026lt;a\u0026gt;Rouge\u0026lt;/a\u0026gt; \u0026lt;a\u0026gt;Noir\u0026lt;/a\u0026gt; \u0026lt;/a\u0026gt;\u0026lt;/c\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a\u0026gt;Rouge\u0026lt;/a\u0026gt; \u0026lt;b\u0026gt;Noir\u0026lt;/b\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;d\u0026gt;majuscule\u0026lt;/d\u0026gt; \u0026lt;/a\u0026gt; Document CSS: a { display: block; color: red; } Résultat : Exercice 2 Supposons que toutes les notes des étudiants, dans différents cours, se trouvent dans le document XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;?xml-stylesheet href=\"class.xsl\" type=\"text/xsl\" ?\u0026gt; \u0026lt;universite\u0026gt; \u0026lt;etudiant\u0026gt;\u0026lt;nom\u0026gt;Réjean Tremblay\u0026lt;/nom\u0026gt; \u0026lt;cours sigle=\"INF8430\" note=\"89\" /\u0026gt; \u0026lt;cours sigle=\"INF1030\" note=\"69\" /\u0026gt; \u0026lt;cours sigle=\"INF1230\" note=\"75\" /\u0026gt;\u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt;\u0026lt;nom\u0026gt;Martin Lambert\u0026lt;/nom\u0026gt; \u0026lt;cours sigle=\"INF8430\" note=\"75\" /\u0026gt; \u0026lt;cours sigle=\"INF1030\" note=\"72\" /\u0026gt; \u0026lt;cours sigle=\"INF1230\" note=\"73\" /\u0026gt;\u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt;\u0026lt;nom\u0026gt;Luc Alain\u0026lt;/nom\u0026gt; \u0026lt;cours sigle=\"INF9430\" note=\"39\" /\u0026gt; \u0026lt;cours sigle=\"INF1030\" note=\"89\" /\u0026gt; \u0026lt;cours sigle=\"INF1230\" note=\"79\" /\u0026gt;\u0026lt;/etudiant\u0026gt; \u0026lt;etudiant\u0026gt;\u0026lt;nom\u0026gt;Olive Saint-Amant\u0026lt;/nom\u0026gt; \u0026lt;cours sigle=\"INF8430\" note=\"91\" /\u0026gt; \u0026lt;cours sigle=\"INF1230\" note=\"99\" /\u0026gt;\u0026lt;/etudiant\u0026gt; \u0026lt;/universite\u0026gt; À partir de ce document XML, fournissez le document XSLT « class.xsl » qui calcule les moyennes des étudiants, d'après les éléments « cours » associés aux éléments « étudiant », et qui trie les étudiants par ordre alphabétique de leur nom de famille. Votre document XSLT doit fonctionner même si on change le nom des étudiants, l'ordre des éléments et le nom des cours. En conséquence, le nom des étudiants ou le nom des cours ne peuvent apparaître dans votre document XSLT. En outre, vous ne devez pas utiliser les crochets « [ ] » dans votre solution. Vous pouvez tester votre solution en ligne à l'aide du laboratoire XSLT. Indices Le tableau ci-dessous devrait vous permettre de vérifier votre réponse. Étudiant Moyenne Luc Alain 69.0 Martin Lambert 73.3 Olive Saint-Amant 95.0 Réjean Tremblay 77.7 Vous pouvez trier les étudiants selon leur nom de famille, en remplaçant « \u0026lt;xsl:apply-templates select=\"etudiant\" /\u0026gt; » par : \u0026lt;xsl:apply-templates select=\"etudiant\" \u0026gt; \u0026lt;xsl:sort select=\"substring-after(nom,' ')\" order=\"ascending\"/\u0026gt; \u0026lt;/xsl:apply-templates\u0026gt; Vous pouvez formater les nombres à virgule flottante comme dans le tableau, en utilisant des appels de fonction XSLT tels que « format-number(10.1324, '##.0') ». Exercice 3 Utilisez le même document XML qu'à l'exercice précédent. Cette fois-ci, comptez le nombre d'étudiants dans chaque cours et calculez la moyenne par cours. Encore une fois, les noms des cours ou des étudiants ne doivent pas apparaître dans votre document XSLT. Le tableau qui suit présente le résultat. Sigle Nombre d'étudiants Moyenne du cours INF8430 3 85.0 INF1030 3 76.7 INF1230 4 81.5 INF9430 1 39.0 Bien que cet exercice soit très similaire au précédent et que la solution soit de même longueur, vous le trouverez probablement plus difficile. Note . Si vous aviez le droit d'utiliser XSLT 2.0, la nouvelle instruction « xsl:for-each-group » rendrait ce problème plus facile. Mais rappelez-vous que vous devez vous limiter à XSLT 1.0. Exercice 4 Supposons que vous ayiez des documents contenant exclusivement une déclaration XML, des éléments et des attributs. Il n'y a pas d'espace de noms. Vous souhaitez filtrer les documents XML de telle manière que seuls les éléments dont le nom contient la lettre a sont inclus. Naturellement, les éléments, peu importe leur nom, qui ne sont pas contenus dans un élément dont le nom contient la lettre a doivent être omis. Le document XML devra contenir une instruction xml-stylesheet, mais elle ne doit pas être reproduite dans le document sortant. Si on prend cet exemple: \u0026lt;?xml-stylesheet href=\"monfichier.xsl\" type=\"text/xsl\" ?\u0026gt; \u0026lt;a\u0026gt; \u0026lt;ab x=\"x\"\u0026gt;\u0026lt;b\u0026gt;Test\u0026lt;/b\u0026gt;\u0026lt;a\u0026gt;z\u0026lt;/a\u0026gt;\u0026lt;/ab\u0026gt; \u0026lt;z x=\"x\"\u0026gt;\u0026lt;a\u0026gt;z\u0026lt;/a\u0026gt;\u0026lt;/z\u0026gt; \u0026lt;/a\u0026gt; On souhaite que le document sortant soit celui-ci: \u0026lt;a\u0026gt; \u0026lt;ab x=\"x\"\u0026gt;\u0026lt;a\u0026gt;z\u0026lt;/a\u0026gt;\u0026lt;/ab\u0026gt; \u0026lt;/a\u0026gt; Vous devez proposer deux documents XSLT permettant de réaliser ce filtrage. Le premier document ne devra pas contenir d'élément « xsl:element », alors que le second ne contiendra pas d'élément « xsl:copy ». Comme précédemment, vous pouvez vérifier votre solution en ligne. Exercice 5 Considérez le fichier XML de la question 2 comprenant les notes des étudiants. Écrivez une requête XQuery qui calcule la moyenne des notes de chaque cours et la présente sous cette forme : \u0026lt;maliste\u0026gt; \u0026lt;cours sigle=\"INF8430\"\u0026gt;85\u0026lt;/cours\u0026gt; \u0026lt;cours sigle=\"INF1030\"\u0026gt;76.66666666666667\u0026lt;/cours\u0026gt; \u0026lt;cours sigle=\"INF1230\"\u0026gt;81.5\u0026lt;/cours\u0026gt; \u0026lt;cours sigle=\"INF9430\"\u0026gt;39\u0026lt;/cours\u0026gt; \u0026lt;/maliste\u0026gt; Vous pouvez utiliser la fonction avg qui calcule la moyenne. "},{"id":89,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/la_fonction_generate-id/","title":"La fonction generate-id","section":"XSLT","content":" La fonction generate-id # Fonction « generate-id » # Dans cette section, nous découvrons la fonction generate-id en XSLT, qui permet de générer des identifiants uniques pour les éléments XML, utiles pour créer des références ou des ancres dans les documents transformés.\nLa fonction XSLT « generate-id » génère un « nom » unique pour chaque élément d\u0026rsquo;un document XML. Ce nom sera toujours le même pour un même élément, même si nous le rencontrons à plusieurs reprises. Si nous reprenons la liste des cours de l\u0026rsquo;exemple précédent sur l\u0026rsquo;utilisation de l\u0026rsquo;attribut « mode », nous pourrions générer un identifiant unique pour chaque cours et l\u0026rsquo;afficher comme dans l\u0026rsquo;exemple de document XSLT qui suit :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;universite\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;p\u0026gt;La liste des cours en bref :\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;cours\u0026#34; mode=\u0026#34;initial\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;La liste détaillée des cours :\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;cours\u0026#34; mode=\u0026#34;complet\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;cours\u0026#34; mode=\u0026#34;initial\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt; (identifiant: \u0026lt;xsl:value-of select=\u0026#34;generate-id(.)\u0026#34; /\u0026gt;)\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;cours\u0026#34; mode=\u0026#34;complet\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt; : \u0026lt;xsl:value-of select=\u0026#34;description\u0026#34; /\u0026gt; (identifiant: \u0026lt;xsl:value-of select=\u0026#34;generate-id(.)\u0026#34; /\u0026gt;)\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Nous pourrions alors obtenir un résultat comme celui-ci :\nLa liste des cours en bref:\nINF 102 Introduction avancée (identifiant: id2243749) INF 101 Introduction (identifiant: id2243760) INF 103 Java (identifiant: id2243686) La liste détaillée des cours:\nINF 102 Introduction avancée: Un cours d\u0026rsquo;introduction à l\u0026rsquo;informatique pour futurs ingénieurs. (identifiant: id2243749) INF 101 Introduction: Un cours d\u0026rsquo;introduction à l\u0026rsquo;informatique pour les étudiants en éducation. (identifiant: id2243760) INF 103 Java: Un cours d\u0026rsquo;introduction au Java (identifiant: id2243686) Les valeurs exactes que prennent les identifiants sont sans importance, mais il importe que ce soit toujours la même valeur pour un même élément. Par exemple, le cours sur Java obtient toujours l\u0026rsquo;identifiant « id2243686 » dans notre exemple.\n"},{"id":90,"href":"/orientee_donnees/docs/modules/b_module_xml/base/laboratoire_sur_la_structure_en_arbre_des_documents_xml/","title":"Laboratoire sur la structure en arbre des documents XML","section":"Les fondements","content":" Laboratoire sur la structure en arbre des documents XML Il est important de bien comprendre la structure en arbre des documents XML. Comme nous l’avons vu, un document XML est arbre dont la racine est toujours le noeud-racine suivi normalement d’autres noeuds, comme des noeuds d’éléments. Les différents noeuds sont ordonnés (si on interverti deux éléments, on crée de facto un nouveau document). Il faut comprendre que les bouts de texte apparaissant dans un document XML sont noeuds à part entière. Nous vous invitons donc à utiliser l’application suivant pour bien vous familiariser avec la structure des documents XML. Vous pouvez saisir un document XML et le décomposer. Essayez de créer vos propres documents (bien formés) pour tester votre compréhension. Bien sûr, si vous saisissez un document XML qui n’est pas valable, vous n’obtiendrez pas une décomposition, mais un message d’erreur. Faites des expérience jusqu’à ce que vous soyez certain d’avoir bien compris. Application d'arborescence XML Entrez un contenu XML dans le champ ci-dessous, puis cliquez sur \"Dessine\" pour afficher l'arborescence sous forme de liste hiérarchique, incluant les attributs des nœuds. Exemple : \u0026lt;library\u0026gt; \u0026lt;book id=\"1\" genre=\"fiction\"\u0026gt; \u0026lt;title\u0026gt;The Hobbit\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;J.R.R. Tolkien\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book id=\"2\" genre=\"non-fiction\"\u0026gt; \u0026lt;title\u0026gt;Sapiens\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Yuval Noah Harari\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/library\u0026gt; Contenu XML : \u0026lt;library\u0026gt; \u0026lt;book id=\"1\" genre=\"fiction\"\u0026gt; The Hobbit \u0026lt;author\u0026gt;J.R.R. Tolkien\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book id=\"2\" genre=\"non-fiction\"\u0026gt; Sapiens \u0026lt;author\u0026gt;Yuval Noah Harari\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/library\u0026gt; Dessine "},{"id":91,"href":"/orientee_donnees/docs/modules/b_module_xml/base/labo/","title":"Vérificateur de XML bien formé","section":"Les fondements","content":" Vérificateur de XML bien formé # Collez votre document XML ci-dessous et cliquez sur le bouton pour vérifier s’il est bien formé. Vérifiez votre compréhension de la syntaxe XML en testant différents documents.\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003ccatalogue\u003e\u0026#10; \u003clivre id=\"1\"\u003e\u0026#10; \u003ctitre\u003eLe Petit Prince\u003c/titre\u003e\u0026#10; \u003cauteur\u003eAntoine de Saint-Exupéry\u003c/auteur\u003e\u0026#10; \u003cannée\u003e1943\u003c/année\u003e\u0026#10; \u003c/livre\u003e\u0026#10; Vérifier le XML\n"},{"id":92,"href":"/orientee_donnees/docs/modules/e_module_services/yaml/","title":"YAML","section":"Module Services et YAML","content":" YAML JSON (JavaScript Object Notation) est aujourd’hui le format le plus populaire pour échanger des données structurées, surtout dans les API web. Il est très strict : tout est basé sur des objets avec des tableaux, des chaînes entre guillemets doubles, des nombres, des booléens (true/false) et null. Sa syntaxe est rigide mais extrêmement prévisible pour les machines, ce qui explique son succès. Cependant, quand un humain doit lire ou écrire du JSON à la main (par exemple dans un fichier de configuration), cette rigueur devient vite pénible : les guillemets partout, les virgules obligatoires, l’absence de commentaires rendent le fichier verbeux et sujet aux erreurs de syntaxe. YAML (YAML Ain’t Markup Language) est né justement pour résoudre ce problème de lisibilité tout en restant compatible, dans une très large mesure, avec la structure de données de JSON. YAML est en réalité un sur-ensemble de JSON : tout fichier JSON valide est aussi un YAML valide. Cela signifie que vous pouvez prendre n’importe quel JSON et le parser avec un parseur YAML sans modification. Mais YAML va beaucoup plus loin en offrant une syntaxe beaucoup plus naturelle et agréable pour les humains. Contrairement à JSON qui n’autorise qu’une seule façon d’écrire les données (accolades et crochets), YAML propose deux syntaxes principales : la syntaxe indentée (la plus courante, proche du Python) et la syntaxe « en ligne » qui ressemble énormément à JSON. Grâce à l’indentation (généralement 2 espaces), on élimine presque totalement les accolades, les virgules de fin et les guillemets autour des clés. YAML autorise aussi nativement les commentaires avec #, les listes simples avec - et supporte des types supplémentaires comme les dates, les timestamps ou les valeurs null écrites ~ ou null ou simplement absentes. Si on compare avec XML, on voit que YAML et XML poursuivent des objectifs opposés bien qu’ils soient tous les deux plus lisibles que JSON brut. XML est un langage de balisage (markup language) avec des balises ouvrantes et fermantes, des attributs, des namespaces, conçu à l’origine pour structurer des documents. Il est extrêmement verbeux et exigeant en syntaxe. YAML, au contraire, n’est pas un langage de balisage mais un format de sérialisation de données. Il cherche la concision et la clarté maximale pour représenter des structures de données (objets, listes, valeurs scalaires) sans aucune balise. Là où XML répète le nom de la balise deux fois (\u0026lt;person\u0026gt;…\u0026lt;/person\u0026gt;), YAML écrit simplement person: suivi de ses propriétés indentées. On peut voir une évolution : XML (années 90-2000) → JSON (années 2010, priorité à la simplicité machine) → YAML (priorité à la lisibilité humaine tout en restant 100 % compatible avec JSON. C’est pourquoi YAML s’est imposé massivement dans les fichiers de configuration (Docker Compose, Kubernetes, GitHub Actions, Ansible, etc.) : il offre le offre un compromis. Syntaxe 1. Les trois briques de base Tout fichier YAML est construit avec seulement trois types de données : Scalaires : une valeur simple (chaîne, nombre, booléen, null, date) Séquences : des listes ordonnées (équivalent d’un tableau) Objets : des dictionnaires clé → valeur # Exemple réunissant les trois prénom: Alice # mapping (clé: valeur) âge: 32 # mapping développeuse: true # mapping hobbies: # mapping - lecture # séquence (liste) - escalade - photographie 2. L’indentation YAML utilise l’indentation avec des espaces pour indiquer la hiérarchie. Le nombre d’espaces par niveau est libre, mais doit être constant dans tout le fichier (la convention la plus courante est 2 espaces). 3. Les objets nom: Alice Dupont âge: 32 adresse: rue: 12 rue des Lilas ville: Paris pays: France 4. Écrire des séquences (listes) Deux syntaxes équivalentes : # Style bloc (le plus lisible) fruits: - pomme - banane - orange # Style « flow » (comme JSON) fruits: [pomme, banane, orange] 5. Les chaînes de caractères # Sans guillemets (la plupart du temps) nom: Alice # Avec simples ou doubles guillemets si besoin message: 'Elle a dit : \"Salut !\"' description: \"Texte sur\\nplusieurs lignes\\navec retours à la ligne\" # Bloc littéral (garde exactement le texte, retours à la ligne inclus) poeme: | Roses are red Violets are blue YAML est génial Et toi aussi ! # Bloc replié (les retours à la ligne deviennent des espaces) resume: \u0026gt; Ceci est un long texte qui sera mis sur une seule ligne lors du parsing. 6. Les booléens et null actif: true # ou True, TRUE, on, On, yes… inactif: false # ou off, no… site_web: null # ou ~ ou simplement rien → site_web: 7. Les commentaires # Ceci est un commentaire nom: Alice # commentaire en fin de ligne autorisé # Les commentaires rendent les fichiers de config très lisibles 8. Style flow (comme JSON) – à utiliser avec parcimonie personne: { nom: Alice, âge: 32, hobbies: [lecture, escalade] } 9. Ancres et alias YAML permet de définir des ancres pour réutiliser des structures de données sans duplication. Cela évite la répétition et facilite la maintenance. Ancre : Définit une référence avec \u0026nom. Alias : Réutilise la référence avec *nom. Fusion : Utilise \u0026lt;\u0026lt;: *nom pour fusionner un mapping dans un autre. # Définition d'une ancre adresse_par_defaut: \u0026amp;adresse_paris rue: 12 rue des Lilas ville: Paris pays: France # Utilisation d'un alias personne1: nom: Alice adresse: *adresse_paris # Réutilise l'adresse personne2: nom: Bob \u0026lt;\u0026lt;: *adresse_paris # Fusionne l'adresse dans l'objet rue: 5 avenue des Champs # Peut être surchargée Les ancres sont particulièrement utiles pour les configurations complexes où des objets similaires sont répétés. Exemples Considérons les exemples suivants. 1. En XML \u0026lt;person\u0026gt; \u0026lt;name\u0026gt;Alice Dupont\u0026lt;/name\u0026gt; \u0026lt;age\u0026gt;32\u0026lt;/age\u0026gt; \u0026lt;isDeveloper\u0026gt;true\u0026lt;/isDeveloper\u0026gt; \u0026lt;address\u0026gt; \u0026lt;street\u0026gt;12 rue des Lilas\u0026lt;/street\u0026gt; \u0026lt;city\u0026gt;Paris\u0026lt;/city\u0026gt; \u0026lt;country\u0026gt;France\u0026lt;/country\u0026gt; \u0026lt;/address\u0026gt; \u0026lt;hobbies\u0026gt; \u0026lt;hobby\u0026gt;lecture\u0026lt;/hobby\u0026gt; \u0026lt;hobby\u0026gt;escalade\u0026lt;/hobby\u0026gt; \u0026lt;hobby\u0026gt;photographie\u0026lt;/hobby\u0026gt; \u0026lt;/hobbies\u0026gt; \u0026lt;/person\u0026gt; 2. En JSON { \"name\": \"Alice Dupont\", \"age\": 32, \"isDeveloper\": true, \"address\": { \"street\": \"12 rue des Lilas\", \"city\": \"Paris\", \"country\": \"France\" }, \"hobbies\": [\"lecture\", \"escalade\", \"photographie\"] } 3. En YAML # Exemple de personne en YAML name: Alice Dupont age: 32 isDeveloper: true # booléen address: street: 12 rue des Lilas city: Paris country: France hobbies: - lecture # liste avec des tirets - escalade - photographie Laboratoire YAML Utilisez l'application suivante pour tester votre compréhension du YAML. YAML JSON (valide) Activité YAML avec Jackson # La librairie Jackson supporte YAML grâce au module jackson-dataformat-yaml. Exécuter le code suivant qui utilise un ObjectMapper configuré avec une YAMLFactory pour analyser une chaîne YAML et la convertir en une structure de données Java facilement navigable.\nLireYamlEnLigne.java import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.dataformat.yaml.YAMLFactory; import com.fasterxml.jackson.databind.JsonNode; import java.io.IOException; public class LireYamlEnLigne { private static final String YAML_EN_LIGNE = \u0026#34;\u0026#34;\u0026#34; personne: nom: Dupont prenom: Marie age: 31 actif: true hobbies: - lecture - randonnée - cuisine adresse: rue: 12 avenue des Lilas ville: Lyon codePostal: 69003 serveur: host: localhost port: 8080 ssl: false chemins: api: /api/v1 admin: /admin \u0026#34;\u0026#34;\u0026#34;; public static void main(String[] args) { ObjectMapper mapper = new ObjectMapper(new YAMLFactory()); try { // Lecture du YAML sous forme d\u0026#39;arbre JsonNode (facile à parcourir) JsonNode racine = mapper.readTree(YAML_EN_LIGNE); // Exemples d\u0026#39;accès aux valeurs String nom = racine.at(\u0026#34;/personne/nom\u0026#34;).asText(); int age = racine.at(\u0026#34;/personne/age\u0026#34;).asInt(); boolean actif = racine.at(\u0026#34;/personne/actif\u0026#34;).asBoolean(); System.out.println(\u0026#34;Nom : \u0026#34; \u0026#43; nom); System.out.println(\u0026#34;Âge : \u0026#34; \u0026#43; age); System.out.println(\u0026#34;Actif : \u0026#34; \u0026#43; actif); // Parcours d\u0026#39;une liste System.out.println(\u0026#34;Hobbies :\u0026#34;); JsonNode hobbies = racine.at(\u0026#34;/personne/hobbies\u0026#34;); hobbies.forEach(hobby -\u0026gt; System.out.println(\u0026#34; - \u0026#34; \u0026#43; hobby.asText())); // Accès à un objet imbriqué String ville = racine.at(\u0026#34;/personne/adresse/ville\u0026#34;).asText(); System.out.println(\u0026#34;Ville : \u0026#34; \u0026#43; ville); // Lecture complète sous forme de chaîne formatée (pour débogage) System.out.println(\u0026#34;\\nContenu complet du YAML interprété en JSON :\u0026#34;); System.out.println(mapper.writeValueAsString(racine)); } catch (IOException e) { System.err.println(\u0026#34;Erreur lors de la lecture du YAML : \u0026#34; \u0026#43; e.getMessage()); e.printStackTrace(); } } } Exécuter Le programme illustre plusieurs techniques importantes : l\u0026rsquo;utilisation de JsonNode pour accéder aux valeurs via des chemins JSON-like (avec la méthode at()), le parcours de listes YAML, et la conversion entre formats. Cette approche est particulièrement utile pour lire des fichiers de configuration YAML dans des applications Java, offrant une alternative plus lisible au JSON traditionnel tout en conservant la puissance de Jackson pour la manipulation de données.\nPour exécuter un tel programme, vous devez inclure les composantes de la librairie Jackson nécessaires. Avec Maven, les lignes suivantes peuvent suffire.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"id":93,"href":"/orientee_donnees/docs/modules/b_module_xml/programmation/jackson/","title":"Activité JSON/XML avec Jackson","section":"Modèles de programmation","content":" Activité JSON/XML avec Jackson # Jackson est l\u0026rsquo;une des bibliothèques Java les plus populaires pour le traitement des formats de données JSON et XML. Développée par FasterXML, elle offre des performances élevées et une API simple pour convertir entre les objets Java et ces formats de données structurés. Cette bibliothèque est particulièrement appréciée dans l\u0026rsquo;écosystème Java pour sa facilité d\u0026rsquo;utilisation et sa flexibilité, permettant aux développeurs de sérialiser et désérialiser des données de manière transparente.\nDans cette activité, nous explorerons les fonctionnalités essentielles de Jackson à travers des exemples pratiques. Vous apprendrez à manipuler des objets simples, des collections, des structures imbriquées, et à personnaliser le comportement de sérialisation/désérialisation. Chaque exemple est conçu pour illustrer un concept spécifique, en commençant par les bases et en progressant vers des cas d\u0026rsquo;usage plus avancés.\nLes exemples de code présentés ci-dessous démontrent comment Jackson peut être utilisé pour traiter à la fois du JSON et du XML. Vous verrez comment créer des objets Java, les convertir en chaînes de caractères dans ces formats, puis les reconstruire. Cette approche est particulièrement utile pour l\u0026rsquo;échange de données avec des APIs web, la persistance de configurations, ou l\u0026rsquo;intégration avec des systèmes externes.\nUtilisation de Jackson # Jackson est une bibliothèque Java pour la manipulation du XML et du JSON, développée par FasterXML.\nSérialisation et désérialisation de base # La sérialisation consiste à convertir un objet Java en une représentation textuelle, comme du JSON. Jackson utilise la méthode writeValueAsString() de l\u0026rsquo;ObjectMapper pour effectuer cette conversion. Inversement, la désérialisation transforme une chaîne JSON en objet Java via readValue().\nJackson suit les conventions JavaBeans : il accède aux propriétés via les getters et setters. Les champs sans getter public sont ignorés lors de la sérialisation, et les valeurs null sont omises par défaut pour produire un JSON plus compact. Pour la désérialisation, un constructeur sans argument est nécessaire pour instancier l\u0026rsquo;objet avant de définir ses propriétés.\nDans cet exemple, nous créons une classe Personne avec deux propriétés simples. Le programme sérialise une instance en JSON, affiche le résultat, puis désérialise la chaîne pour recréer l\u0026rsquo;objet original. Notez que Jackson produit un JSON compact sans espaces inutiles.\nVoici un exemple complet :\nExempleBasique.java import com.fasterxml.jackson.databind.ObjectMapper; class Personne { private String nom; private int age; public Personne() {} // Nécessaire pour la désérialisation public Personne(String nom, int age) { this.nom = nom; this.age = age; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } public class ExempleBasique { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Personne personne = new Personne(\u0026#34;Alice\u0026#34;, 30); // Sérialisation String json = mapper.writeValueAsString(personne); System.out.println(\u0026#34;JSON sérialisé :\u0026#34;); System.out.println(json); // Désérialisation Personne deserialisee = mapper.readValue(json, Personne.class); System.out.println(\u0026#34;\\nObjet désérialisé : nom=\u0026#34; \u0026#43; deserialisee.getNom() \u0026#43; \u0026#34;, age=\u0026#34; \u0026#43; deserialisee.getAge()); } } Exécuter Ce code affiche un JSON compact et reconstruit l\u0026rsquo;objet. La version XML est similaire, mais utilise XmlMapper au lieu d\u0026rsquo;ObjectMapper. XmlMapper produit une sortie XML bien formée avec des balises au lieu d\u0026rsquo;accolades JSON.\nL\u0026rsquo;exemple XML suivant démontre la même fonctionnalité, mais avec une sérialisation en XML. Notez que la structure de la classe Java reste identique - seule la classe de mapper change. Le XML produit inclut une déclaration XML et utilise le nom de la classe comme élément racine.\nExempleXmlBasique.java import com.fasterxml.jackson.dataformat.xml.XmlMapper; class Personne { private String nom; private int age; public Personne() {} // Nécessaire pour la désérialisation public Personne(String nom, int age) { this.nom = nom; this.age = age; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } public class ExempleXmlBasique { public static void main(String[] args) throws Exception { XmlMapper mapper = new XmlMapper(); Personne personne = new Personne(\u0026#34;Alice\u0026#34;, 30); // Sérialisation en XML String xml = mapper.writeValueAsString(personne); System.out.println(\u0026#34;XML sérialisé :\u0026#34;); System.out.println(xml); // Désérialisation depuis XML Personne deserialisee = mapper.readValue(xml, Personne.class); System.out.println(\u0026#34;\\nObjet désérialisé : nom=\u0026#34; \u0026#43; deserialisee.getNom() \u0026#43; \u0026#34;, age=\u0026#34; \u0026#43; deserialisee.getAge()); } } Exécuter Mise en forme jolie et inclusion des null # Par défaut, Jackson produit un JSON compact sans espaces. Pour améliorer la lisibilité, particulièrement lors du développement ou du débogage, vous pouvez activer l\u0026rsquo;indentation en utilisant SerializationFeature.INDENT_OUTPUT. Cela ajoute des espaces et des sauts de ligne pour structurer le JSON de manière hiérarchique.\nDe plus, Jackson omet les valeurs null par défaut pour éviter de gonfler inutilement le JSON. Cependant, dans certains cas (comme les APIs qui attendent tous les champs), vous voudrez inclure explicitement les valeurs null. L\u0026rsquo;annotation @JsonInclude(JsonInclude.Include.ALWAYS) au niveau de la classe force l\u0026rsquo;inclusion de tous les champs, même s\u0026rsquo;ils sont null.\nDans cet exemple, la classe Livre utilise cette annotation et contient un champ pages qui peut être null. L\u0026rsquo;ObjectMapper est configuré avec l\u0026rsquo;indentation activée, produisant un JSON formaté et complet.\nExempleMiseEnForme.java import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import com.fasterxml.jackson.annotation.JsonInclude; @JsonInclude(JsonInclude.Include.ALWAYS) class Livre { private String titre; private String auteur; private Integer pages; // Peut être null public Livre() {} public Livre(String titre, String auteur, Integer pages) { this.titre = titre; this.auteur = auteur; this.pages = pages; } public String getTitre() { return titre; } public void setTitre(String titre) { this.titre = titre; } public String getAuteur() { return auteur; } public void setAuteur(String auteur) { this.auteur = auteur; } public Integer getPages() { return pages; } public void setPages(Integer pages) { this.pages = pages; } } public class ExempleMiseEnForme { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper() .enable(SerializationFeature.INDENT_OUTPUT); Livre livre = new Livre(\u0026#34;Programmation Java\u0026#34;, \u0026#34;John Doe\u0026#34;, null); String json = mapper.writeValueAsString(livre); System.out.println(\u0026#34;JSON mis en forme avec nulls :\u0026#34;); System.out.println(json); } } Exécuter Cela produit un JSON indenté incluant les champs null grâce à l\u0026rsquo;annotation. Observez comment le champ \u0026ldquo;pages\u0026rdquo; apparaît avec la valeur null, et comment la structure est présentée avec une indentation claire facilitant la lecture.\nGestion des collections # Jackson offre un support natif pour toutes les collections Java standard (List, Set, Map, etc.), ce qui facilite grandement le travail avec des structures de données complexes. Lors de la sérialisation, une List devient un tableau JSON, et lors de la désérialisation, Jackson peut reconstruire la collection appropriée.\nCette fonctionnalité est particulièrement utile pour traiter des données provenant d\u0026rsquo;APIs REST qui retournent des listes d\u0026rsquo;objets. Jackson préserve l\u0026rsquo;ordre des éléments dans les listes et gère correctement les types génériques grâce à l\u0026rsquo;utilisation de List.class ou de types plus spécifiques si nécessaire.\nL\u0026rsquo;exemple suivant démontre la sérialisation d\u0026rsquo;une ArrayList de chaînes en tableau JSON, puis sa désérialisation pour recréer la liste originale.\nExempleCollections.java import com.fasterxml.jackson.databind.ObjectMapper; import java.util.ArrayList; import java.util.List; public class ExempleCollections { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); List\u0026lt;String\u0026gt; fruits = new ArrayList\u0026lt;\u0026gt;(); fruits.add(\u0026#34;Pomme\u0026#34;); fruits.add(\u0026#34;Banane\u0026#34;); fruits.add(\u0026#34;Orange\u0026#34;); // Sérialisation String json = mapper.writeValueAsString(fruits); System.out.println(\u0026#34;Liste sérialisée :\u0026#34;); System.out.println(json); // Désérialisation List\u0026lt;String\u0026gt; deserialisee = mapper.readValue(json, List.class); System.out.println(\u0026#34;\\nListe désérialisée :\u0026#34;); System.out.println(deserialisee); } } Exécuter Objets imbriqués # Jackson traite les hiérarchies d\u0026rsquo;objets de manière transparente et récursive, permettant de sérialiser des graphes d\u0026rsquo;objets complexes. Chaque objet imbriqué est converti en objet JSON imbriqué, préservant ainsi la structure relationnelle des données.\nCette capacité est essentielle pour modéliser des entités métier réalistes qui contiennent des références à d\u0026rsquo;autres objets. Jackson gère automatiquement la navigation dans ces hiérarchies, tant pour la sérialisation que pour la désérialisation, à condition que toutes les classes implémentent correctement le pattern JavaBeans.\nDans cet exemple, nous définissons deux classes : Adresse (imbriquée) et Employe (contenant une adresse). Le JSON produit reflète fidèlement cette structure hiérarchique.\nExempleObjetsImbriques.java import com.fasterxml.jackson.databind.ObjectMapper; class Adresse { private String ville; private String pays; public Adresse() {} public Adresse(String ville, String pays) { this.ville = ville; this.pays = pays; } public String getVille() { return ville; } public void setVille(String ville) { this.ville = ville; } public String getPays() { return pays; } public void setPays(String pays) { this.pays = pays; } } class Employe { private String nom; private Adresse adresse; public Employe() {} public Employe(String nom, Adresse adresse) { this.nom = nom; this.adresse = adresse; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } public Adresse getAdresse() { return adresse; } public void setAdresse(Adresse adresse) { this.adresse = adresse; } } public class ExempleObjetsImbriques { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Adresse adresse = new Adresse(\u0026#34;New York\u0026#34;, \u0026#34;USA\u0026#34;); Employe employe = new Employe(\u0026#34;Bob\u0026#34;, adresse); String json = mapper.writeValueAsString(employe); System.out.println(\u0026#34;Objet imbriqué sérialisé :\u0026#34;); System.out.println(json); Employe deserialise = mapper.readValue(json, Employe.class); System.out.println(\u0026#34;\\nDésérialisé : nom=\u0026#34; \u0026#43; deserialise.getNom() \u0026#43; \u0026#34;, ville=\u0026#34; \u0026#43; deserialise.getAdresse().getVille()); } } Exécuter Noms de champs personnalisés avec @JsonProperty # Par défaut, Jackson utilise les noms des propriétés Java (déduits des getters/setters) comme clés JSON. Cependant, les conventions de nommage diffèrent souvent entre Java (camelCase) et JSON (snake_case ou kebab-case). L\u0026rsquo;annotation @JsonProperty permet de spécifier explicitement le nom de la clé JSON pour chaque propriété.\nCette annotation est particulièrement utile lors de l\u0026rsquo;intégration avec des APIs externes qui imposent des conventions de nommage spécifiques, ou pour maintenir la compatibilité avec des formats de données existants. Elle peut être appliquée sur les champs, getters ou setters, offrant une grande flexibilité.\nL\u0026rsquo;exemple suivant montre comment mapper des propriétés Java vers des clés JSON avec des noms personnalisés, transformant \u0026ldquo;id\u0026rdquo; en \u0026ldquo;product_id\u0026rdquo; et \u0026ldquo;nom\u0026rdquo; en \u0026ldquo;product_name\u0026rdquo;.\nExempleJsonProperty.java import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.ObjectMapper; class Produit { @JsonProperty(\u0026#34;product_id\u0026#34;) private int id; @JsonProperty(\u0026#34;product_name\u0026#34;) private String nom; public Produit() {} public Produit(int id, String nom) { this.id = id; this.nom = nom; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNom() { return nom; } public void setNom(String nom) { this.nom = nom; } } public class ExempleJsonProperty { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Produit produit = new Produit(101, \u0026#34;Ordinateur portable\u0026#34;); String json = mapper.writeValueAsString(produit); System.out.println(\u0026#34;JSON avec noms personnalisés :\u0026#34;); System.out.println(json); } } Exécuter Ignorer des champs avec @JsonIgnore # Certaines propriétés d\u0026rsquo;un objet Java ne devraient pas être incluses dans la sérialisation JSON, soit pour des raisons de sécurité (mots de passe), soit pour des considérations de performance (données temporaires), soit simplement parce qu\u0026rsquo;elles sont internes à l\u0026rsquo;application. L\u0026rsquo;annotation @JsonIgnore permet d\u0026rsquo;exclure complètement un champ de la sérialisation et désérialisation.\nCette annotation est particulièrement importante pour éviter de exposer des données sensibles dans les réponses JSON des APIs. Elle peut être appliquée sur les champs, getters ou setters, et Jackson l\u0026rsquo;ignorera complètement lors des opérations de conversion.\nDans cet exemple, le champ motDePasse est marqué avec @JsonIgnore, donc il n\u0026rsquo;apparaîtra pas dans le JSON produit, protégeant ainsi les informations sensibles.\nExempleJsonIgnore.java import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.databind.ObjectMapper; class Utilisateur { private String nomUtilisateur; @JsonIgnore private String motDePasse; public Utilisateur() {} public Utilisateur(String nomUtilisateur, String motDePasse) { this.nomUtilisateur = nomUtilisateur; this.motDePasse = motDePasse; } public String getNomUtilisateur() { return nomUtilisateur; } public void setNomUtilisateur(String nomUtilisateur) { this.nomUtilisateur = nomUtilisateur; } public String getMotDePasse() { return motDePasse; } public void setMotDePasse(String motDePasse) { this.motDePasse = motDePasse; } } public class ExempleJsonIgnore { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Utilisateur utilisateur = new Utilisateur(\u0026#34;charlie\u0026#34;, \u0026#34;caché\u0026#34;); String json = mapper.writeValueAsString(utilisateur); System.out.println(\u0026#34;JSON sans le champ ignoré :\u0026#34;); System.out.println(json); } } Exécuter XML et JSON # Jackson offre une API unifiée pour traiter à la fois JSON et XML, permettant aux développeurs d\u0026rsquo;écrire du code largement indépendant du format de données. L\u0026rsquo;exemple suivant démontre cette dualité en utilisant le même objet Person pour produire des représentations JSON et XML équivalentes.\nCette approche est particulièrement puissante pour les applications qui doivent supporter plusieurs formats de données (par exemple, une API qui peut retourner JSON ou XML selon l\u0026rsquo;en-tête Accept de la requête HTTP). Le code métier reste identique, seule la classe de mapper change.\nObservez comment le même objet produit des sorties dans les deux formats : JSON avec des accolades et XML avec des balises, mais contenant les mêmes informations structurées.\nApp.java package fr.example.jackson; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.dataformat.xml.XmlMapper; class Person { private String name; private int age; public Person() {} public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; \u0026#43; name \u0026#43; \u0026#34;\u0026#39;, age=\u0026#34; \u0026#43; age \u0026#43; \u0026#34;}\u0026#34;; } } public class App { public static void main(String[] args) throws Exception { Person person = new Person(\u0026#34;Jean Dupont\u0026#34;, 30); // Sérialisation JSON ObjectMapper jsonMapper = new ObjectMapper(); String json = jsonMapper.writeValueAsString(person); System.out.println(\u0026#34;JSON: \u0026#34; \u0026#43; json); // Désérialisation JSON Person fromJson = jsonMapper.readValue(json, Person.class); System.out.println(\u0026#34;Depuis JSON: \u0026#34; \u0026#43; fromJson); // Sérialisation XML XmlMapper xmlMapper = new XmlMapper(); String xml = xmlMapper.writeValueAsString(person); System.out.println(\u0026#34;XML: \u0026#34; \u0026#43; xml); // Désérialisation XML Person fromXml = xmlMapper.readValue(xml, Person.class); System.out.println(\u0026#34;Depuis XML: \u0026#34; \u0026#43; fromXml); } } Exécuter Activité Maven # Nous vous invitons maintenant à faire une activité practique avec la librairie Java Jackson. L'activité vous amènera sur la plateforme GitHub et vous devrez utiliser Maven. "},{"id":94,"href":"/orientee_donnees/docs/modules/b_module_xml/base/autoevaluation/","title":"Autoévaluation XML","section":"Les fondements","content":" Autoévaluation XML # Le bouton Vérifier mes réponses vous indique immédiatement si vos choix sont corrects et vous donne une courte explication.\nCommentaires en vert = bonne réponse\nCommentaires contenant du rouge = erreur, lisez l’explication.\nVous pouvez recommencer à tout moment avec le bouton Recommencer le quiz.\nQuestion 2 – Quelles sont les balises du document suivant ? \u0026lt;pageweb\u0026gt; \u0026lt;lien\u0026gt;http://www.google.com [Lien externe…]\u0026lt;/lien\u0026gt; \u0026lt;description\u0026gt;Un moteur de recherche\u0026lt;/description\u0026gt; \u0026lt;/pageweb\u0026gt; http://www.google.com[…], Un moteur de recherche. \u0026lt;pageweb\u0026gt;, \u0026lt;lien\u0026gt;, \u0026lt;/lien\u0026gt;, \u0026lt;description\u0026gt;, \u0026lt;/description\u0026gt;, \u0026lt;/pageweb\u0026gt; \u0026lt;lien\u0026gt;http://www.google.com[…] \u0026lt;/lien\u0026gt;, \u0026lt;description\u0026gt;…\u0026lt;/description\u0026gt; Question 6 – Hiérarchie (casse exacte) du document \u0026lt;classe\u0026gt;\u0026lt;etudiant\u0026gt;\u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt;\u0026lt;nom\u0026gt;Laroche\u0026lt;/nom\u0026gt;\u0026lt;/etudiant\u0026gt;\u0026lt;etudiant\u0026gt;\u0026lt;prenom\u0026gt;Gaetan\u0026lt;/prenom\u0026gt;\u0026lt;nom\u0026gt;Roche\u0026lt;/nom\u0026gt;\u0026lt;/etudiant\u0026gt;\u0026lt;/classe\u0026gt; classe → Etudiant → … (majuscule) classe → etudiant → prenom → Jean … (tout en minuscules sauf les données) classe → prenom → etudiant → … Question 7 – Quels sont les noms des attributs ? \u0026lt;pageweb categorie=\"recherche\"\u0026gt; \u0026lt;description type=\"court texte\"\u0026gt;…\u0026lt;/description\u0026gt; \u0026lt;/pageweb\u0026gt; categorie, type \"recherche\", \"court texte\" pageweb, lien, description Question 8 – Quelles sont les balises (ouvertes + fermantes) ? \u0026lt;pageweb categorie=\"recherche\"\u0026gt; \u0026lt;description type=\"court texte\"\u0026gt;…\u0026lt;/description\u0026gt; \u0026lt;/pageweb\u0026gt; categorie, type \"recherche\", \"court texte\" pageweb, description \u0026lt;pageweb categorie=…\u0026gt;, \u0026lt;description\u0026gt;, … Question 9 – Quels sont les noms des éléments ? \u0026lt;pageweb categorie=\"recherche\"\u0026gt; \u0026lt;description type=\"court texte\"\u0026gt;…\u0026lt;/description\u0026gt; \u0026lt;/pageweb\u0026gt; categorie, type \"recherche\", \"court texte\" pageweb, description Question 11 – Pourquoi a-t-on besoin d’entités en XML ? Parce qu’on ne pourrait pas utiliser le symbole \u0026lt; dans le contenu textuel (il marque le début d’une balise). Parce qu’on ne pourrait pas utiliser uniquement le symbole \u0026gt;. Parce que les cinq caractères \u0026lt;, \u0026gt;, ', \", \u0026amp; sont tous strictement interdits. Question 16 – Quelle est la forme correcte de la déclaration XML ? \u0026lt;xml version=\"1.0\" /\u0026gt; \u0026lt;?xml version=\"1.0\" /\u0026gt; \u0026lt;?xml version=\"1.0\"?\u0026gt; Question 17 – Ce document est-il bien formé ? \u0026lt;?xml version=\"1.0\"?\u0026gt; \u0026lt;ami age=19 \u0026gt; \u0026lt;/ami\u0026gt; Vrai Faux Question 18 – Un élément ne peut-il pas être vide en XML ? Vrai Faux Question 19 – Lequel de ces noms n’est PAS permis pour un élément ? x1 1x Nx Question 20 – Lequel de ces noms EST permis pour un élément ? xmlcourse 7eleven Joe Louis Aucune de ces réponses Question 21 – Le XML préserve-t-il les espaces (blancs) entre les éléments ? Vrai Faux Question 22 – Combien de nœuds de texte contient ce document ? \u0026lt;?xml encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;?xml version=\"1.0\"?\u0026gt; \u0026lt;étudiant\u0026gt; \u0026lt;nom\u0026gt;Daniel Jacques\u0026lt;/nom\u0026gt; \u0026lt;cours\u0026gt;bibliothéconomie\u0026lt;/cours\u0026gt; \u0026lt;/étudiant\u0026gt; 2 5 Question 23 – Peut-il y avoir des nœuds de texte avant l’élément-racine ? Vrai Faux Question 24 – Peut-il y avoir des nœuds de texte après l’élément-racine ? Vrai Faux Question 25 – Un document avec 12 balises a forcément 6 éléments ? Vrai Faux Question 26 – Un document avec 12 balises peut-il avoir 12 nœuds de texte ? Vrai Faux Vérifier mes réponses Recommencer le quiz "},{"id":95,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/les_tests/","title":"Les tests","section":"XSLT","content":" Les tests # Utilisation des tests # Dans cette section, nous apprenons à utiliser les tests conditionnels en XSLT avec les éléments xsl:if et xsl:choose, permettant de contrôler le flux de transformation basé sur des conditions XPath.\nNous pouvons tester des conditions à l\u0026rsquo;aide d\u0026rsquo;expressions XPath contenant les symboles « \u0026lt; », « = », « != », « or », « and », « \u0026gt; », « \u0026gt;= », « \u0026lt;= ». Nous utilisons les tests en XSLT avec les éléments « xsl:choose » et « xsl:if ». Par exemple, faire quelque chose de particulier, si le nom de l\u0026rsquo;élément courant est « montant ».\n\u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:if test=\u0026#34;name(.) = \u0026#39;montant\u0026#39;\u0026#34;\u0026gt; Il s\u0026#39;agit d\u0026#39;un élément nommé «montant». \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:template\u0026gt; La syntaxe de l\u0026rsquo;élément « xsl:if » est très simple; si la valeur de l\u0026rsquo;expression XPath contenue dans l\u0026rsquo;attribut « test » est vraie, le contenu de l\u0026rsquo;élément « xsl:if » s\u0026rsquo;applique, sinon, on l\u0026rsquo;omet. Notez qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;élément « xsl:else »\nNous pouvons aussi traiter plusieurs tests dans un seul élément « xsl:choose » comme ceci :\n\u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;name(.)=\u0026#39;montant\u0026#39;\u0026#34;\u0026gt; Il y a une balise \u0026#34;montant\u0026#34; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:when test=\u0026#34;name(.)=\u0026#39;facture\u0026#39;\u0026#34;\u0026gt; J\u0026#39;ai trouvé une \u0026#34;facture\u0026#34; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; Je ne connais pas cet élément \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; On peut aussi combiner plusieurs tests avec les opérateurs logiques and, or et not comme le montre le prochain exemple.\n\u0026lt;xsl:template match=\u0026#34;*\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;name(.)=\u0026#39;montant\u0026#39; or name(.)=\u0026#39;facture\u0026#39;\u0026#34;\u0026gt; Il y a une balise \u0026#34;montant\u0026#34; ou une balise \u0026#34;facture\u0026#34; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:when test=\u0026#34;not(name(.)=\u0026#39;argent\u0026#39;)\u0026#34;\u0026gt; Ce n\u0026#39;est ni montant, ni facture, ni argent. \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt; Je ne connais pas cet élément. \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; On peut aussi tester la langue d\u0026rsquo;un élément avec la fonction XPath « lang ». L\u0026rsquo;expression « count(//p[lang(\u0026rsquo;en\u0026rsquo;)]) » compte le nombre d\u0026rsquo;élément « p » ayant été déclaré comme contenant du texte en langue anglaise.\nObservez qu\u0026rsquo;un élément « xsl:choose » contient plusieurs éléments « xsl:when » qui sont testés tour à tour, jusqu\u0026rsquo;à ce qu\u0026rsquo;une condition soit vraie; l\u0026rsquo;élément « xsl:otherwise » est présent pour l\u0026rsquo;éventualité où tous les tests échouent. Tous les tests sont réalisés en séquence et dès qu\u0026rsquo;une condition est vraie, les tests s\u0026rsquo;arrêtent et le contenu de l\u0026rsquo;élément « xsl:when » est évalué.\nEn XSLT, il ne faut pas abuser des tests; il est préférable d\u0026rsquo;utiliser des éléments « xsl:template » qui sont plus modulaires.\n"},{"id":96,"href":"/orientee_donnees/docs/modules/b_module_xml/examples/docx_microsoft_word/","title":"Office Open XML","section":"Exemples","content":" Open XML # Open XML est un format de fichier ouvert pour les documents bureautiques, développé par Microsoft et standardisé par l\u0026rsquo;ECMA et l\u0026rsquo;ISO. Il permet de créer des documents Word, Excel et PowerPoint qui sont compatibles avec les applications Microsoft Office.\nOrganisation des documents Open XML # Les documents Open XML sont structurés comme des archives ZIP compressées contenant des fichiers XML et des ressources. Cette structure permet une manipulation programmatique aisée des documents.\nStructure générale # [Content_Types].xml : Définit les types MIME des parties du document. _rels/ : Dossier des relations entre les parties du document. docProps/ : Propriétés du document (métadonnées comme auteur, titre, date de création). Documents Word (.docx) # Les fichiers .docx ont la structure suivante :\nword/ document.xml : Contenu principal du document (texte, paragraphes, etc.). styles.xml : Définitions des styles utilisés dans le document. settings.xml : Paramètres du document (marges, orientation, etc.). _rels/ : Relations spécifiques à la partie word. media/ : Images et autres médias intégrés (optionnel). Documents Excel (.xlsx) # Les fichiers .xlsx sont organisés ainsi :\nxl/ workbook.xml : Structure générale du classeur (feuilles, propriétés). worksheets/ : Dossier contenant les feuilles de calcul individuelles (sheet1.xml, sheet2.xml, etc.). styles.xml : Styles pour les cellules, polices, etc. sharedStrings.xml : Chaînes de caractères partagées pour optimiser l\u0026rsquo;espace. _rels/ : Relations spécifiques à la partie xl. media/ : Images et graphiques (optionnel). Cette organisation modulaire facilite la lecture et l\u0026rsquo;écriture des documents par des bibliothèques comme Apache POI ou Docx4j.\nApache POI # Apache POI est une bibliothèque Java open-source qui permet de lire et d\u0026rsquo;écrire des fichiers Microsoft Office, tels que les documents Word (.docx), les feuilles de calcul Excel (.xlsx) et les présentations PowerPoint (.pptx). Elle est particulièrement utile pour manipuler des fichiers Office de manière programmatique.\nCréation d\u0026rsquo;un document Microsoft Word (docx) # Voici un exemple de code Java utilisant la bibliothèque Docx4j pour créer un document Word avec un titre, un paragraphe formaté et une liste :\n// Code from Docx4jGenerator.java public static void main(String[] args) { String filename = \u0026#34;mon_document_docx.docx\u0026#34;; try { // 1. Créer le package Word WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.createPackage(); MainDocumentPart documentPart = wordMLPackage.getMainDocumentPart(); // 2. Ajouter un titre de niveau 1 documentPart.getContent().add(createHeading( \u0026#34;Mon document .docx généré élégamment avec Docx4j\u0026#34;, \u0026#34;Heading1\u0026#34; )); // 3. Ajouter un paragraphe formaté documentPart.getContent().add(createStyledParagraph()); // 4. Ajouter une liste numérotée simple documentPart.getContent().add(createNumberedItem(\u0026#34;Premier élément\u0026#34;, 1)); documentPart.getContent().add(createNumberedItem(\u0026#34;Deuxième élément\u0026#34;, 1)); // 5. Sauvegarder le fichier wordMLPackage.save(new File(filename)); System.out.println(\u0026#34;✅ Document Docx4j créé avec succès : \u0026#34; + filename); } catch (Docx4JException e) { System.err.println(\u0026#34;❌ Erreur lors de la création du document Docx4j : \u0026#34; + e.getMessage()); e.printStackTrace(); } } Nous vous invitons maintenant à faire notre activité de création de documents Word.\nCréation d\u0026rsquo;un document Microsoft Excel (xlsx) # Voici un exemple de code Java utilisant la bibliothèque Apache POI pour créer un classeur Excel avec un titre et des données :\n// Code from ExcelGenerator.java public static void main(String[] args) { String nomFichier = \u0026#34;mon_classeur_excel.xlsx\u0026#34;; try { // 1. Créer le classeur Excel Workbook classeur = new XSSFWorkbook(); Sheet feuille = classeur.createSheet(\u0026#34;Feuille1\u0026#34;); // 2. Ajouter un titre Row ligneTitre = feuille.createRow(0); Cell celluleTitre = ligneTitre.createCell(0); celluleTitre.setCellValue(\u0026#34;Mon classeur Excel généré avec Apache POI\u0026#34;); // Style pour le titre CellStyle styleTitre = classeur.createCellStyle(); Font policeTitre = classeur.createFont(); policeTitre.setBold(true); policeTitre.setFontHeightInPoints((short) 14); styleTitre.setFont(policeTitre); celluleTitre.setCellStyle(styleTitre); // 3. Ajouter des données d\u0026#39;exemple String[][] donnees = { {\u0026#34;Nom\u0026#34;, \u0026#34;Âge\u0026#34;, \u0026#34;Ville\u0026#34;}, {\u0026#34;Alice\u0026#34;, \u0026#34;25\u0026#34;, \u0026#34;Paris\u0026#34;}, {\u0026#34;Bob\u0026#34;, \u0026#34;30\u0026#34;, \u0026#34;Lyon\u0026#34;}, {\u0026#34;Charlie\u0026#34;, \u0026#34;35\u0026#34;, \u0026#34;Marseille\u0026#34;} }; for (int i = 0; i \u0026lt; donnees.length; i++) { Row ligne = feuille.createRow(i + 1); for (int j = 0; j \u0026lt; donnees[i].length; j++) { Cell cellule = ligne.createCell(j); cellule.setCellValue(donnees[i][j]); } } // 4. Sauvegarder le fichier try (FileOutputStream fos = new FileOutputStream(nomFichier)) { classeur.write(fos); } System.out.println(\u0026#34;✅ Classeur Excel créé avec succès : \u0026#34; + nomFichier); } catch (IOException e) { System.err.println(\u0026#34;❌ Erreur lors de la création du classeur Excel : \u0026#34; + e.getMessage()); e.printStackTrace(); } } Nous vous invitons maintenant à faire notre activité de création de documents Excel.\n"},{"id":97,"href":"/orientee_donnees/legacy/semaine_1/petit_guide_dusage_du_courriel_efficace/","title":"Petit guide d’usage du courriel efficace","section":"Legacies","content":" Petit guide d’usage du courriel efficace Lors de l’écriture d’un courriel, être bref est important. Omettez les formules de salutation, les signatures surfaites, etc. Attention aux émotions : Il est facile quand on reçoit ou transmet un courriel de s’emporter ou de lire dans les messages reçus des sentiments. Dans un contexte professionnel, évitez d’écrire un courriel alors que vous êtes énervé. Choisissez les destinataires de votre courriel avec soin. Il est pratiquement toujours mal avisé de transmettre un courriel à un grand groupe, à moins que le courriel soit une communication formelle. Dans le doute, écrivez un courriel à un seul destinataire. Avant de répondre à un courriel, prenez le temps de bien le lire. Si on vous demande de fournir des informations ou détails additionnels, prenez le temps de le faire, ou expliquez clairement pourquoi cela n’est pas possible ou souhaitable. L’objet d’un courriel doit en refléter le contenu. Il faut éviter les objets génériques (par ex., « une question »). Il faut éviter à tout prix les objets qui ne réflètent pas le contenu (par ex. intitulé un courriel « travail 2 » alors que celui-ci porte en fait sur l’examen. Si vous utilisez un objet de courriel vague ou absent, il faut vous attendre à ce que votre courriel puisse ne pas être traité correctement. Si vous avez plusieurs sujets distincts, il est souvent préférable d’écrire plusieurs courriels distincts, chacun ayant un objet distinct. Dans un contexte professionnel, il est nettement préférable d’envoyer un courriel identifié à votre nom. Il n’est pas pratique d’envoyer des courriels vous identifiant sous le nom de votre conjoint, par exemple. Il peut être amusant de se donner des pseudonymes (« la chouette », « le montréalais ») entre amis, mais ce n’est pas souhaitable dans un contexte professionnel. Un courriel destiné à un humain doit obligatoirement avoir un corps de texte. Un courriel doit être clair et fournir tous les détails nécessaires. Par exemple, si vous écrivez à quelqu’un pour lui faire part d’un problème ou d’une incompréhension, il faut fournir tous les détails, incluant les démarches que vous avez déjà entreprises. On peut être précis sans nécessairement utiliser beaucoup de mots. Préparer un courriel précis peut exiger plus d’effort et de temps, mais c’est un signe de respect envers le récipiendaire. Si vous écrivez un courriel pour faire rapport de problèmes techniques, soyez aussi précis que possible. Joignez des saisies d’écran au besoin. Lorsque possible, on évite les pièces jointes. Lorsque celles-ci sont nécessaires, on s’assure que le récipiendaire pourra aisément en prendre connaissance. ll faut donc éviter les formats de fichier qui ne correspondent pas à un usage courant. Les formats propriétaires qui ne sont pas courants et qui nécessitent l’installation de logiciel particulier sont à éviter. Les fichiers de bureautique (par ex., Word, PDF) sont déjà compressés. Transmettre les fichiers en question dans une archive compressée ajoute des manipulations inutiles. À moins de transmettre des fichiers très volumineux, la compression des fichiers attachés est inutile étant donné la généreuse bande passante dont nous bénéficions. Si on doit utiliser un format d’archive compressé, il faut utiliser un format qui est largement supporté par les divers systèmes d’exploitation (comme le format zip basique). Certains logiciels de courriel (Outlook) ne permettent pas la transmission de fichiers avec certaines extensions. Dans de tels cas, il est acceptable de renommer l’extension du fichier et d’inclure dans le corps du message une explication. Par exemple, tous les fichiers au format texte (.xml, .html), peuvent être transmis avec l’extension « .txt ». Les courriels automatisés non sollicités sont du pourriel. Ainsi, il ne faut pas transmettre des réponses automatisées (par ex., des accusés de réception) à des destinateurs non avisés. Les protocoles Internet utilisés pour transmettre nos courriels nous assurent déjà de la bonne réception des courriels avec une grande probabilité et un courriel automatisé de réponse ne nous assure pas que le récipiendaire a effectivement pris en compte le courriel. Il est légitime de relancer un destinataire après un délai raisonable pour s’assurer que notre envoi a été bien reçu et traité. Par contre, il est normalement considéré impoli et abusif d’exiger des accusés de réception. Le courriel n’est pas toujours le meilleur outil pour obtenir de l’information. Il est souvent souhaitable de faire au préalable vos propres recherches. Dans tous les cas, montrez au destinataire que vous avez fait un effort avant d’écrire votre courriel. Le courriel n’est pas, en général, un moyen d’échange préservant la confidentialité. Ne transmettez pas vos mots de passe ou toute autre information confidentielle par courriel. "},{"id":98,"href":"/orientee_donnees/legacy/semaine_12/simdjson/","title":"Méthode On-Demand avec simdjson (C++)","section":"Semaine 12","content":" Traitement on-demand du JSON en C++ avec simdjson (activité optionnelle) # simdjson est la bibliothèque JSON la plus rapide au monde (2025). Elle est conçue dès le départ pour le parsing on-demand (aussi appelé zero-copy ou lazy parsing) : elle ne construit les objets C++ que pour les parties du JSON que vous consultez réellement. Si vous maîtriser le C++, il s\u0026rsquo;agit d\u0026rsquo;une librairie à connaître.\nSite officiel : https://github.com/simdjson/simdjson\nPrincipes du parsing on-demand # Au lieu de matérialiser le document comme avec DOM, un index est construit rapidement qui permet de naviguer avec aisance vers les parties importantes du document JSON. L\u0026rsquo;index est porté pour une instance du type parser (simdjson::ondemand::parser). Une vue paresseuse sur le document est obtenue avec ondemand::document. Seuls les éléments nécessaires sont analysés, lors de l\u0026rsquo;appel .get_string(), .get_uint64(), etc.\nExemples complets # 1. Parcourir un tableau géant sans jamais tout charger en mémoire # #include \u0026lt;iostream\u0026gt; #include \u0026lt;simdjson.h\u0026gt; int main() { simdjson::ondemand::parser parser; // Fichier de 3 Go contenant [ {obj1}, {obj2}, ... ] auto json = simdjson::padded_string::load(\u0026#34;huge_array.json\u0026#34;); simdjson::ondemand::document doc = parser.iterate(json); simdjson::ondemand::array items = doc.get_array(); // ne coûte presque rien uint64_t count = 0; for (auto item : items) { // itération on-demand uint64_t id = item[\u0026#34;id\u0026#34;]; // conversion uniquement ici std::string_view name = item[\u0026#34;name\u0026#34;].get_string(); std::cout \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; if (++count % 1\u0026#39;000\u0026#39;000 == 0) std::cout \u0026lt;\u0026lt; \u0026#34;Traités : \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; objets\\n\u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;Total : \u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34; objets\\n\u0026#34;; } 2. Accès à des chemins imbriqués profonds sans tout matérialiser # for (auto user : doc[\u0026#34;results\u0026#34;][\u0026#34;users\u0026#34;]) { std::string_view email = user[\u0026#34;profile\u0026#34;][\u0026#34;contact\u0026#34;][\u0026#34;email\u0026#34;]; double score = user[\u0026#34;metrics\u0026#34;][\u0026#34;engagement_score\u0026#34;]; process_user(email, score); } Chaque accès (user[\u0026quot;profile\u0026quot;], etc.) ne déclenche le parsing que de cette branche.\nRéférences # John Keiser, Daniel Lemire, On-Demand JSON: A Better Way to Parse Documents?, Software: Practice and Experience 54 (6), 2024. Geoff Langdale, Daniel Lemire, Parsing Gigabytes of JSON per Second, VLDB Journal 28 (6), 2019. Vidéos # "},{"id":99,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/les_boucles/","title":"Les boucles","section":"XSLT","content":" Les boucles # Utiliser XSLT comme base de données et éléments « for-each » # Dans cette section, nous explorons l\u0026rsquo;utilisation de XSLT pour traiter des séquences d\u0026rsquo;éléments avec l\u0026rsquo;élément xsl:for-each, permettant de boucler sur des nœuds sélectionnés par XPath et d\u0026rsquo;effectuer des opérations répétitives.\nL\u0026rsquo;exemple de la liste des clients avec leur numéro de téléphone nous permet de faire plus. Tout d\u0026rsquo;abord, l\u0026rsquo;expression « //client » donne une séquence de tous les éléments « client » dans le nœud courant. Avec l\u0026rsquo;expression XPath « //client[nom=\u0026lsquo;Sylvain\u0026rsquo;] », nous pouvons obtenir la séquence de tous les éléments « client » ayant pour nom « Sylvain ». Dans ce cas précis, il y a plus d\u0026rsquo;un élément dans la réponse. Pour visiter l\u0026rsquo;ensemble des éléments dans la séquence, il suffit d\u0026rsquo;utiliser l\u0026rsquo;élément « xsl:for-each » comme ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Numéros de téléphone pour Sylvain: \u0026lt;ul\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;//client[nom=\u0026#39;Sylvain\u0026#39;]/@telephone\u0026#34; \u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;.\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Le résultat de l\u0026rsquo;application de ce fichier XSLT au fichier XML contenant les numéros de téléphone sera :\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Numéros de téléphone pour Sylvain: \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;545-5455\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;545-5456\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; Dans une telle boucle, il peut être utile de savoir quel est le numéro du nœud courant. On obtient ce numéro avec la fonction XSLT « position() » qui a la valeur 1 quand il s\u0026rsquo;agit du premier nœud et la valeur « last() » quand il s\u0026rsquo;agit du dernier nœud. On peut aussi utiliser une instruction xsl:sort au sein d\u0026rsquo;un élément for-each.\nSupposons maintenant que nous voulions compter le nombre de fois qu\u0026rsquo;un client est dans la base de données. Un modèle XSLT comme celui qui suit semble une bonne piste :\n\u0026lt;xsl:template match=\u0026#34;client\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;count(//client[nom=./nom])\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; Malheureusement, entre les crochets (partie conditionnelle de l\u0026rsquo;expression XPath), le symbole « . » ne représente plus l\u0026rsquo;élément « client » XSLT courant, mais bien chacun des éléments « client » du document tour à tour : la condition « nom=./nom » est ici toujours satisfaite. Heureusement, il existe une fonction XSLT, appelée « current() », qui représente toujours l\u0026rsquo;élément XSLT courant. Donc, si nous voulons parcourir tout le document et trouver combien de fois chaque client est dans la liste, nous pourrions utiliser le document XSLT suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;listes\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;vendeur\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;p\u0026gt;Nom du vendeur: \u0026lt;xsl:value-of select=\u0026#34;@nom\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt;\u0026lt;/ul\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;client\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt;: \u0026lt;xsl:value-of select=\u0026#34;count(//client[nom=current()/nom])\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Le résultat de la transformation sera alors :\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Nom du vendeur: Jean\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Jacques: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Sylvain: 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Claude: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Yvon: 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;Nom du vendeur: Raymond\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Arthur: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Sylvain: 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Claudette: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Yvon: 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; "},{"id":100,"href":"/orientee_donnees/legacy/semaine_12/travail_4/","title":"Travail 4","section":"Semaine 12","content":" Travail 4 # Consignes générales Utilisez les noms des fichiers spécifiés dans chaque exercice. Vous n'avez droit qu'à un seul fichier « .java » par exercice et il ne doit pas contenir plus de 500 lignes de code. Tous les problèmes peuvent être résolus en moins de 100 lignes! Rappelons qu'une « ligne » de code comprend un maximum de 80 caractères. Chaque fichier Java doit débuter par un commentaire donnant le sigle du cours et votre nom comme ceci : /** * programmation orientée-données - Travail noté 4 - Votre nom, fait avec JDK 26 */ Vous devriez pouvoir accéder à la version de votre SDK, en tapant « javac -version » ou « java -version » dans une ligne de commande. Ne traitez pas les cas d'exception, comme les fichiers qui n'existent pas ou ne peuvent être ouverts. Par contre, votre code doit produire un résultat correct dans des conditions normales. Par exemple, si on vous demande de produire du XML, il doit s'agir de XML bien formé. Si on vous demande de lire du XML, vous devez pouvoir lire tout XML qui se conforme aux spécifications décrites dans l'exercice. Vous devez utiliser l'API DOM. Il est impératif que vos fichiers compilent avec le SDK (le plus récent), sans utiliser de librairies particulières. Un fichier Java qui ne compile pas ne sera pas noté. Lorsque vous aurez terminé les exercices, vous devez transmettre à votre personne tutrice, en utilisant l'outil de dépôt de l'Université, l'ensemble des fichiers avec l'extension Java comme fichiers attachés. Vous devez aussi remettre un fichier XML ainsi qu'un document (Word 97/2000/XP, ODF , PDF, RTF ou en format texte) clairement identifié à votre nom contenant l'analyse demandée à la première question du travail. Il s'agit d'un travail personnel et vous ne devez pas partager vos solutions. Cette activité notée compte pour 15 % de la note globale. Exercice 1 Supposons une liste de transactions avec un attribut « montant » pour chaque client, comme dans le document XML suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;liste\u0026gt; \u0026lt;client nom=\"Jean Charles\"\u0026gt; \u0026lt;transaction montant=\"500\" /\u0026gt; \u0026lt;question\u0026gt;Quelle est la dernière marque?\u0026lt;/question\u0026gt; \u0026lt;transaction montant=\"1200\" /\u0026gt; \u0026lt;/client\u0026gt; \u0026lt;client nom=\"Pierre Élisabeth\"\u0026gt; \u0026lt;transaction montant=\"600\" /\u0026gt; \u0026lt;transaction montant=\"800\" /\u0026gt; \u0026lt;question\u0026gt;Où puis-je trouver le modèle 2002?\u0026lt;/question\u0026gt; \u0026lt;transaction montant=\"2000\" /\u0026gt; \u0026lt;/client\u0026gt; \u0026lt;/liste\u0026gt; Supposons que le fichier se nomme « transactions.xml ». Nous ne savons pas combien de transactions il peut y avoir par client; nous ne savons pas combien de clients nous avons; de plus, nous ne connaissons pas les noms des clients d'avance. Nous supposons que l'élément-racine est toujours « liste »; que tous les éléments « transaction » ont un attribut « montant »; que tous les éléments « transaction » sont dans des éléments « client »; que les éléments « client » sont tous dans l'élément-racine et ont tous un attribut « nom ». Nous supposons également qu'il n'y aura pas deux attributs « nom » avec la même valeur (même nom). Enfin, nous supposons que toutes les valeurs d'attribut de « montant » sont des entiers (« int » en Java). Écrivez un programme qui calcule la somme des valeurs de l'attribut « montant » pour chaque client (seuls les attributs « montant » des éléments « transaction »). Nous supposons qu'il s'agit de nombres entiers, des dollars par exemple. Le code source de votre programme sera dans un fichier nommé « Transactions.java ». Ainsi, la commande « java Transactions transactions.xml » devra donner : Nom du client: Jean Charles Somme: 1700 Nom du client: Pierre Élisabeth Somme: 3400 Comparez la solution que vous obtenez en utilisant DOM avec ce qui est possible de faire avec XSLT, en fonction du temps de développement. Donnez au moins un avantage de l'approche DOM sur l'approche XSLT et un avantage de l'approche XSLT sur DOM. Vous devez remettre une solution XSLT sous la forme d'un document XML. Vous pouvez mettre des commentaires dans votre code Java, mais la comparaison entre DOM et XSLT doit être faite dans un document à part. Exercice 2 Avec XSLT, nous pouvons combiner plusieurs documents en utilisant la fonction « document » qui permet de charger plusieurs documents XML. Mais que se passe-t-il lorsque nous devons combiner plusieurs documents, dont certains ne sont pas en XML? À ce moment, l'utilisation d'un langage comme Java et de DOM peut être très avantageuse. Supposons qu'un serveur enregistre les achats effectués sur le site, dans un fichier texte, en plaçant chaque achat sur une ligne avec des informations séparées par des virgules. Le fichier se nomme « achats.txt » : Jean Charles, 3214324565, 321, 2 Yvan Richard, 5435435545, 321, 1 Yvette Gagnon, 4324324243, 1, 12 Sur chaque ligne, se trouvent le nom du client, son numéro de carte de crédit, le code du produit acheté et la quantité achetée. Nous supposons que le serveur est un logiciel commercial et qu'il n'est pas possible de le modifier pour obtenir le format des données en XML. Par ailleurs, nous avons un document XML contenant notre inventaire; le fichier se nomme « inventaire.xml ». Le voici : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;inventaire\u0026gt; \u0026lt;produit code=\"1\" prix=\"432.00\" quantité= \"43\" /\u0026gt; \u0026lt;produit code=\"32\" prix=\"32.00\" quantité= \"100\" /\u0026gt; \u0026lt;produit code=\"321\" prix=\"31.00\" quantité= \"200\" /\u0026gt; \u0026lt;/inventaire\u0026gt; Écrivez un programme qui met à jour l'inventaire en tenant compte des achats de la journée, contenus dans le fichier « achats.txt ». Votre code source devra se trouver dans le fichier « Inventaire.java » et la commande « java Inventaire achats.txt inventaire.xml» va modifier le fichier « inventaire » pour y soustraire les produits achetés ce qui, dans le cas qui nous concerne, donnera un fichier « inventaire.xml » ayant le contenu suivant : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;inventaire\u0026gt; \u0026lt;produit code=\"1\" prix=\"432.00\" quantité= \"31\" /\u0026gt; \u0026lt;produit code=\"32\" prix=\"32.00\" quantité= \"100\" /\u0026gt; \u0026lt;produit code=\"321\" prix=\"31.00\" quantité= \"197\" /\u0026gt; \u0026lt;/inventaire\u0026gt; Nous pouvons supposer que le fichier « inventaire.xml » ne contient qu'un seul élément « produit » pour chaque valeur d'attribut « code ». Nous pouvons aussi supposer qu'aucun code invalide n'apparaît dans le fichier « achats.txt ». Par contre, nous ne savons pas combien de produits nous avons et combien d'achats il y aura. Évidemment, il est possible d'avoir un nombre négatif de produits dans notre inventaire. Indice.- Il est parfaitement possible d'écrire un tel programme en moins de 50 lignes. Exercice 3 Il est parfois pénible d'utiliser l'interface DOM quand on cherche une seule information précise. Écrivez un programme Java qui permet d'extraire le prix correspondant à l'item ayant le code de produit 321 dans un fichier XML ayant la forme suivante en utilisant une expression XPath . \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;inventaire\u0026gt; \u0026lt;produit code=\"1\" prix=\"432.00\" quantité= \"43\" /\u0026gt; \u0026lt;produit code=\"32\" prix=\"32.00\" quantité= \"100\" /\u0026gt; \u0026lt;produit code=\"321\" prix=\"31.00\" quantité= \"200\" /\u0026gt; \u0026lt;/inventaire\u0026gt; Exercice 4 En utilisant AJAX, on peut rendre une page web dynamique. Malheureusement, pour des raisons de sécurité, un script dans une page web ne peut charger un fichier qui se trouve dans un domaine autre que celui d'origine. On vous demande donc de déposer le fichier RSS https://www.ledevoir.com/rss/edition_complete.xml (il faut enregister le contenu sur votre disque) sur votre machine et de créer une page web AJAX capable de charger le fichier XML en question et d'afficher tant le titre des nouvelles que leur description complète. Attention, il ne faut récupérer que le contenu des éléments au sein des éléments item. Vous pouvez supposer que les titres et descriptions ne contiennent que du texte, sans éléments HTML. Certains étudiants trouvent utile d'utiliser la syntaxe « try { } catch(e) {} » de l'JavaScript (qui fonctionne comme en Java) pour traiter les erreurs. Cependant, cette syntaxe n'est pas nécessaire. \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Exemple AJAX\u0026lt;/title\u0026gt; \u0026lt;script language=\u0026#34;JavaScript\u0026#34;\u0026gt; function afficheTitres(doc) { titres = doc.getElementsByTagName(\u0026#34;title\u0026#34;); elementol = document.createElement(\u0026#34;ol\u0026#34;); var longueur = titres.length; for (k = 0; k \u0026lt; longueur; ++k) { elementli = document.createElement(\u0026#34;li\u0026#34;); elementli.appendChild(document.createTextNode(titres[k].firstChild.nodeValue)); elementol.appendChild(elementli); } body = document.getElementsByTagName(\u0026#34;body\u0026#34;).item(0); body.appendChild(elementol); } function chargeDocument(f) { var fileReader = new FileReader(); fileReader.onload = function(evt) { var doc = new DOMParser().parseFromString(this.result, \u0026#39;application/xml\u0026#39;); afficheTitres(doc); } fileReader.readAsText(f[0]); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Récupére et affiche les nouvelles du devoir: \u0026lt;/p\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; onchange=\u0026#34;chargeDocument(this.files)\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Exercice 5 Pour les cas simples, on peut convertir les documents XML en JSON, et vice versa avec une simple familiarité avec les formats. Convertissez le fichier suivant en fichier JSON. Vérifiez que votre document JSON est un document JSON valable . \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;joueur\u0026gt; \u0026lt;nom\u0026gt;Pierrot Rouge\u0026lt;/nom\u0026gt; \u0026lt;cote\u0026gt;3 étoiles\u0026lt;/cote\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;nom\u0026gt;Pierrette Rouge\u0026lt;/nom\u0026gt; \u0026lt;nom\u0026gt;Pierre Rouge\u0026lt;/nom\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;/joueur\u0026gt; "},{"id":101,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/cles_et_aggregation/","title":"Clés et aggrégation","section":"XSLT","content":" Clés et aggrégation # Obtenir l\u0026rsquo;aggrégation avec la fonction « generate-id » # Supposons qu\u0026rsquo;on veuille calculer le total des éléments « quantite », mais en faisant l\u0026rsquo;aggrégation pour chaque valeur de l\u0026rsquo;attribut « type » dans l\u0026rsquo;exemple suivant.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;produits.xsl\u0026#34; type=\u0026#34;text/xsl\u0026#34; ?\u0026gt; \u0026lt;produits\u0026gt; \u0026lt;france\u0026gt; \u0026lt;quantite type=\u0026#34;bain\u0026#34;\u0026gt;53\u0026lt;/quantite\u0026gt; \u0026lt;quantite type=\u0026#34;chambre\u0026#34;\u0026gt;12\u0026lt;/quantite\u0026gt; \u0026lt;/france\u0026gt; \u0026lt;canada\u0026gt; \u0026lt;quantite type=\u0026#34;bain\u0026#34;\u0026gt;14\u0026lt;/quantite\u0026gt; \u0026lt;quantite type=\u0026#34;chambre\u0026#34;\u0026gt;12\u0026lt;/quantite\u0026gt; \u0026lt;/canada\u0026gt; \u0026lt;/produits\u0026gt; On pourrait tenter de résoudre ce problème avec une expression XPath de la forme « sum(//quantite[@type=current()/@type]) ». Malheureusement, on risque alors de calculer plusieurs fois la même somme. Par exemple, tentez d\u0026rsquo;appliquer la transformation suivante :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;produits\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;quantite\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;@type\u0026#34; /\u0026gt; - \u0026lt;xsl:value-of select=\u0026#34;sum(//quantite[@type=current()/@type])\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Vous obtiendrez alors le résultat suivant :\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;p\u0026gt;bain - 67\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;chambre - 24\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;bain - 67\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;chambre - 24\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; Pour calculer la somme qu\u0026rsquo;une seule fois pour chaque valeur de l\u0026rsquo;attribut type, on pourrait ne faire le calcul que la première fois qu\u0026rsquo;on rencontre une valeur d\u0026rsquo;attribut donnée. L\u0026rsquo;expression XPath « //quantite[@type=x] » représente l\u0026rsquo;ensemble des éléments quantite ayant un attribut de valeur x. L\u0026rsquo;expression « //quantite[@type=x][1] » nous donne le premier élément de ce type rencontré. On pourrait penser que l\u0026rsquo;expression XPath « //quantite[@type=x][1]=current() » permet de déterminer si le nœud courant est le premier. Malheureusement, cette expression XPath vérifie plutôt si les deux éléments ont le même contenu. Comme nous avons deux éléments quantite ayant le même contenu dans notre exemple, cette solution ne suffit pas. La fonction generate-id quant à elle associe un identifiant unique à chaque nœud d\u0026rsquo;un document XML et permet donc de distinguer les éléments entre eux même lorsqu\u0026rsquo;ils ont le même contenu. L\u0026rsquo;expression « //quantite[@type=current()/@type]) » donne la séquence de tous les éléments quantite ayant un attribut type de même valeur que l\u0026rsquo;élément courant, alors que « (//quantite[@type=current()/@type])[1] » sélectionne le premier de cette liste. On peut vérifier si l\u0026rsquo;élément « quantite » est le premier du document ayant un certain type avec la fonction « generate-id » et l\u0026rsquo;expression « generate-id((//quantite[@type=current()/@type])[1]) = generate-id(.) ». On peut aussi vérifier que c\u0026rsquo;est le dernier avec l\u0026rsquo;expression « generate-id((//quantite[@type=current()/@type])[last()]) = generate-id(.) ». En utilisant cette astuce, on peut obtenir l\u0026rsquo;aggrégation souhaitée avec le programme XSLT suivant où l\u0026rsquo;on fait la somme seulement pour le premier élément rencontré ayant un certain type :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;produits\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;quantite\u0026#34;\u0026gt; \u0026lt;xsl:if test=\u0026#34;generate-id((//quantite[@type=current()/@type])[1]) = generate-id(.)\u0026#34; \u0026gt; \u0026lt;p\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;@type\u0026#34; /\u0026gt; - \u0026lt;xsl:value-of select=\u0026#34;sum(//quantite[@type=current()/@type])\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; On peut appliquer cette technique à notre exemple de la section précédente avec les vendeurs et les clients. La transformation suivante permet de ne calculer la fréquence de chaque client qu\u0026rsquo;une seule fois.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;listes\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;vendeur\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;client\u0026#34;\u0026gt; \u0026lt;xsl:if test=\u0026#34;generate-id(.)=generate-id(//client[nom=current()/nom][1])\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt;: \u0026lt;xsl:value-of select=\u0026#34;count(//client[nom=current()/nom])\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Le résultat de cette transformation donne une liste désordonnée de clients :\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Jacques: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Sylvain: 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Claude: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Yvon: 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Arthur: 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Claudette: 1\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; On peut trier le nom des clients en utilisant un élément xsl:sort :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;listes\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;//client\u0026#34; \u0026gt; \u0026lt;xsl:sort select=\u0026#34;nom\u0026#34; order=\u0026#34;ascending\u0026#34; data-type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;xsl:if test=\u0026#34;generate-id(.)=generate-id(//client[nom=current()/nom][1])\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt;: \u0026lt;xsl:value-of select=\u0026#34;count(//client[nom=current()/nom])\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Un peu plus de performance avec la fonction XSLT « key » # Cette section explore l\u0026rsquo;utilisation de la fonction XSLT « key » pour améliorer les performances lors de l\u0026rsquo;aggrégation de données.\nLe problème avec l\u0026rsquo;utilisation d\u0026rsquo;expressions XPath telles que //client[nom=current()/nom] est qu\u0026rsquo;elles peuvent s\u0026rsquo;avérer coûteuses en temps de calcul si on les utilisent à répétition. Afin d\u0026rsquo;accélérer les choses et simplifier un peu nos programmes, on peut créer un tableau associatif avec l\u0026rsquo;élément xsl:key et sa fonction correspondante key. Un tableau associatif est simplement une structure de donnée qui associe à chaque clef ou au plusieurs valeurs. Puisque ce tableau est construit une seule fois lorsque le processeur rencontre l\u0026rsquo;élément xsl:key, le processeur XSLT n\u0026rsquo;a pas à visiter les nœuds du document plusieurs fois. L\u0026rsquo;élément xsl:key comprend trois attributs incluant le nom du tableau associative (name), les clefs à inclure (use) et les nœuds à traiter (match). L\u0026rsquo;instruction \u0026lt;xsl:key name=\u0026quot;montableau\u0026quot; match=\u0026quot;client\u0026quot; use=\u0026quot;nom\u0026quot;/\u0026gt; va créer un tableau associatif s\u0026rsquo;appelant montableau et qui associe à chaque valeur client/nom l\u0026rsquo;élément nom correspondant. La fonction key quant à elle prend deux paramètres incluant le nom du tableau et la valeur de la clef. À titre d\u0026rsquo;exemple, la transformation suivante permet de calculer la fréquence de chaque client comme à la question précédente, mais en utilisant un tableau associatif :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:key name=\u0026#34;montableau\u0026#34; match=\u0026#34;client\u0026#34; use=\u0026#34;nom\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;listes\u0026#34;\u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;ul\u0026gt; \u0026lt;xsl:for-each select=\u0026#34;//client\u0026#34; \u0026gt; \u0026lt;xsl:sort select=\u0026#34;nom\u0026#34; order=\u0026#34;ascending\u0026#34; data-type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;xsl:if test=\u0026#34;generate-id(.)=generate-id(key(\u0026#39;montableau\u0026#39;,nom)[1])\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;nom\u0026#34; /\u0026gt;: \u0026lt;xsl:value-of select=\u0026#34;count(//client[nom=current()/nom])\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:for-each\u0026gt; \u0026lt;/ul\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; "},{"id":102,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/generer_des_noeuds_dynamiquement/","title":"Générer des noeuds dynamiquement","section":"XSLT","content":" Générer des noeuds dynamiquement # Générer un commentaire # Cette section explique comment générer des commentaires dans la sortie XML à l\u0026rsquo;aide de XSLT.\nIl arrive qu\u0026rsquo;on veuille produire un commentaire dans la sortie XML. Rien de plus simple ! Il suffit d\u0026rsquo;utiliser l\u0026rsquo;instruction xsl:comment comme dans cet exemple :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:comment\u0026gt;Ceci est un commentaire.\u0026lt;/xsl:comment\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Le résultat devrait ressembler à ceci :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!--Ceci est un commentaire.--\u0026gt; Créer des éléments dynamiquement avec « xsl:element » # Cette section montre comment créer des éléments XML dynamiquement en utilisant xsl:element et xsl:attribute.\nIl est parfois utile de créer dynamiquement un élément avec « xsl:element » et de créer des attributs avec « xsl:attribute ». Dans l\u0026rsquo;exemple suivant, on va créer un élément dont le nom nous est fourni par un paramètre.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:param name=\u0026#34;ele\u0026#34; select=\u0026#34;p\u0026#34; /\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;xsl:element name=\u0026#34;{$ele}\u0026#34; namespace=\u0026#34;http://mondom.com/\u0026#34; \u0026gt; \u0026lt;xsl:attribute name=\u0026#34;couleur\u0026#34; namespace=\u0026#34;http://mondom.com/\u0026#34;\u0026gt; bleu \u0026lt;/xsl:attribute\u0026gt; \u0026lt;/xsl:element\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Copier des nœuds avec « xsl:copy » et « xsl:copy-of » # Cette section explique comment copier des nœuds XML en utilisant xsl:copy et xsl:copy-of.\nIl est parfois nécessaire de dire au XSLT qu\u0026rsquo;on souhaite tout simplement recopier le nœud courant dans le document sortant. L\u0026rsquo;élément « xsl:copy » copie l\u0026rsquo;élément (seul, sans ses attributs mais avec son espace de noms) alors que l\u0026rsquo;élément « xsl:copy-of » permet de copier un élément ainsi que tous les nœuds qu\u0026rsquo;il contient. XSLT ne transforme pas les nœuds ainsi copiés, ils sont insérés dans le résultat directement. Par exemple, ce document XSLT va créer une copie intégrale du document:\n\u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;xsl:copy-of select=\u0026#34;.\u0026#34; /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Dans le cas où l\u0026rsquo;on sélectionne plus d\u0026rsquo;un élément, notamment avec une expression du type nom|prenom, tous les éléments sont copiés l\u0026rsquo;un après l\u0026rsquo;autre. Ce comportement diffère de l\u0026rsquo;instruction value-of qui n\u0026rsquo;extrait le contenu textuel que du premier élément rencontré.\nPar contre, si on ne souhaite qu\u0026rsquo;un document XML qui contient le même élément-racine, mais sans le contenu de l\u0026rsquo;élément racine, on utilisera plutôt un élément « xsl:copy », comme ceci :\n\u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/*\u0026#34;\u0026gt; \u0026lt;xsl:copy/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Naturellement, on peut même définir le contenu de l\u0026rsquo;élément copié à l\u0026rsquo;aide d\u0026rsquo;un modèle :\n\u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/*\u0026#34;\u0026gt; \u0026lt;xsl:copy \u0026gt; \u0026lt;a\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;/xsl:copy\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Si on souhaite ne copier qu\u0026rsquo;une partie du contenu de l\u0026rsquo;élément ainsi reproduit, par exemple ses attributs, on peut utiliser copy-of :\n\u0026lt;xsl:stylesheet xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; \u0026lt;xsl:template match=\u0026#34;/*\u0026#34;\u0026gt; \u0026lt;xsl:copy \u0026gt; \u0026lt;xsl:copy-of select=\u0026#34;@*\u0026#34;/\u0026gt; \u0026lt;a\u0026gt;x\u0026lt;/a\u0026gt; \u0026lt;/xsl:copy\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; "},{"id":103,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/variables_et_parametres/","title":"Variables et paramètres","section":"XSLT","content":" Variables et paramètres Les variables Il est possible, en XSLT, de définir des variables, mais elles sont « immutables » (« dont la valeur ne peut être modifiée »). On peut se demander, à juste titre, si les mots variables et immutables vont bien ensemble, mais c'est ainsi que les inventeurs du XSLT se sont exprimés. Pour définir une variable nommée « test », on utilise l'élément « \u0026lt;xsl:variable name=\"test\" select=\"xxx\" /\u0026gt; ». La variable contiendra alors le résultat de l'expression XPath contenue dans l'attribut « select ». On fait référence à la variable dans d'autres expressions XPath en utilisant le symbole « $ ». Ainsi, si la variable se nomme test, l'expression $test aura comme valeur la valeur de la variable. L'exemple suivant peut être utilisé pour remplacer tous les éléments « produit » par le noeud de texte « bozo ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:variable name=\"test\" select=\"'bozo'\" /\u0026gt; \u0026lt;xsl:template match=\"produit\"\u0026gt; \u0026lt;xsl:value-of select=\"$test\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; On peut aussi définir la valeur de la variable en omettant l'attribut « select » et en ajoutant du contenu à l'élément « xsl:variable ». Dans l'exemple suivant, on propose de remplacer tous les éléments «produit» par le contenu de la variable (qui est ici « \u0026lt;produit\u0026gt;x\u0026lt;/produit\u0026gt; »): \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:variable name=\"test\" \u0026gt; \u0026lt;produit\u0026gt;x\u0026lt;/produit\u0026gt; \u0026lt;/xsl:variable\u0026gt; \u0026lt;xsl:template match=\"produit\"\u0026gt; \u0026lt;xsl:copy-of select=\"$test\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; On peut déclarer la variable localement au sein d'un élément template. Pouvez-vous trouver ce que fait la transformation suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:variable name=\"test\" \u0026gt; \u0026lt;produit\u0026gt;x\u0026lt;/produit\u0026gt; \u0026lt;/xsl:variable\u0026gt; \u0026lt;xsl:copy-of select=\"$test\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Les paramètres Un fichier XSLT peut être utilisé comme un programme dans la mesure où on peut lui passer des paramètres. Rappelons qu'on appelle un fichier XSLT « xslt.xml » à partir d'un fichier XML qu'on veut transformer de cette manière : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;?xml-stylesheet href=\"xslt.xml\" type=\"application/xml\"?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;raison\u0026gt;Achat d'ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; On peut enrichir cet appel avec les instructions « xslt-param » comme dans cet exemple. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;?xslt-param name=\"couleur\" value=\"blue\"?\u0026gt; \u0026lt;?xslt-param name=\"taille\" value=\"2\"?\u0026gt; \u0026lt;?xml-stylesheet href=\"xslt.xml\" type=\"application/xml\"?\u0026gt; \u0026lt;facture\u0026gt; \u0026lt;montant\u0026gt;10.10\u0026lt;/montant\u0026gt; \u0026lt;personne\u0026gt;Jean Rochond\u0026lt;/personne\u0026gt; \u0026lt;raison\u0026gt;Achat d'ordinateur\u0026lt;/raison\u0026gt; \u0026lt;/facture\u0026gt; Selon votre processeur XSLT, il peut y avoir d'autres façons de passer des paramètres à une feuille de style XSLT. On reçoit alors les paramètres avec un élément « xsl:param ». L'attribut « select » est utilisé pour spécifier une valeur par défaut. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:param name=\"couleur\" select=\"red\" /\u0026gt; \u0026lt;xsl:param name=\"taille\" select=\"1\" /\u0026gt; \u0026lt;xsl:template match=\"facture\"\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\"personne\" /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p style=\"color:{$couleur}; font-size:{$taille}em\"\u0026gt;Ceci est une facture pour \u0026lt;xsl:value-of select=\"personne\" /\u0026gt; de \u0026lt;xsl:value-of select=\"montant\" /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\"raison\" /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; On peut aussi passer des paramètres aux éléments « xsl:template » avec les éléments « xsl:call-template » comme dans cet exemple qui est une façon équivalente, mais plus compliquée, de formater notre document XML de type « facture » . \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"facture\"\u0026gt; \u0026lt;xsl:call-template name=\"monmotif\"\u0026gt; \u0026lt;xsl:with-param name=\"contenu\" select=\".\"/\u0026gt; \u0026lt;/xsl:call-template\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template name=\"monmotif\"\u0026gt; \u0026lt;xsl:param name=\"contenu\" /\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Facture de \u0026lt;xsl:value-of select=\"$contenu/personne\" /\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Ceci est une facture pour \u0026lt;xsl:value-of select=\"$contenu/personne\" /\u0026gt; de \u0026lt;xsl:value-of select=\"$contenu/montant\" /\u0026gt;$ pour: \u0026lt;xsl:value-of select=\"$contenu/raison\" /\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; On peut aussi charger des documents distants avec la fonction XSLT « document » , cette instruction donne une copie du document situé à l'adresse @href : \u0026lt;xsl:copy-of select=\"document(@href)\"/\u0026gt;. (L'élément « xsl:copy-of » sert ici à faire une copies des nœuds contenus dans le document distant.) Elle est cependant sujette à des contraintes de sécurité lorsqu'on l'utilise dans un navigateur : il n'est pas permis de charger des documents provenant d'autres serveurs que le serveur d'origine. "},{"id":104,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/mise_en_forme/","title":"Mise en forme","section":"XSLT","content":" Mise en forme # Format et mise en forme # Cette section explique comment contrôler le format de sortie des transformations XSLT.\nPar défaut, le document créé par une transformation XSLT est en XML, sauf si le nœud-racine est nommé HTML et qu\u0026rsquo;il est précédé uniquement d\u0026rsquo;espaces et de retours de charriot, auquel cas le document créé est un document HTML. L\u0026rsquo;instruction xsl:output permet de spécifier explicitement le format du document nouvellement créé comme étant en XML, en HTML ou même au format texte (sans balise). On peut aussi spécifier l\u0026rsquo;encodage des caractères ainsi que l\u0026rsquo;indentation des éléments. Voici des exemples :\n\u0026lt;xsl:output method=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;xsl:output method=\u0026#34;html\u0026#34; /\u0026gt; \u0026lt;xsl:output method=\u0026#34;xml\u0026#34; version=\u0026#34;1.0\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;/\u0026gt; Le résultat d\u0026rsquo;une transformation XSLT peut ensuite être redirigé vers un fichier sur disque en utilisant un autre langage, comme JavaScript ou Java. Avec XSLT 1.0, il n\u0026rsquo;est pas possible de créer directement un fichier avec XSLT.\n"},{"id":105,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/espaces_de_noms/","title":"Espaces de noms","section":"XSLT","content":" Espaces de noms # Espaces de noms # Cette section explique comment travailler avec les espaces de noms XML en XSLT.\nLes espaces de noms sont supportés et ne posent pas de problème. Il suffit de définir les préfixes, comme on le fait habituellement. Par exemple, considérons le code XML suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; ?\u0026gt; \u0026lt;?xml-stylesheet href=\u0026#34;class2.xsl\u0026#34; type=\u0026#34;text/xsl\u0026#34; ?\u0026gt; \u0026lt;université\u0026gt; \u0026lt;étudiant\u0026gt; \u0026lt;n:nom xmlns:n=\u0026#34;http://www.mondomaine.com/\u0026#34;\u0026gt;Réjean Tremblay\u0026lt;/n:nom\u0026gt; \u0026lt;/étudiant\u0026gt; \u0026lt;/université\u0026gt; Pour afficher le nom de l\u0026rsquo;étudiant, il suffira d\u0026rsquo;utiliser le document XSLT suivant :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34; xmlns:n=\u0026#34;http://www.mondomaine.com/\u0026#34;\u0026gt; \u0026lt;xsl:template match=\u0026#34;université\u0026#34; \u0026gt; \u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;étudiant/n:nom\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;n:nom\u0026#34; \u0026gt; \u0026lt;p\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;.\u0026#34; /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Observons que l\u0026rsquo;attribut « match=\u0026ldquo;nom\u0026rdquo; » ne s\u0026rsquo;applique pas à l\u0026rsquo;élément « nom » dans l\u0026rsquo;espace de noms « http://www.mondomaine.com/ », tel qu\u0026rsquo;il apparaît dans notre document XML : il est obligatoire d\u0026rsquo;utiliser un préfixe correspondant au bon espace de noms. Tout comme « match=\u0026quot;\u0026quot; » permet de sélectionner tous les éléments, « match=\u0026ldquo;n:\u0026rdquo; » permet de sélectionner tous les éléments qui sont dans un espace de noms donné.\n"},{"id":106,"href":"/orientee_donnees/docs/travail_integration/","title":"Travail d'intégration","section":"Docs","content":" Travail d\u0026rsquo;intégration # Ce travail d\u0026rsquo;intégration vous permet de démontrer l\u0026rsquo;acquisition des compétences développées tout au long du cours. Vous devez créer une application web complète qui intègre plusieurs technologies : HTML5, JavaScript, AJAX, Java, JSON, XML, SVG, MathML, YAML, Maven et les styles CSS. Vous utilisez les libraires Java Gson, Jackson et Apache POI.\nAvertissement. Vous devez avoir fait toutes les activités du cours avant de tenter de faire l\u0026rsquo;activité d\u0026rsquo;intégration.\nObjectif # Créer un serveur web Java qui sert une page HTML5 permettant à l\u0026rsquo;utilisateur d\u0026rsquo;entrer une liste de 10 entiers et de dix étiquettes (par exemple, les dix provinces canadiennes). Ce serveur reçoit ces données via AJAX, génère un graphique à barres SVG avec des styles appropriés, puis retourne le graphique intégré dans un document JSON.\nTechnologies à utiliser # Pour réaliser ce projet, vous utiliserez plusieurs technologies. Le serveur sera développé en Java avec HttpServer. Pour le traitement des données XML, vous emploierez Jackson, tandis que Gson sera utilisé pour manipuler les données JSON. Apache POI sera utilisé pour générer des documents Excel au format Open XML. XSLT sera utilisé pour transformer les données XML en Markdown. L\u0026rsquo;interface utilisateur sera créée en HTML5 valide, avec des graphiques vectoriels SVG stylisés en CSS. La communication asynchrone se fera via AJAX, et les styles CSS3 seront appliqués tant à l\u0026rsquo;interface qu\u0026rsquo;aux éléments SVG.\nCahier des charges # Interface utilisateur (HTML5) # La page doit contenir un formulaire avec 10 champs numériques de type number ainsi que dix champs qui représentent les étiquettes. Par exemple, il pourrait être possible d\u0026rsquo;associer une valeur numérique à chaque province canadienne. Un bouton permettra de générer le graphique. Une zone d\u0026rsquo;affichage sera réservée pour montrer le résultat SVG. La génération du graphique doit se faire du côté serveur, en Java.\nIndices. Il peut être possible récupérer une réponse JSON d\u0026rsquo;un serveur avec du code JavaScript similaire à celui-ci.\nfetch(\u0026#39;/route\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { // code de traitement ici }); Il peut être possible d\u0026rsquo;insérer du SVG dans la page courante avec un code semblable à celui-ci.\nconst container = document.getElementById(\u0026#39;svg-container\u0026#39;); const parser = new DOMParser(); const svgDoc = parser.parseFromString(data.svg, \u0026#39;image/svg+xml\u0026#39;); const svgElement = svgDoc.documentElement; // The root \u0026lt;svg\u0026gt; element container.appendChild(svgElement); Maven # Maven est utilisé pour la gestion des dépendances et la construction du projet Java. Vous devez créer un fichier pom.xml à la racine du projet. Un fichier possible est celui-ci.\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;graph-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;21\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;21\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Gson pour la manipulation JSON --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.code.gson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.10.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Jackson pour le traitement XML --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Apache POI pour la génération de documents Excel Open XML --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi-ooxml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; La structure des fichiers doit suivre les conventions Maven :\npom.xml à la racine du projet. Les fichiers Java (comme GraphServer.java) dans src/main/java/. Les ressources statiques (comme index.html) dans src/main/resources/. Pour compiler le projet, utilisez mvn compile.\nConfiguration YAML # Votre service web doit être configurable avec un fichier YAML. Le fichier de configuration config.yml doit être placé dans le répertoire src/main/resources/ du projet Maven. Ce fichier contiendra les paramètres du serveur tels que le port, les chemins par défaut, et d\u0026rsquo;autres options de configuration.\nExemple de fichier config.yml :\nserver: port: 8080 host: localhost graph: defaultWidth: 800 defaultHeight: 600 colors: primary: \u0026#34;#3498db\u0026#34; secondary: \u0026#34;#e74c3c\u0026#34; Pour charger ce fichier YAML dans votre code Java, utilisez Jackson avec YAMLFactory :\nimport com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.dataformat.yaml.YAMLFactory; // Dans votre classe serveur ObjectMapper yamlMapper = new ObjectMapper(new YAMLFactory()); Config config = yamlMapper.readValue(new File(\u0026#34;src/main/resources/config.yml\u0026#34;), Config.class); Serveur Java # Le serveur doit servir la page HTML statique sur la route racine /. Il recevra les données XML sur l\u0026rsquo;endpoint /api/graph via une requête POST. Le serveur validera que exactement 10 entiers sont fournis, générera un SVG avec un graphique à barres, puis retournera un document JSON contenant le SVG. De plus, un endpoint /api/excel devra générer et retourner un fichier Excel Open XML avec les données saisies. Enfin, un endpoint /api/markdown devra transformer les données XML en Markdown à l\u0026rsquo;aide d\u0026rsquo;XSLT et retourner le résultat.\nGraphique SVG # Le SVG doit afficher 10 barres verticales représentant les valeurs saisies par l\u0026rsquo;utilisateur avec les étiquettes associées. Il utilisera des dégradés. Les axes seront étiquetés de manière claire. Le graphique inclura des infobulles au survol des barres. Vous devez par ailleurs include une expression MathML dans votre SVG.\nGénération d\u0026rsquo;un document Excel (Open XML) # Le serveur doit également fournir une fonction capable de générer et retourner un document Excel au format Open XML contenant les données saisies par l\u0026rsquo;utilisateur. Ce document devra inclure une feuille de calcul avec les valeurs et les étiquettes dans des colonnes appropriées. Un endpoint supplémentaire, par exemple /api/excel, devra être créé pour permettre le téléchargement du fichier Excel. Vous utiliserez Apache POI pour créer le fichier .xlsx.\nTransformation XSLT vers Markdown # Le serveur doit prendre les données XML reçues et les transformer en Markdown à l\u0026rsquo;aide d\u0026rsquo;une feuille de style XSLT. Un endpoint /api/markdown devra retourner le contenu Markdown généré, par exemple sous forme de texte brut ou dans un objet JSON. Vous devrez créer une feuille XSLT qui convertit la structure XML des données (valeurs et étiquettes) en un format Markdown lisible, tel qu\u0026rsquo;une liste ou un tableau.\nStructure proposée # 1. Page HTML (index.html) (point de départ) # \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Générateur de graphiques\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Générateur de graphiques à barres\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;graphForm\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;input-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val1\u0026#34; placeholder=\u0026#34;Valeur 1\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val2\u0026#34; placeholder=\u0026#34;Valeur 2\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val3\u0026#34; placeholder=\u0026#34;Valeur 3\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val4\u0026#34; placeholder=\u0026#34;Valeur 4\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val5\u0026#34; placeholder=\u0026#34;Valeur 5\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val6\u0026#34; placeholder=\u0026#34;Valeur 6\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val7\u0026#34; placeholder=\u0026#34;Valeur 7\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val8\u0026#34; placeholder=\u0026#34;Valeur 8\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val9\u0026#34; placeholder=\u0026#34;Valeur 9\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; id=\u0026#34;val10\u0026#34; placeholder=\u0026#34;Valeur 10\u0026#34; min=\u0026#34;0\u0026#34; max=\u0026#34;100\u0026#34; required\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- Ajouter les étiquettes !!! --\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Générer le graphique\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#39;graphForm\u0026#39;).addEventListener(\u0026#39;submit\u0026#39;, async function(e) { e.preventDefault(); // Collecter les valeurs const values = []; for (let i = 1; i \u0026lt;= 10; i++) { const val = parseInt(document.getElementById(\u0026#39;val\u0026#39; + i).value); if (isNaN(val)) { alert(\u0026#39;Veuillez entrer des valeurs numériques valides\u0026#39;); return; } values.push(val); } const label = []; // à compléter // Afficher le chargement document.getElementById(\u0026#39;result\u0026#39;) //.... à compléter try { // Envoyer les données au serveur en XML (généré avec DOM) // À faire: ajouter les étiquettes!!! const doc = document.implementation.createDocument(null, \u0026#39;data\u0026#39;); const valuesElement = doc.createElement(\u0026#39;values\u0026#39;); values.forEach(v =\u0026gt; { const valueElement = doc.createElement(\u0026#39;value\u0026#39;); valueElement.textContent = v; valuesElement.appendChild(valueElement); }); doc.documentElement.appendChild(valuesElement); const serializer = new XMLSerializer(); const xmlData = serializer.serializeToString(doc); const response = await fetch(\u0026#39;/api/graph\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/xml\u0026#39;, }, body: xmlData }); if (response.ok) { //.... } else { //.... } } catch (error) { //... } }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2. Serveur Java (GraphServer.java) (point de départ possible) # import com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.HttpExchange; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.dataformat.xml.XmlMapper; import com.google.gson.Gson; import com.google.gson.JsonArray; import com.google.gson.JsonObject; import java.io.*; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.List; import java.util.Map; public class GraphServer { private static final Gson gson = new Gson(); private static final ObjectMapper jsonMapper = new ObjectMapper(); private static final XmlMapper xmlMapper = new XmlMapper(); public static void main(String[] args) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0); server.createContext(\u0026#34;/\u0026#34;, exchange -\u0026gt; { try { if (\u0026#34;GET\u0026#34;.equals(exchange.getRequestMethod())) { String html = new String(Files.readAllBytes(Paths.get(\u0026#34;index.html\u0026#34;)), \u0026#34;UTF-8\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, html.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(html.getBytes(\u0026#34;UTF-8\u0026#34;)); } } else { exchange.sendResponseHeaders(405, -1); } } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } }); // Endpoint pour générer le graphique server.createContext(\u0026#34;/api/graph\u0026#34;, exchange -\u0026gt; { if (\u0026#34;POST\u0026#34;.equals(exchange.getRequestMethod())) { try { // Lire les données XML InputStreamReader reader = new InputStreamReader(exchange.getRequestBody(), \u0026#34;UTF-8\u0026#34;); StringBuilder xmlBuilder = new StringBuilder(); char[] buffer = new char[1024]; int length; while ((length = reader.read(buffer)) != -1) { xmlBuilder.append(buffer, 0, length); } String xmlInput = xmlBuilder.toString(); // Parser avec jackson // Convertir en liste d\u0026#39;entiers int[] values = new int[10]; for (int i = 0; i \u0026lt; 10; i++) { values[i] = valuesNode.get(i).asInt(); } String[] labels = //... à compléter pour les étiquettes // Générer le SVG String svgContent = generateSVG(values, labels); // Créer la réponse JSON JsonObject responseJson = new JsonObject(); responseJson.addProperty(\u0026#34;svg\u0026#34;, svgContent); String jsonResponse = gson.toJson(responseJson); exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=UTF-8\u0026#34;); exchange.sendResponseHeaders(200, jsonResponse.getBytes(\u0026#34;UTF-8\u0026#34;).length); try (OutputStream os = exchange.getResponseBody()) { os.write(jsonResponse.getBytes(\u0026#34;UTF-8\u0026#34;)); } } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else if (\u0026#34;OPTIONS\u0026#34;.equals(exchange.getRequestMethod())) { exchange.getResponseHeaders().set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;POST, OPTIONS\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type\u0026#34;); exchange.sendResponseHeaders(200, -1); } else { exchange.sendResponseHeaders(405, -1); } }); server.setExecutor(null); server.start(); System.out.println(\u0026#34;Serveur de graphiques démarré sur http://localhost:8080/\u0026#34;); } private static String generateSVG(int[] values, String[] labels) { //... } private static String generateHTMLResponse(String svgContent) { //... } } Le SVG doit utiliser des styles CSS appropriés. Pour les barres, vous emploierez un dégradé linéaire linearGradient. Les animations utiliseront les propriétés transition et transform au survol. Les couleurs devront être cohérentes, idéalement avec des variables CSS. La typographie sera soignée avec des polices et tailles appropriées pour les étiquettes. Pour l\u0026rsquo;accessibilité, n\u0026rsquo;oubliez pas d\u0026rsquo;ajouter des éléments \u0026lt;title\u0026gt; pour les infobulles.\nTypes MIME pour les réponses du serveur # Lors de la création des endpoints du serveur, il est essentiel de définir correctement les en-têtes Content-Type pour indiquer le type de contenu retourné. Voici les types MIME appropriés pour chaque format :\nSVG : Utilisez image/svg+xml pour indiquer que la réponse contient du SVG. Exemple en Java :\nexchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/svg+xml; charset=UTF-8\u0026#34;); Open XML (Excel) : Pour un fichier .xlsx, utilisez application/vnd.openxmlformats-officedocument.spreadsheetml.sheet. Pour permettre le téléchargement, ajoutez également un en-tête Content-Disposition. Exemple :\nexchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;data.xlsx\\\u0026#34;\u0026#34;); Markdown : Utilisez text/plain. Exemple :\nexchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain; charset=UTF-8\u0026#34;); Ces en-têtes permettent aux navigateurs et clients de traiter correctement les réponses, que ce soit pour l\u0026rsquo;affichage inline (SVG), le téléchargement (Excel) ou le rendu textuel (Markdown).\nÀ remettre # Vous devrez vérifier que exactement 10 valeurs sont fournies dans la requête. Vous devez vérifier que les étiquettes sont présentes. La gestion des erreurs devra être appropriée, avec des messages d\u0026rsquo;erreur clairs en cas de données invalides.\nLa page web doit transmettre du XML. Elle doit recevoir du JSON de la part du serveur. Jackson devra être utilisé de manière appropriée pour le XML et Gson pour le JSON.\nVous devrez remettre le code source Java complet avec des commentaires explicatifs, incluant la génération du SVG, du document Excel Open XML et de la transformation XSLT vers Markdown. La page HTML avec le formulaire et le JavaScript devra également être fournie. Une documentation expliquant l\u0026rsquo;architecture et les technologies utilisées sera nécessaire. Des exemples de données d\u0026rsquo;entrée et de résultats de sortie (SVG, Excel et Markdown) devront être inclus. Enfin, des tests montrant le fonctionnement avec différentes valeurs devront être présentés.\n"},{"id":107,"href":"/orientee_donnees/docs/evaluation/","title":"Évaluation et feuille de route","section":"Docs","content":" Évaluation # Pour évaluer vos apprentissages dans ce cours, nous avons préparé 5 travaux notés et un travail d\u0026rsquo;intégration. Le tableau qui suit les présente sommairement.\nActivités notées Pondération Travail noté 1 (JSON) 10 % Travail noté 2 (XML) 10 % Travail noté 3 (XPath et XSLT) 15 % Travail noté 4 (HTML) 15 % Travail noté 5 (Services/YAML) 10 % Travail d\u0026rsquo;intégration 40 % Total 100 % Feuille de route pour les 15 semaines # Pour réussir ce cours, nous vous recommandons de répartir votre temps de travail sur les 15 semaines, avec environ 9 heures par semaine. Voici une proposition de planning :\nSemaines 1-3 : Module JSON (bases, GeoJSON, Gson, jq, Unicode). Réalisez le Travail noté 1 (10 %). (~27 heures) Semaines 4-6 : Module XML (bases, espaces de noms, exemples, DOM/Jackson, RDF/SPARQL, validation). Réalisez le Travail noté 2 (10 %). (~27 heures) Semaines 7-9 : Module XPath, XSLT, XQuery (navigation, transformation, requêtes). Réalisez le Travail noté 3 (15 %). (~27 heures) Semaines 10-12 : Module HTML, CSS, SVG, MathML (structure, style, graphiques, maths). Réalisez le Travail noté 4 (15 %). (~27 heures) Semaines 13-14 : Module Services et YAML (AJAX, serveurs, API, encodage). Réalisez le Travail noté 5 (10 %). (~18 heures) Semaine 15 : Travail d\u0026rsquo;intégration (application web complète avec toutes les technologies). (40 %, ~9 heures) Cette répartition vous permet de progresser de manière équilibrée, en consacrant du temps à l\u0026rsquo;apprentissage théorique et à la pratique. Ajustez selon vos contraintes personnelles, mais assurez-vous de terminer tous les travaux notés avant de commencer l\u0026rsquo;intégration.\n"},{"id":108,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/les_axes/","title":"Les axes","section":"XSLT","content":" Les axes Les axes Par défaut, l'expression XPath « nom » désigne les éléments « nom » qui sont des enfants du nœud courant. On peut aussi écrire « child::nom ». De la même manière, « nom[2] » ou « child::nom[2] » désigne le second enfant du nœud courant. Il est possible de changer ce comportement en choisissant un axe différent. « child » : il s'agit de l'axe par défaut, « child::nom[3] » désigne le troisième élément « nom » enfant du nœud courant. « parent » : l'axe « parent » est pratiquement inutile, « parent::nom » désigne l'élément parent si celui-ci se nomme « nom ». En général, il est plus simple d'utiliser la syntaxe « .. » qui est équivalente à « parent::node() ». « attribute » : la syntaxe « attribute:: » n'est pas utilisée, on préfère la notation « @nom » qui signifie la même chose que « attribute::nom ». « ancestor » : la syntaxe « ancestor::nom » désigne les éléments de nom « nom » dans lesquels le nœud courant est contenu. On peut tester si le nœud courant est contenu dans un paragraphe avec la syntaxe \u0026lt;xsl:if test=\"ancestor::paragraphe\"\u0026gt;...\u0026lt;/xsl:if\u0026gt;. « ancestor-or-self » : idem que l'axe ancestor exception faite que l'on inclut le nœud courant, on pourrait donc tester si nœud courant est contenu dans un paragraphe ou s'il est lui-même un paragraphe avec la syntaxe \u0026lt;xsl:if test=\"ancestor-or-self::paragraphe\"\u0026gt;...\u0026lt;/xsl:if\u0026gt;. « preceding-sibling » : cet axe consulte en séquence les frères du nœud courant, c'est-à-dire les nœud ayant le même parent, qui apparaissent avant le nœud courant. Par exemple, « preceding-sibling::nom[2] » cherche le second élément-frère apparaissant avant le nœud courant. « following-sibling » : voir l'axe « preceding-sibling », mais à l'envers ( après le nœud courant). « preceding » : cet axe est similaire à « preceding-sibling », mais on traverse tous les nœuds qui se sont terminés avant nœud courant. Par exemple, « preceding::nom[2] » cherche le second élément apparaissant avant le nœud courant, même s'il n'a pas le même parent. « following » : voir l'axe « preceding », mais à l'envers. « descendant » : voir l'axe « ancestor », mais à l'envers. « descendant-or-self » : voir l'axe « ancestor-or-self », mais à l'envers. "},{"id":109,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/etude_dun_exemple_docbook/","title":"Étude d’un exemple (DocBook)","section":"XSLT","content":" Étude d’un exemple (DocBook) # L\u0026rsquo;étude d\u0026rsquo;un exemple: docbook.xslt # On peut utiliser un document XSLT pour transformer des documents DocBook simple en HTML.\nNous allons passer en revue brièvement les éléments « xsl:template » qu\u0026rsquo;il contient.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026#34;1.0\u0026#34; xmlns:xsl=\u0026#34;http://www.w3.org/1999/XSL/Transform\u0026#34;\u0026gt; \u0026lt;xsl:output method=\u0026#34;html\u0026#34; indent=\u0026#34;yes\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34; /\u0026gt; \u0026lt;xsl:template match=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;bookinfo\u0026#34;/\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;bookinfo/title\u0026#34; /\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026#34;text-indent:1em;\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/author/firstname\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/author/surname\u0026#34; /\u0026gt; \u0026amp;#169; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/copyright/year\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;h2\u0026gt;Table des matières\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;chapter\u0026#34; mode=\u0026#34;tdm\u0026#34;/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;chapter\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;bookinfo\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt; par \u0026lt;xsl:value-of select=\u0026#34;author/firstname\u0026#34; /\u0026gt;\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;author/surname\u0026#34; /\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;chapter\u0026#34; mode=\u0026#34;tdm\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;section\u0026#34; mode=\u0026#34;tdm\u0026#34;/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;section\u0026#34; mode=\u0026#34;tdm\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;chapter\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;a name=\u0026#34;{generate-id(.)}\u0026#34; \u0026gt;Chapitre \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;.\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div style=\u0026#34;margin-left:1em\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a name=\u0026#34;{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;div style=\u0026#34;margin-left:1em\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;itemizedlist\u0026#34;\u0026gt; \u0026lt;ul style=\u0026#34;margin-left:1em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;orderedlist\u0026#34;\u0026gt; \u0026lt;ol style=\u0026#34;margin-left:1em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ol\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;listitem\u0026#34;\u0026gt; \u0026lt;li style=\u0026#34;text-indent:0.5em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;programlisting\u0026#34;\u0026gt; \u0026lt;pre style=\u0026#34;color:blue;background-color:rgb(200,200,200); margin-left:1em\u0026#34;\u0026gt;\u0026lt;code\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;para\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;name(..) = \u0026#39;listitem\u0026#39;\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt;\u0026lt;p\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;title\u0026#34; /\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Le premier élément « xsl:template » sert à capturer l\u0026rsquo;élément « book ». Comme il s\u0026rsquo;agit de l\u0026rsquo;élément-racine, on en profite pour produire les éléments « html », « head » et « body ». Le contenu de l\u0026rsquo;élément « head » sera rempli par l\u0026rsquo;élément « xsl:template » traitant l\u0026rsquo;élément DocBook « bookinfo ». On affiche immédiatement le prénom et le nom de l\u0026rsquo;auteur à l\u0026rsquo;aide des expressions XPath « bookinfo/author/firstname » et « bookinfo/author/surname ». Notez l\u0026rsquo;utilisation de l\u0026rsquo;élément xsl:text \u0026lt;/xsl:text\u0026gt; pour produire un espace entre le nom et le prénom. En effet, sans cet élément, il n\u0026rsquo;y aurait pas d\u0026rsquo;espace puisque les espaces et retours de charriot sont ignorés dans les fichiers XSLT. Le reste du document est produit avec les deux éléments « xsl:template » traitant les éléments « chapter » : on utilise le l\u0026rsquo;attribut mode « tdm » pour produire la table des matières, et le reste du document est produit avec le traitement des éléments « chapter » par défaut (sans attribut mode).\n\u0026lt;xsl:template match=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;bookinfo\u0026#34;/\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;bookinfo/title\u0026#34; /\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p style=\u0026#34;text-indent:1em;\u0026#34;\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/author/firstname\u0026#34; /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/author/surname\u0026#34; /\u0026gt; \u0026amp;#169; \u0026lt;xsl:value-of select=\u0026#34;bookinfo/copyright/year\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;h2\u0026gt;Table des matières\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;chapter\u0026#34; mode=\u0026#34;tdm\u0026#34;/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;chapter\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; L\u0026rsquo;élément « xsl:template » traitant l\u0026rsquo;élément DocBook « bookinfo » est simple : l\u0026rsquo;expression XPath « title » permet de trouver le titre du document puisqu\u0026rsquo;un élément « title » doit être présent dans tout élément DocBook « bookinfo ». Comme on l\u0026rsquo;a fait précédemment, on trouve le prénom et le nom de l\u0026rsquo;auteur, mais cette fois-ci, avec les expressions XPath « author/firstname » et « author/surname » puisque nous sommes maintenant au sein d\u0026rsquo;un élément « bookinfo ».\n\u0026lt;xsl:template match=\u0026#34;bookinfo\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt; par \u0026lt;xsl:value-of select=\u0026#34;author/firstname\u0026#34; /\u0026gt;\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt;\u0026lt;xsl:value-of select=\u0026#34;author/surname\u0026#34; /\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/xsl:template\u0026gt; Les élément « xsl:template » avec attribut mode génèrent la table des matières. Les éléments « xsl:number » permettent de numéroter automatiquement les chapitres et sections. Afin de générer des hyperliens permettant de naviguer dans le document à partir de la table des matières, on utilise des fragments générés à partir de la fonction XSLT « generate-id ». Lorsque nous générons le contenu du document lui-même, on utilise à nouveau la fonction XSLT « generate-id » pour placer des ancres dans le document au bon endroit. L\u0026rsquo;avantage de la fonction XSLT « generate-id » est qu\u0026rsquo;elle permet de générer facilement un identifiant unique pour chaque paragraphe.\n\u0026lt;xsl:template match=\u0026#34;chapter\u0026#34; mode=\u0026#34;tdm\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\u0026#34;section\u0026#34; mode=\u0026#34;tdm\u0026#34;/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;section\u0026#34; mode=\u0026#34;tdm\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; Les élément « xsl:template » sans attribut mode génèrent le document lui-même. La principale différence avec la génération de la table des matières est la présence de l\u0026rsquo;élément xsl:apply-templates/ qui traite le contenu des éléments « section ».\n\u0026lt;xsl:template match=\u0026#34;chapter\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;a name=\u0026#34;{generate-id(.)}\u0026#34; \u0026gt;Chapitre \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;.\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div style=\u0026#34;margin-left:1em\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates select=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a name=\u0026#34;{generate-id(.)}\u0026#34;\u0026gt; \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;chapter\u0026#34;/\u0026gt;. \u0026lt;xsl:number format=\u0026#34;digit\u0026#34; lang=\u0026#34;fr\u0026#34; count=\u0026#34;section\u0026#34;/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\u0026#34;title\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;div style=\u0026#34;margin-left:1em\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; Le traitement des éléments DocBook « itemizedlist », « orderedlist » et « listitem » est simple : il suffit de les convertir en éléments HTML « ul », « ol » et « li » respectivement.\n\u0026lt;xsl:template match=\u0026#34;itemizedlist\u0026#34;\u0026gt; \u0026lt;ul style=\u0026#34;margin-left:1em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;orderedlist\u0026#34;\u0026gt; \u0026lt;ol style=\u0026#34;margin-left:1em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ol\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\u0026#34;listitem\u0026#34;\u0026gt; \u0026lt;li style=\u0026#34;text-indent:0.5em\u0026#34;\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; Les éléments DocBook « programlisting » sont convertis en éléments HTML « pre » ( préformaté ).\n\u0026lt;xsl:template match=\u0026#34;programlisting\u0026#34;\u0026gt; \u0026lt;pre style=\u0026#34;color:blue;background-color:rgb(200,200,200); margin-left:1em\u0026#34;\u0026gt; \u0026lt;code\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/xsl:template\u0026gt; Les éléments DocBook « para » sont convertis en éléments HTML « p » sauf lorsqu\u0026rsquo;ils sont au sein d\u0026rsquo;un élément DocBook « listitem ».\n\u0026lt;xsl:template match=\u0026#34;para\u0026#34;\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\u0026#34;name(..) = \u0026#39;listitem\u0026#39;\u0026#34;\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt;\u0026lt;p\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Les éléments DocBook « title » ne doivent pas être traités directement lorsqu\u0026rsquo;on les rencontre.\n\u0026lt;xsl:template match=\u0026#34;title\u0026#34; /\u0026gt; "},{"id":110,"href":"/orientee_donnees/docs/extra/glossaire/","title":"Glossaire","section":"Contenu suppplémentaire","content":" Glossaire # Appel d’entité\nUn appel d’entité est une suite de caractères qui commence par une esperluette (\u0026amp;) et se termine par un point-virgule (;). Les entités courantes :\nEntité Résultat \u0026amp;amp;lt; \u0026lt; \u0026amp;amp;amp; \u0026amp; \u0026amp;amp;gt; \u0026gt; \u0026amp;amp;quot; \u0026quot; \u0026amp;amp;apos; ’ Attribut\nUn attribut est un nom XML qui suit les mêmes règles que les noms d’éléments. Il est immédiatement suivi d’un signe = et d’une valeur entre guillemets. Exemple : \u0026lt;lavie age=\u0026quot;5\u0026quot;\u0026gt; a l’attribut age=\u0026quot;5\u0026quot;. Une balise peut avoir plusieurs attributs, mais leurs noms doivent être distincts.\nBalise\nUne balise commence par \u0026lt; et se termine par \u0026gt;. Il existe : balises ouvrantes (\u0026lt;tag\u0026gt;), fermantes (\u0026lt;/tag\u0026gt;) et vides (\u0026lt;tag/\u0026gt;). Les déclarations \u0026lt;!DOCTYPE\u0026gt;, les instructions \u0026lt;?xml?\u0026gt;, les commentaires \u0026lt;!-- --\u0026gt; et les sections \u0026lt;![CDATA[ ]]\u0026gt; ne sont pas des balises d’élément.\nBien formé\nUn document XML est bien formé s’il respecte la grammaire XML (p. ex. éléments correctement imbriqués, attributs bien formés). Tout parseur XML générique peut lire un document bien formé.\nCommentaire\nCommence par \u0026lt;!-- et se termine par --\u0026gt;. On ne peut pas avoir deux tirets consécutifs -- à l’intérieur d’un commentaire.\nCSS — Cascading Style Sheets.\nDéclaration de type de document (DOCTYPE)\nUne déclaration DOCTYPE a la forme \u0026lt;!DOCTYPE racine SYSTEM \u0026quot;URL\u0026quot;\u0026gt;. Elle indique le nom de l’élément racine attendu et (optionnellement) l’emplacement du DTD.\nDéfinitions et mots-clés utiles # CDATA : type d’attribut indiquant que la valeur est du texte. #PCDATA : contenu textuel (parsed character data). REQUIRED : attribut obligatoire. IMPLIED : attribut optionnel. Espace de noms (Namespace) Un espace de noms permet d\u0026rsquo;éviter les conflits de noms dans les documents XML en associant un préfixe à un URI. Exemple : xmlns:prefix=\u0026quot;http://example.com\u0026quot;.\nÉlément\nUn élément est une unité de structure XML, composée d\u0026rsquo;une balise ouvrante, de contenu (texte, éléments enfants) et d\u0026rsquo;une balise fermante. Exemple : \u0026lt;livre\u0026gt;Titre\u0026lt;/livre\u0026gt;.\nÉlément vide\nUn élément sans contenu, représenté par \u0026lt;tag/\u0026gt; ou \u0026lt;tag\u0026gt;\u0026lt;/tag\u0026gt;.\nEntité\nUne entité est un raccourci pour du texte ou des caractères spéciaux. Les entités prédéfinies sont \u0026amp;lt;, \u0026amp;gt;, \u0026amp;amp;, \u0026amp;quot;, \u0026amp;apos;.\nInstruction de traitement\nUne instruction pour les applications, de la forme \u0026lt;?nom instruction?\u0026gt;. Exemple : \u0026lt;?xml-stylesheet type=\u0026quot;text/xsl\u0026quot; href=\u0026quot;style.xsl\u0026quot;?\u0026gt;.\nParseur XML\nUn programme qui analyse un document XML et vérifie sa conformité à la syntaxe XML.\nRacine (Root)\nL\u0026rsquo;élément principal d\u0026rsquo;un document XML, qui contient tous les autres éléments.\nSchéma XML (XSD)\nUn langage pour définir la structure et les types de données d\u0026rsquo;un document XML, plus puissant que la DTD.\nSection CDATA\nUne section \u0026lt;![CDATA[ contenu ]]\u0026gt; où le contenu n\u0026rsquo;est pas analysé comme du XML, utile pour du code ou du texte spécial.\nValide\nUn document XML est valide s\u0026rsquo;il est bien formé et respecte les règles définies dans une DTD ou un schéma.\nXPath\nUn langage pour naviguer dans les documents XML, utilisé dans XSLT et XQuery.\nXQuery\nUn langage de requête pour extraire des données des documents XML.\nXSD — XML Schema Definition.\nFormats de données populaires # YAML # YAML (YAML Ain\u0026rsquo;t Markup Language) est un format de sérialisation de données lisible par l\u0026rsquo;humain, souvent utilisé pour les fichiers de configuration. Il s\u0026rsquo;appuie sur l\u0026rsquo;indentation pour représenter la structure.\nExemple :\nperson: name: \u0026#34;Alice\u0026#34; age: 30 tags: - xml - yaml YAML est pratique pour écrire des structures arborescentes sans beaucoup de ponctuation. Attention à l\u0026rsquo;indentation (espaces, pas de tabulations) et au typage implicite (ex. on, yes, no, true, false peuvent être interprétés).\nJSON # JSON (JavaScript Object Notation) est un format léger d\u0026rsquo;échange de données, très répandu pour les API et la configuration. Il est strict sur la syntaxe (guillemets, virgules, crochets).\nExemple :\n{ \u0026#34;person\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;tags\u0026#34;: [\u0026#34;xml\u0026#34;, \u0026#34;json\u0026#34;] } } JSON est facile à parser et largement supporté par les langages. Quand on convertit entre XML, JSON et YAML, il faut décider comment représenter les attributs, les éléments vides et l\u0026rsquo;ordre des nœuds.\nJSON Schema\nUn vocabulaire et une grammaire pour valider la structure et les types de données dans un document JSON. Permet de définir des contraintes comme les types requis, les formats, etc.\nYAML Anchor\nUn mécanisme en YAML pour définir une référence réutilisable avec \u0026amp;nom et la référencer avec *nom. Utile pour éviter la duplication.\nYAML Alias\nVoir YAML Anchor. Permet de réutiliser des structures complexes.\nYAML Merge\nUne fonctionnalité YAML pour fusionner des mappings avec \u0026lt;\u0026lt;: *ancre.\nYAML Multi-line strings\nUtilise | pour conserver les sauts de ligne, ou \u0026gt; pour les fusionner en une ligne.\nAutres notions # DOM (Document Object Model)\nUne interface de programmation pour les documents HTML et XML. Représente le document comme une arborescence d\u0026rsquo;objets, permettant la manipulation via des API comme getElementById(), appendChild(), etc.\nSAX (Simple API for XML)\nUne API événementielle pour parser les documents XML. Au lieu de charger tout le document en mémoire (comme DOM), SAX déclenche des événements pour chaque élément rencontré, ce qui est plus efficace pour les gros fichiers.\nAPI de parsing\nInterfaces pour analyser et traiter les documents structurés : DOM pour une vue arborescente, SAX pour un parsing séquentiel, StAX pour un mélange des deux.\nSérialisation\nLe processus de conversion d\u0026rsquo;une structure de données en un format textuel comme JSON, YAML ou XML.\nDésérialisation\nL\u0026rsquo;inverse de la sérialisation : convertir un format textuel en structure de données.\nStreaming parser\nUn parseur qui traite le document de manière incrémentale, sans charger tout en mémoire, utile pour les gros fichiers.\nTree parser\nUn parseur qui construit une arborescence complète en mémoire, comme DOM.\nXPath\nUn langage pour adresser des parties d\u0026rsquo;un document XML, permettant de naviguer et sélectionner des nœuds.\nXSLT\nUn langage pour transformer les documents XML en d\u0026rsquo;autres formats, comme HTML ou texte.\nNamespace URI\nL\u0026rsquo;identifiant unique associé à un espace de noms XML, généralement une URL.\nPréfixe d\u0026rsquo;espace de noms\nUn raccourci pour référencer un espace de noms, comme xmlns:xs=\u0026quot;http://www.w3.org/2001/XMLSchema\u0026quot;.\nXML Schema (XSD)\nVoir Schéma XML.\nDTD (Document Type Definition)\nUn langage pour définir la structure d\u0026rsquo;un document XML, moins puissant que XSD mais plus simple.\nWell-formed vs Valid\nWell-formed : respecte la syntaxe XML. Valid : well-formed et conforme à une DTD ou schéma.\nEncoding\nLe jeu de caractères utilisé, spécifié dans la déclaration XML, comme UTF-8.\nBOM (Byte Order Mark)\nUn marqueur au début des fichiers pour indiquer l\u0026rsquo;endianness, parfois présent dans les fichiers UTF.\nDéclaration XML : La déclaration XML ressemble à s’y méprendre à une instruction de traitement et prend la forme \u0026lt; ?xml ... ?\u0026gt;. Le contenu d’une déclaration XML comporte généralement au maximum trois attributs : version=\"...\", encoding=\"...\" et standalone=\"...\". La version du XML la plus utilisée est la 1.0 ; bien que la version 1.1 existe, elle est fort peu utilisée. On utilisera souvent une déclaration XML avec « encoding=\"ISO-8859-1\" » pour pouvoir utiliser les accents dans le document ; par défaut, on ne peut pas utiliser les accents dans un document XML, sans des outils supportant les normes UTF-8/UTF-16. L’attribut « standalone » prend les valeurs yes ou no , selon que l’on veut que la DTD externe soit lue ou pas. La déclaration XML doit obligatoirement être au tout début du document ou être carrément absente : même un espace avant n’est pas permis. DocBook : C’est un format de document souvent utilisé pour la documentation technique. DOM ( Document Object Model ) : Le terme « DOM » a deux significations : un ensemble d’API utilisant un modèle en arbre ou un certain modèle en arbre. DTD ( Définition de Type Document ) : Une DTD permet de définir un type de document XML en spécifiant des contraintes sur les éléments, les attributs et leur contenu. Un document XML qui satisfait ces contraintes et qui est bien formé est dit valable. Élément : Un élément est l’ensemble du texte borné par deux balises ayant le même nom XML, comme \u0026lt;lavie\u0026gt; et \u0026lt;/lavie\u0026gt;. On dit que l’élément \u0026lt;lavie\u0026gt;\u0026lt;/lavie\u0026gt; a le nom XML « lavie ». L’élément hérite des attributs de sa balise de départ : l’élément \u0026lt;lavie age=\"5\"\u0026gt;\u0026lt;/lavie\u0026gt; possède l’attribut « age=\"5\" ». Il est à noter que la casse est significative en XML : les balises \u0026lt; A \u0026gt; et \u0026lt; a \u0026gt; n’ont pas le même nom XML. Lorsque l’élément est vide, c’est-à-dire sans contenu, on peut remplacer \u0026lt;lavie\u0026gt;\u0026lt;/lavie\u0026gt; par \u0026lt;lavie /\u0026gt;, pour être plus bref. Par ailleurs, un élément peut contenir d’autres éléments, comme dans \u0026lt;lavie\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/lavie\u0026gt;, ou du texte ou du texte et des éléments, comme \u0026lt;lavie\u0026gt;fd\u0026lt;a\u0026gt;fsd\u0026lt;/a\u0026gt;fd\u0026lt;/lavie\u0026gt;. Si un élément contient l’élément de début ou de fin d’un élément, alors il doit aussi contenir l’autre. Ainsi, un élément peut être contenu par un autre ou non, mais deux éléments ne peuvent se chevaucher , comme \u0026lt;b\u0026gt;\u0026lt;a\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/a\u0026gt;, qui est du XML mal formé. Élément-racine : Tout document XML bien formé doit avoir un élément-racine, et un seul. Tous les autres éléments doivent être contenus dans cet élément-racine. Espace de noms : Les espaces de noms permettent d’utiliser plusieurs vocabulaires XML en même temps. Extensible : Voir Métalangage . Graphe : Un graphe est un ensemble de nœuds liés par des relations d’un nœud à un autre. Graphe dirigé : Un graphe est dirigé si les relations sont à sens unique. Graphe annoté : Un graphe est annoté si les relations entre deux nœuds peuvent être de différentes natures. HTML ( HyperText Markup Language ) : Le HTML est un langage à base de balises. La majorité des documents sur le web sont écrits en HTML. Instruction de traitement : L’instruction de traitement ne fait rien en soit, mais peut indiquer aux programmes comment obtenir un certain résultat. Une instruction de traitement débute par « \u0026lt; ? » et se termine par « ?\u0026gt; » ; immédiatement après le « \u0026lt; ? », un nom XML valable doit apparaître et tous les noms XML valables sont autorisés à l’exception de xml, Xml, XMl, XML, XmL, xMl, xML et xmL. Ainsi n’importe quel autre texte peut être utilisé, mais il faut faire des appels d’entités pour « \u0026lt; » et « \u0026amp; », comme pour n’importe quel contenu textuel XML. Métalangage : Le XML est un « métalangage » permettant d’échanger de l’information, principalement sur le web. On dit que c’est un « métalangage » parce qu’il permet de créer de nouveaux langages pour l’échange d’informations, mais qu’il ne constitue pas un langage en soi. On dit donc que le XML est « extensible » (peut être étendu) et que c’est un métalangage : les deux affirmations ont le même sens et notent la capacité du XML à s’adapter à des besoins différents. Nom XML : Le nom XML d’une balise est le texte suivant le symbole « \u0026lt; » ou « \u0026lt;/ » pour une balise de fin ; il peut contenir n’importe quelle lettre (a, b,...) ou chiffre (0,1,2,...) et les signes de ponctuation suivants : la barre de soulignement ( _ ), le trait d’union ( - ) et le point ( . ) ; il ne peut contenir ni les autres signes de ponctuation ni un espace. En outre, un nom XML ne peut pas commencer par un nombre, un trait d’union ou un point. Par exemple, le nom XML de la balise \u0026lt;lavie\u0026gt; est « lavie », alors que la balise \u0026lt;7lavie\u0026gt; ne serait pas autorisée. RDF ( Resource Description Framework ) : Le RDF est un langage pour les métadonnées sur le web, c’est-à-dire un langage pour énoncer ce que l’on sait sur quelque chose ou quelqu’un. SGML : Standard Generalized Markup Language . Syntaxe : La syntaxe XML est la manière d’écrire les informations dans un document XML. Les notions importantes de la syntaxe de base du XML sont la balise , l’ élément , l’ élément-racine et l’ attribut . URI : C’est une adresse Internet fictive. L’URI agit un peu comme le numéro d’assurance sociale des vocabulaires XML. Valide : : Un document est valide s’il répond à certains critères de base de l’application XML. Un document XML qui est bien formé, qui en plus satisfait aux contraintes dictant quels éléments et attributs peuvent être utilisés, et dans quel ordre et avec quel contenu, est dit valide. Vocabulaire XML : Un « vocabulaire XML » est un ensemble de noms de balises et d’attributs ayant une signification donnée. Un vocabulaire XML peut être associé à un document DTD. XHTML : Le XHTML est un format hybride : il tient à la fois du HTML et du XML. XML : eXtensible MarkupLanguage . XSL : eXtensible Stylesheet Language . XSLT : XSL Transformations . XSL-FO : eXtensible Stylesheet Language Formatting Objects . "},{"id":111,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/laboratoire_xslt/","title":"Laboratoire XSLT","section":"XSLT","content":" Laboratoire XSLT Vous pouvez maintenant expérimenter avec un document XSLT un peu plus sophistiqué. Vous trouverez sur cette page un document DocBook et sa transformation. Nous vous invitons à modifier la transformation et le document XML d'origine afin de vous assurez que vous maîtrisez bien le XSLT. Instructions : il suffit de saisir un fichier XML source et une transformation XSLT valide et d'appuyer sur le bouton. Instructions : Saisissez un fichier XML source et une transformation XSLT valide, puis cliquez sur « Transformer ». Vous pouvez réinitialiser les champs avec le bouton « Réinitialiser ». Fichier XML : \u0026lt;book\u0026gt; \u0026lt;bookinfo\u0026gt; \u0026lt;title\u0026gt;Notre documentation\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt; \u0026lt;firstname\u0026gt;Alexis\u0026lt;/firstname\u0026gt; \u0026lt;surname\u0026gt;Letrotteur\u0026lt;/surname\u0026gt; \u0026lt;/author\u0026gt; \u0026lt;copyright\u0026gt;\u0026lt;year\u0026gt;2004\u0026lt;/year\u0026gt;\u0026lt;holder\u0026gt;Bell Canada\u0026lt;/holder\u0026gt;\u0026lt;/copyright\u0026gt; \u0026lt;/bookinfo\u0026gt; \u0026lt;chapter\u0026gt; \u0026lt;title\u0026gt;Premier chapitre\u0026lt;/title\u0026gt; \u0026lt;section\u0026gt; \u0026lt;title\u0026gt;Première section du premier chapitre\u0026lt;/title\u0026gt; \u0026lt;para\u0026gt;Mettre ici le premier paragraphe de la première section.\u0026lt;/para\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/book\u0026gt; Transformation XSLT : \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:output method=\"html\" indent=\"yes\" encoding=\"ISO-8859-1\" /\u0026gt; \u0026lt;xsl:template match=\"book\"\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;xsl:apply-templates select=\"bookinfo\"/\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;\u0026lt;xsl:value-of select=\"bookinfo/title\" /\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p style=\"text-indent:1em;\"\u0026gt; \u0026lt;xsl:value-of select=\"bookinfo/author/firstname\" /\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\"bookinfo/author/surname\" /\u0026gt; © \u0026lt;xsl:value-of select=\"bookinfo/copyright/year\" /\u0026gt; \u0026lt;/p\u0026gt;\u0026lt;h2\u0026gt;Table des matières\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\"chapter\" mode=\"tdm\"/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;xsl:apply-templates select=\"chapter\"/\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"bookinfo\"\u0026gt; \u0026lt;title\u0026gt;\u0026lt;xsl:value-of select=\"title\" /\u0026gt; par \u0026lt;xsl:value-of select=\"author/firstname\" /\u0026gt;\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt;\u0026lt;xsl:value-of select=\"author/surname\" /\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"chapter\" mode=\"tdm\"\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\"#{generate-id(.)}\"\u0026gt; \u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"chapter\"/\u0026gt;. \u0026lt;xsl:value-of select=\"title\" /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;ul\u0026gt;\u0026lt;xsl:apply-templates select=\"section\" mode=\"tdm\"/\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"section\" mode=\"tdm\"\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\"#{generate-id(.)}\"\u0026gt; \u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"chapter\"/\u0026gt;.\u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"section\"/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\"title\" /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"chapter\"\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;a name=\"{generate-id(.)}\" \u0026gt;Chapitre \u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"chapter\"/\u0026gt;.\u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\"title\" /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;div style=\"margin-left:1em\"\u0026gt; \u0026lt;xsl:apply-templates select=\"section\"/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"section\"\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a name=\"{generate-id(.)}\"\u0026gt; \u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"chapter\"/\u0026gt;.\u0026lt;xsl:number format=\"digit\" lang=\"fr\" count=\"section\"/\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;xsl:value-of select=\"title\" /\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;div style=\"margin-left:1em\"\u0026gt; \u0026lt;xsl:apply-templates/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"itemizedlist\"\u0026gt; \u0026lt;ul style=\"margin-left:1em\"\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"orderedlist\"\u0026gt; \u0026lt;ol style=\"margin-left:1em\"\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/ol\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"listitem\"\u0026gt; \u0026lt;li style=\"text-indent:0.5em\"\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"programlisting\"\u0026gt; \u0026lt;pre style=\"color:blue;background-color:rgb(200,200,200); margin-left:1em\"\u0026gt; \u0026lt;code\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt; \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"para\"\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\"name(..) = 'listitem'\"\u0026gt; \u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise\u0026gt;\u0026lt;p\u0026gt;\u0026lt;xsl:apply-templates /\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/xsl:otherwise\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"title\" /\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Résultat : émotion Erreur : Veuillez vérifier votre XML ou XSLT. Transformer Réinitialiser "},{"id":112,"href":"/orientee_donnees/docs/extra/pense-bete_xml/","title":"Pense-bête XML","section":"Contenu suppplémentaire","content":"Pense-bête XML Quelques symboles importants en DTD # \u003c!DOCTYPE nomXML_elementRacine SYSTEM \"URL\"\u003e Déclaration de type de document.\n\u003c!ELEMENT ... \u003e Déclaration d\u0026rsquo;un élément (instruction DTD).\n? — Élément optionnel.\n* — Élément pouvant être présent plusieurs fois (0..∞).\n+ — Élément présent au moins une fois (1..∞).\n| — Alternative (ou).\n#PCDATA — Contenu textuel (parsed character data).\n\u003c!ATTLIST nomElementX nomAttributY ...\u003e Spécifie qu’un élément nomElementX possède l’attribut nomAttributY.\nCDATA — Type d’attribut indiquant que l’attribut contient du texte.\nREQUIRED — Attribut obligatoire.\nIMPLIED — Attribut optionnel (pas de valeur par défaut).\nFIXED — Attribut fixé à une valeur constante.\n\u003c!ENTITY nomEntiteX \"Yvaleur\"\u003e Définit une entité nommée nomEntiteX qui vaut Yvaleur.\nNote : j\u0026rsquo;ai remplacé valeurY par Yvaleur dans l\u0026rsquo;exemple pour éviter une répétition maladroite du mot \u0026ldquo;valeur\u0026rdquo;.\n\u003c!ENTITY % nomEntiteX \"Yvaleur\"\u003e Entité paramètre pour la DTD (locale à la DTD) — nomEntiteX prend la valeur Yvaleur.\nÉléments essentiels du XML # Déclaration XML # \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Déclaration obligatoire au début d\u0026rsquo;un document XML. Spécifie la version XML et l\u0026rsquo;encodage des caractères.\nÉléments # Les éléments sont les blocs de construction principaux du XML. Ils sont délimités par des balises.\ncontenu : Élément avec contenu. : Élément vide (auto-fermant). Attributs # Les attributs fournissent des informations supplémentaires sur les éléments.\n: Attribut avec valeur. Contenu textuel # Le texte entre les balises est le contenu de l\u0026rsquo;élément.\n#PCDATA : Données de caractères analysées (texte normal). Sections CDATA # \u003c![CDATA[ contenu ]]\u003e Permet d\u0026rsquo;inclure du texte qui ne doit pas être analysé comme du XML (par exemple, du code HTML ou JavaScript).\nCommentaires # Les commentaires sont ignorés par le parseur XML.\nInstructions de traitement # \u003c?nom instruction?\u003e Instructions pour les applications, comme \u003c?xml-stylesheet type=\"text/xsl\" href=\"style.xsl\"?\u003e pour lier une feuille de style XSL.\nEntités # Les entités permettent de définir des raccourcis pour du texte ou des caractères spéciaux.\n\u0026amp;entite; : Référence à une entité. Entités prédéfinies : \u0026lt; (\u0026lt;), \u0026gt; (\u0026gt;), \u0026amp; (\u0026amp;), \u0026quot; (\u0026quot;), ' (\u0026rsquo;). Espaces de noms (Namespaces) # Permettent d\u0026rsquo;éviter les conflits de noms dans les documents XML.\nxmlns:prefix=\u0026ldquo;URI\u0026rdquo; : Déclaration d\u0026rsquo;un espace de noms. prefix:element : Utilisation d\u0026rsquo;un élément dans un espace de noms. Règles de bien-formé (Well-formed) # Un document XML est bien-formé s\u0026rsquo;il respecte la syntaxe XML :\nUn élément racine unique. Balises correctement imbriquées et fermées. Attributs uniques par élément. Valeurs d\u0026rsquo;attributs entre guillemets. Validation # DTD (Document Type Definition) : Définit la structure autorisée du document. XML Schema (XSD) : Alternative plus puissante à la DTD pour la validation. Exemples rapides # \u0026lt;!DOCTYPE livre SYSTEM \u0026#34;livre.dtd\u0026#34;\u0026gt; \u0026lt;!ELEMENT livre (titre, auteur+, chapitre*)\u0026gt; \u0026lt;!ATTLIST chapitre numero CDATA #REQUIRED\u0026gt; \u0026lt;!ENTITY entiteExemple \u0026#34;Valeur de l\u0026#39;entite\u0026#34;\u0026gt; Ces exemples montrent la syntaxe de base pour déclarer un DTD et des éléments/attributs.\n"},{"id":113,"href":"/orientee_donnees/docs/extra/pense-bete_json/","title":"Pense-bête JSON","section":"Contenu suppplémentaire","content":" Pense-bête JSON # Types de données en JSON # Objet Structure de données clé-valeur, délimitée par des accolades {}.\nTableau Liste ordonnée de valeurs, délimitée par des crochets [].\nChaîne de caractères Texte entre guillemets doubles \u0026quot;texte\u0026quot;. Peut inclure des caractères d\u0026rsquo;échappement comme \\\u0026quot;, \\\\, \\/, \\b, \\f, \\n, \\r, \\t, \\uXXXX.\nNombre Valeur numérique, entière ou décimale, sans guillemets. Exemples : 123, 12.34, -56.\nBooléen Valeurs true ou false.\nNull Valeur nulle représentée par null.\nSyntaxe de base # Objet : {\u0026quot;clé\u0026quot;: \u0026quot;valeur\u0026quot;, \u0026quot;clé2\u0026quot;: 123} Les clés sont des chaînes, les valeurs peuvent être de n\u0026rsquo;importe quel type JSON.\nTableau : [\u0026quot;valeur1\u0026quot;, \u0026quot;valeur2\u0026quot;, 123] Liste de valeurs séparées par des virgules.\nImbrication : Les objets et tableaux peuvent être imbriqués. Exemple : {\u0026quot;utilisateur\u0026quot;: {\u0026quot;nom\u0026quot;: \u0026quot;Dupont\u0026quot;, \u0026quot;âges\u0026quot;: [25, 30]}}\nRègles de syntaxe # Clés uniques : Dans un objet, chaque clé doit être unique. Virgules : Séparent les paires clé-valeur dans les objets et les valeurs dans les tableaux. Pas de virgule après le dernier élément. Guillemets : Les clés et les chaînes doivent être entre guillemets doubles. Pas de commentaires : JSON ne supporte pas les commentaires nativement. Encodage : Généralement en UTF-8. Échappement et caractères spéciaux # \\\u0026quot; : Guillemet double \\\\ : Barre oblique inverse \\/ : Barre oblique \\b : Retour arrière \\f : Saut de page \\n : Nouvelle ligne \\r : Retour chariot \\t : Tabulation \\uXXXX : Caractère Unicode (XXXX en hexadécimal) Validation et outils # JSON valide : Doit respecter la syntaxe stricte. Utilisez des validateurs en ligne ou des bibliothèques comme jsonlint. JSON Schema : Spécification pour valider la structure des documents JSON. Parsing : En JavaScript, utilisez JSON.parse() pour analyser, JSON.stringify() pour sérialiser. Exemples rapides # { \u0026#34;livre\u0026#34;: { \u0026#34;titre\u0026#34;: \u0026#34;Exemple de livre\u0026#34;, \u0026#34;auteurs\u0026#34;: [\u0026#34;Auteur1\u0026#34;, \u0026#34;Auteur2\u0026#34;], \u0026#34;chapitres\u0026#34;: [ {\u0026#34;numero\u0026#34;: 1, \u0026#34;titre\u0026#34;: \u0026#34;Introduction\u0026#34;}, {\u0026#34;numero\u0026#34;: 2, \u0026#34;titre\u0026#34;: \u0026#34;Contenu\u0026#34;} ] } } Cet exemple montre un objet JSON imbriqué avec des chaînes, tableaux et objets.\n"},{"id":114,"href":"/orientee_donnees/docs/extra/pense-bete_yaml/","title":"Pense-bête YAML","section":"Contenu suppplémentaire","content":"Pense-bête YAML Types de données en YAML # Scalaires Valeurs simples : chaînes, nombres, booléens, null.\nMappings (Dictionnaires) Paires clé-valeur, équivalents aux objets JSON.\nSéquences (Listes) Listes ordonnées de valeurs.\nChaînes Texte simple ou entre guillemets. Supporte les multi-lignes.\nNombres Entiers ou décimaux : 123, 12.34.\nBooléens true, false, yes, no, on, off.\nNull null, ~, ou vide.\nSyntaxe de base # Mappings :\nclé: valeur clé2: valeur2 : Utilise l\u0026rsquo;indentation pour la structure.\nSéquences :\n- élément1 - élément2 - élément3 : Liste avec des tirets.\nImbrication :\nutilisateur: nom: Dupont âges: - 25 - 30 : Combinez mappings et séquences.\nRègles de syntaxe # Indentation : Utilise des espaces (pas de tabulations). 2 espaces par niveau recommandés. Clés : Sensibles à la casse. Peuvent être entre guillemets si nécessaire. Valeurs : Types inférés automatiquement. Commentaires : # Commentaire (ignorés). Multi-lignes : | pour conserver les sauts de ligne, \u0026gt; pour les fusionner. Ancres et alias : \u0026amp;ancre pour définir, *ancre pour référencer. Échappement et caractères spéciaux # Guillemets doubles \u0026quot; pour les chaînes avec caractères spéciaux. Guillemets simples ' pour les chaînes littérales. Échappement avec \\ dans les guillemets doubles. Fonctionnalités avancées # Types explicites : !!str \u0026quot;texte\u0026quot;, !!int 123, etc. Documents multiples : Séparés par ---. Fusion : \u0026lt;\u0026lt;: *ancre pour fusionner mappings. Ensembles : !!set {clé1: null, clé2: null}. Validation et outils # YAML valide : Respecte l\u0026rsquo;indentation et la syntaxe. Utilisez des validateurs comme yamllint. Conversion : Facilement convertible en JSON ou autres formats. Parsing : En Python, utilisez pyyaml ; en JavaScript, js-yaml. Exemples rapides # livre: titre: \u0026#34;Exemple de livre\u0026#34; auteurs: - Auteur1 - Auteur2 chapitres: - numero: 1 titre: \u0026#34;Introduction\u0026#34; - numero: 2 titre: \u0026#34;Contenu\u0026#34; Cet exemple montre un mapping imbriqué avec des séquences et des scalaires.\n"},{"id":115,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/laboratoire_xslt_avec_python_optionnel/","title":"Laboratoire XSLT avec Python (optionnel)","section":"XSLT","content":" Laboratoire XSLT avec Python (optionnel) Rendez vous sur le site xsltpy qui comprend une petite application Python capable de traiter du XSLT et du XML. Suivez les consignes. "},{"id":116,"href":"/orientee_donnees/docs/extra/professeur/","title":"Professeur","section":"Contenu suppplémentaire","content":" À propos du professeur # Daniel Lemire est professeur d\u0026rsquo;informatique à l\u0026rsquo;Université TÉLUQ. Il a aussi été un chercheur au conseil national de recherche du Canada et un entrepreneur. Il est l\u0026rsquo;auteur de plus de 80 publications arbitrées, incluant plus de 55 articles parus dans des revues internationales. Il a écrit plusieurs livres. Il détient des subventions de recherche depuis plus de 20 ans. Il est éditeur de la revue Software : Practice and Experience, fondée en 1971. Il participe aux comités scientifiques de plusieurs conférences prestigieuses en informatique (par exemple, ACM CIKM, WWW, ACM WSDM, ACM SIGIR, ACM RecSys). Ses logiciels sont utilisés par de grandes sociétés comme Google et Facebook. En 2020 et 2021, Daniel Lemire était co-président du comité informatique du CRSNG. Il a reçu le prix d\u0026rsquo;excellence de l\u0026rsquo;Université du Québec 2020 en recherche et création pour une réalisation en recherche (tous secteurs confondus) concernant ses travaux sur l\u0026rsquo;accélération du traitement des fichiers JSON. Il est parmi les 2% de scientifiques les plus cités au monde selon le classement de l\u0026rsquo;Université Stanford.\nÀ lire : Les géants du numérique raffolent des algorithmes de ce prof québécois (Journal de Montréal).\nQuelques-uns des travaux de Daniel Lemire # Avec Geoff Langdale, John Keiser, Paul Dreik et d\u0026rsquo;autres, il est l\u0026rsquo;auteur de la bibliothèque JSON la plus rapide au monde : simdjson. C\u0026rsquo;est la première bibliothèque capable de parser plusieurs gigaoctets de JSON par seconde. Elle est utilisée par de nombreux systèmes importants tels que Meta Velox, le runtime Node.js, ClickHouse, WatermelonDB, Apache Doris, Milvus, StarRocks. En 2024, l\u0026rsquo;article On-demand JSON: A better way to parse documents? a été l\u0026rsquo;article le plus lu des cinq dernières années dans la revue Software: Practice and Experience.\nAvec Yagiz Nizipli et d\u0026rsquo;autres, il est l\u0026rsquo;auteur d\u0026rsquo;Ada URL parser, le parseur d\u0026rsquo;URL de Node.js et des Cloudflare Workers. Nous pensons qu\u0026rsquo;il s\u0026rsquo;agit du parseur conforme WHATWG le plus rapide au monde. Leur article de 2024 dans Software: Practice and Experience est le quatrième article le plus lu des cinq dernières années selon l\u0026rsquo;éditeur (Wiley). Avec Robert Clausecker, Wojciech Muła, John Keiser, Paul Dreik et d\u0026rsquo;autres, il a écrit la bibliothèque simdutf, la bibliothèque la plus rapide au monde pour le transcodage Unicode et le base64. Elle accélère deux des principaux runtimes JavaScript (Node.js et Bun). Elle fait également partie de WebKit, le moteur derrière le navigateur Safari, et de Chromium, le moteur derrière Google Chrome et Microsoft Edge. L\u0026rsquo;algorithme de validation UTF-8 qu\u0026rsquo;il a conçu avec Keiser est également intégré à l\u0026rsquo;interpréteur PHP et à de nombreuses bibliothèques standard.\nIl a joué un rôle déterminant dans la conception de l\u0026rsquo;algorithme de parsing de nombres le plus rapide au monde. Avec des collaborateurs, il a écrit la bibliothèque fast_float qui fait partie de GCC. Elle est également présente dans WebKit, le moteur de Safari, le navigateur web d\u0026rsquo;Apple. Elle a aussi été adoptée par Chromium, le moteur derrière Google Chrome et Microsoft Edge. Cette approche de parsing des nombres est intégrée aux bibliothèques runtime de Go, C# et Rust. Elle est utilisée dans MySQL. Pour la première fois, elle a permis de parser des nombres à plus d\u0026rsquo;un gigaoctet par seconde.\nIl a conçu le format Roaring bitmap comme format d\u0026rsquo;index bitmap efficace. Ce format est devenu un standard. Il est utilisé par Apache Lucene et les systèmes dérivés tels que Solr et Elasticsearch, Apache Druid, etc. Le moteur SQL de YouTube, Google Procella, utilise les Roaring bitmaps pour l\u0026rsquo;indexation. Avec des ingénieurs comme Richard Startin, il a contribué de manière déterminante à de nombreuses implémentations, notamment RoaringBitmap (Java), roaring (Go) et CRoaring (C et C++).\n"},{"id":117,"href":"/orientee_donnees/docs/modules/a_module_json/travail/","title":"Travail noté","section":"Module JSON","content":" Travail noté # Question 1 : Application Java avec Gson et GeoJSON # Dans ce premier travail, vous développerez une application Java utilisant la bibliothèque Gson pour manipuler des données GeoJSON. Pour démontrer l\u0026rsquo;utilité de votre travail, vous utiliserez le fichier GeoJSON suivant comme base, qui représente des lieux emblématiques du Québec :\n{ \u0026#34;type\u0026#34;: \u0026#34;FeatureCollection\u0026#34;, \u0026#34;features\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Mont Royal\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;montagne\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Montagne emblématique de Montréal\u0026#34; }, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Point\u0026#34;, \u0026#34;coordinates\u0026#34;: [-73.5878, 45.5017] } }, { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Fleuve Saint-Laurent\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;rivière\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Principal fleuve du Québec\u0026#34; }, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;LineString\u0026#34;, \u0026#34;coordinates\u0026#34;: [ [-73.5, 45.5], [-71.2, 46.8], [-69.5, 48.4] ] } }, { \u0026#34;type\u0026#34;: \u0026#34;Feature\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Parc national de la Jacques-Cartier\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;parc\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Parc national dans la région de Québec\u0026#34; }, \u0026#34;geometry\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Polygon\u0026#34;, \u0026#34;coordinates\u0026#34;: [[ [-72.0, 47.0], [-71.5, 47.0], [-71.5, 47.5], [-72.0, 47.5], [-72.0, 47.0] ]] } } ] } Votre application devra impérativement implémenter les fonctionnalités suivantes :\nCharger le fichier GeoJSON fourni et afficher le nombre total de features. Ajouter une nouvelle feature de type Point représentant un lieu d\u0026rsquo;intérêt de votre choix (par exemple, un monument ou un bâtiment historique du Québec). Filtrer et afficher uniquement les features dont la catégorie est \u0026ldquo;parc\u0026rdquo;. Calculer et afficher des statistiques : nombre de points, nombre de lignes, nombre de polygones. Sauvegarder les données modifiées (avec la nouvelle feature ajoutée) dans un nouveau fichier GeoJSON nommé \u0026ldquo;quebec_modifie.geojson\u0026rdquo;. Votre code devra être organisé selon les bonnes pratiques Java, utiliser Maven pour la gestion des dépendances Gson, inclure une documentation complète sous forme de commentaires, et gérer les erreurs potentielles de manière appropriée.\nRessources : Consultez la documentation officielle de Gson pour la sérialisation et désérialisation JSON : https://github.com/google/gson/blob/main/UserGuide.md\nLivrables : Code source Java, fichier pom.xml, fichier GeoJSON d\u0026rsquo;exemple, et un README en Markdown expliquant comment exécuter le projet.\nQuestion 2 : Script jq pour l\u0026rsquo;analyse de données JSON # Pour ce deuxième travail, vous créerez un ensemble de scripts jq permettant d\u0026rsquo;analyser et transformer des données JSON complexes représentant un catalogue de produits. Vous commencerez par utiliser le fichier JSON suivant comme base de données, qui représente un inventaire de produits électroniques :\n{ \u0026#34;store\u0026#34;: \u0026#34;Électronique Québec\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;Montréal\u0026#34;, \u0026#34;products\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Ordinateur portable\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;informatique\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Dell\u0026#34;, \u0026#34;price\u0026#34;: 1299.99, \u0026#34;stock\u0026#34;: 15, \u0026#34;rating\u0026#34;: 4.5, \u0026#34;features\u0026#34;: [\u0026#34;16GB RAM\u0026#34;, \u0026#34;512GB SSD\u0026#34;, \u0026#34;Intel i7\u0026#34;] }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Smartphone\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;mobile\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Samsung\u0026#34;, \u0026#34;price\u0026#34;: 899.99, \u0026#34;stock\u0026#34;: 25, \u0026#34;rating\u0026#34;: 4.2, \u0026#34;features\u0026#34;: [\u0026#34;128GB\u0026#34;, \u0026#34;Android\u0026#34;, \u0026#34;5G\u0026#34;] }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;Casque audio\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;audio\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Sony\u0026#34;, \u0026#34;price\u0026#34;: 199.99, \u0026#34;stock\u0026#34;: 8, \u0026#34;rating\u0026#34;: 4.8, \u0026#34;features\u0026#34;: [\u0026#34;Bluetooth\u0026#34;, \u0026#34;Noise cancelling\u0026#34;, \u0026#34;30h autonomie\u0026#34;] }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Tablette\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;mobile\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;price\u0026#34;: 599.99, \u0026#34;stock\u0026#34;: 12, \u0026#34;rating\u0026#34;: 4.6, \u0026#34;features\u0026#34;: [\u0026#34;10 pouces\u0026#34;, \u0026#34;iOS\u0026#34;, \u0026#34;Face ID\u0026#34;] }, { \u0026#34;id\u0026#34;: 5, \u0026#34;name\u0026#34;: \u0026#34;Clavier mécanique\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;informatique\u0026#34;, \u0026#34;brand\u0026#34;: \u0026#34;Logitech\u0026#34;, \u0026#34;price\u0026#34;: 149.99, \u0026#34;stock\u0026#34;: 20, \u0026#34;rating\u0026#34;: 4.3, \u0026#34;features\u0026#34;: [\u0026#34;Switches rouges\u0026#34;, \u0026#34;RGB\u0026#34;, \u0026#34;USB-C\u0026#34;] } ], \u0026#34;last_updated\u0026#34;: \u0026#34;2024-12-29\u0026#34; } Vos scripts jq devront impérativement implémenter les fonctionnalités suivantes :\nExtraire et afficher la liste de tous les noms de produits. Filtrer et afficher uniquement les produits de catégorie \u0026ldquo;mobile\u0026rdquo;. Calculer et afficher des statistiques : nombre total de produits, valeur totale du stock (prix × stock), moyenne des notes. Transformer les données pour créer un résumé simplifié de chaque produit (id, name, price, stock). Créer un pipeline jq qui génère un rapport formaté en texte avec les produits en rupture de stock (stock ≤ 10). Enfin, vous intégrerez des mécanismes de validation pour vérifier que les fichiers d\u0026rsquo;entrée sont des objets JSON valides avec une structure de produits.\nRessources : Consultez la documentation officielle de jq pour les opérations de traitement JSON : https://jqlang.org/manual/\nLivrables : Scripts jq (.jq), fichier JSON d\u0026rsquo;exemple, et un fichier README en Markdown avec des exemples d\u0026rsquo;exécution et d\u0026rsquo;explication des scripts.\n"},{"id":118,"href":"/orientee_donnees/docs/modules/d_module_html/travail/","title":"Travail noté","section":"Module HTML, CSS, SVG, MathML","content":" Travail noté # Question 1 : Expressions mathématiques avec MathML et CSS # Dans ce premier travail, vous créerez des expressions mathématiques complexes en utilisant MathML (Mathematical Markup Language) et les mettrez en forme avec du CSS spécifique à MathML. Vous développerez une page web présentant différentes formules mathématiques avec une mise en forme élégante.\nVoici la structure HTML de base que vous devez utiliser :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Mathématiques avec MathML\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* C\u0026#39;est à vous d\u0026#39;implémenter le CSS spécifique à MathML ici */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Formules Mathématiques avec MathML\u0026lt;/h1\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Équation quadratique\u0026lt;/h2\u0026gt; \u0026lt;math display=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;=\u0026lt;/mo\u0026gt; \u0026lt;mfrac\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mo\u0026gt;−\u0026lt;/mo\u0026gt; \u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;±\u0026lt;/mo\u0026gt; \u0026lt;msqrt\u0026gt; \u0026lt;msup\u0026gt; \u0026lt;mi\u0026gt;b\u0026lt;/mi\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;/msup\u0026gt; \u0026lt;mo\u0026gt;−\u0026lt;/mo\u0026gt; \u0026lt;mn\u0026gt;4\u0026lt;/mn\u0026gt; \u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt; \u0026lt;mi\u0026gt;c\u0026lt;/mi\u0026gt; \u0026lt;/msqrt\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;mi\u0026gt;a\u0026lt;/mi\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;/mfrac\u0026gt; \u0026lt;/math\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h2\u0026gt;Intégrale\u0026lt;/h2\u0026gt; \u0026lt;math display=\u0026#34;block\u0026#34;\u0026gt; \u0026lt;mrow\u0026gt; \u0026lt;msubsup\u0026gt; \u0026lt;mo\u0026gt;∫\u0026lt;/mo\u0026gt; \u0026lt;mn\u0026gt;0\u0026lt;/mn\u0026gt; \u0026lt;mi\u0026gt;π\u0026lt;/mi\u0026gt; \u0026lt;/msubsup\u0026gt; \u0026lt;msup\u0026gt; \u0026lt;mi\u0026gt;sin\u0026lt;/mi\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;/msup\u0026gt; \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;ⅆ\u0026lt;/mo\u0026gt; \u0026lt;mi\u0026gt;x\u0026lt;/mi\u0026gt; \u0026lt;mo\u0026gt;=\u0026lt;/mo\u0026gt; \u0026lt;mfrac\u0026gt; \u0026lt;mi\u0026gt;π\u0026lt;/mi\u0026gt; \u0026lt;mn\u0026gt;2\u0026lt;/mn\u0026gt; \u0026lt;/mfrac\u0026gt; \u0026lt;/mrow\u0026gt; \u0026lt;/math\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Vous devez créer un CSS qui améliore la présentation des expressions MathML avec les propriétés suivantes :\nÉlément math :\nfont-family: 'Times New Roman', serif; pour une police mathématique appropriée font-size: 18px; pour une taille lisible line-height: 1.4; pour un espacement confortable Fractions (mfrac) :\npadding: 2px 0; pour espacer la fraction Utiliser border-top: 1px solid #000; sur le numérateur pour créer la barre de fraction margin: 4px 0; pour séparer visuellement numérateur et dénominateur Variables (mi) :\nfont-style: italic; pour différencier les variables color: #2E7D32; pour une couleur verte distinctive font-weight: normal; pour les maintenir lisibles Opérateurs (mo) :\ncolor: #1976D2; pour une couleur bleue font-weight: bold; pour les mettre en valeur padding: 0 2px; pour les espacer des autres éléments Constantes numériques (mn) :\ncolor: #D32F2F; pour une couleur rouge font-weight: bold; pour les distinguer font-variant-numeric: tabular-nums; pour un alignement uniforme Ressources :\nSpécification MathML : https://www.w3.org/TR/MathML3/ Guide MathML MDN : https://developer.mozilla.org/fr/docs/Web/MathML Livrables : Page HTML complète avec MathML et CSS, et documentation des choix de mise en forme.\nQuestion 2 : Graphiques vectoriels avec SVG et CSS # Dans ce deuxième travail, vous créerez des graphiques vectoriels complexes en utilisant SVG (Scalable Vector Graphics) et les mettrez en forme avec du CSS spécifique à SVG. Vous développerez une visualisation de données statistiques avec animations et interactions.\nVoici la structure HTML de base que vous devez utiliser :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Visualisation de données avec SVG\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* C\u0026#39;est à vous d\u0026#39;implémenter le CSS spécifique à SVG ici */ \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Visualisation de données avec SVG\u0026lt;/h1\u0026gt; \u0026lt;svg width=\u0026#34;600\u0026#34; height=\u0026#34;400\u0026#34; viewBox=\u0026#34;0 0 600 400\u0026#34;\u0026gt; \u0026lt;!-- Titre --\u0026gt; \u0026lt;text x=\u0026#34;300\u0026#34; y=\u0026#34;30\u0026#34; class=\u0026#34;title\u0026#34;\u0026gt;Ventes mensuelles 2024\u0026lt;/text\u0026gt; \u0026lt;!-- Axes --\u0026gt; \u0026lt;line x1=\u0026#34;50\u0026#34; y1=\u0026#34;350\u0026#34; x2=\u0026#34;550\u0026#34; y2=\u0026#34;350\u0026#34; class=\u0026#34;axis\u0026#34;/\u0026gt; \u0026lt;line x1=\u0026#34;50\u0026#34; y1=\u0026#34;50\u0026#34; x2=\u0026#34;50\u0026#34; y2=\u0026#34;350\u0026#34; class=\u0026#34;axis\u0026#34;/\u0026gt; \u0026lt;!-- Barres du graphique --\u0026gt; \u0026lt;rect x=\u0026#34;70\u0026#34; y=\u0026#34;250\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;100\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;rect x=\u0026#34;130\u0026#34; y=\u0026#34;200\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;150\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;150\u0026#34;/\u0026gt; \u0026lt;rect x=\u0026#34;190\u0026#34; y=\u0026#34;180\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;170\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;170\u0026#34;/\u0026gt; \u0026lt;rect x=\u0026#34;250\u0026#34; y=\u0026#34;220\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;130\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;130\u0026#34;/\u0026gt; \u0026lt;rect x=\u0026#34;310\u0026#34; y=\u0026#34;160\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;190\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;190\u0026#34;/\u0026gt; \u0026lt;rect x=\u0026#34;370\u0026#34; y=\u0026#34;190\u0026#34; width=\u0026#34;40\u0026#34; height=\u0026#34;160\u0026#34; class=\u0026#34;bar\u0026#34; data-value=\u0026#34;160\u0026#34;/\u0026gt; \u0026lt;!-- Étiquettes des mois --\u0026gt; \u0026lt;text x=\u0026#34;90\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Jan\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;150\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Fév\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;210\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Mar\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;270\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Avr\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;330\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Mai\u0026lt;/text\u0026gt; \u0026lt;text x=\u0026#34;390\u0026#34; y=\u0026#34;375\u0026#34; class=\u0026#34;label\u0026#34;\u0026gt;Jun\u0026lt;/text\u0026gt; \u0026lt;!-- Points de données animés --\u0026gt; \u0026lt;circle cx=\u0026#34;90\u0026#34; cy=\u0026#34;240\u0026#34; r=\u0026#34;5\u0026#34; class=\u0026#34;data-point\u0026#34;/\u0026gt; \u0026lt;circle cx=\u0026#34;150\u0026#34; cy=\u0026#34;190\u0026#34; r=\u0026#34;5\u0026#34; class=\u0026#34;data-point\u0026#34;/\u0026gt; \u0026lt;circle cx=\u0026#34;210\u0026#34; cy=\u0026#34;170\u0026#34; r=\u0026#34;5\u0026#34; class=\u0026#34;data-point\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Consignes spécifiques pour le CSS SVG :\nVous devez créer un CSS qui améliore la présentation du graphique SVG avec les propriétés suivantes :\nTitre (.title) :\ntext-anchor: middle; pour centrer le texte font-family: Arial, sans-serif; pour une police élégante font-size: 18px; pour une taille appropriée font-weight: bold; pour le mettre en valeur Axes (.axis) :\nstroke: #333; pour une couleur sombre stroke-width: 2; pour une épaisseur visible Barres (.bar) :\nfill: linear-gradient(to top, #4CAF50, #81C784); pour un dégradé vert stroke: #2E7D32; pour une bordure plus foncée stroke-width: 1; pour une bordure fine Au survol : fill: linear-gradient(to top, #66BB6A, #A5D6A7); pour éclaircir Étiquettes (.label) :\ntext-anchor: middle; pour centrer sous les barres font-size: 12px; pour une petite police fill: #666; pour une couleur discrète Points de données (.data-point) :\nopacity: 0; pour les rendre invisibles par défaut fill: #FF5722; pour une couleur orange visible Au survol des barres : opacity: 1; avec transition: opacity 0.3s ease; Ressources :\nSpécification SVG : https://www.w3.org/TR/SVG2/ Guide SVG MDN : https://developer.mozilla.org/fr/docs/Web/SVG Livrables : Page HTML complète avec SVG et CSS, et documentation des choix de mise en forme.\n"},{"id":119,"href":"/orientee_donnees/docs/modules/e_module_services/travail/","title":"Travail noté","section":"Module Services et YAML","content":" Travail noté # Question 1 : Service web REST avec JSON # Dans ce premier travail, vous créerez un service web REST simple en Java qui fournit des données JSON. Vous développerez un serveur qui expose plusieurs endpoints REST pour gérer des ressources.\nVoici la structure Java de base que vous devez utiliser :\nimport com.sun.net.httpserver.HttpServer; import com.sun.net.httpserver.HttpExchange; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.util.*; public class ServeurREST { private static List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; ressources = new ArrayList\u0026lt;\u0026gt;(); private static int nextId = 2; // Prochain ID disponible static { // Initialiser avec quelques données de test Map\u0026lt;String, Object\u0026gt; item1 = new HashMap\u0026lt;\u0026gt;(); item1.put(\u0026#34;id\u0026#34;, 1); item1.put(\u0026#34;nom\u0026#34;, \u0026#34;Exemple 1\u0026#34;); item1.put(\u0026#34;valeur\u0026#34;, 42); ressources.add(item1); } public static void main(String[] args) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0); // Endpoint GET /api/ressources - Liste toutes les ressources server.createContext(\u0026#34;/api/ressources\u0026#34;, exchange -\u0026gt; { if (\u0026#34;GET\u0026#34;.equals(exchange.getRequestMethod())) { try { // C\u0026#39;est à vous d\u0026#39;implémenter la logique pour retourner la liste en JSON String jsonResponse = \u0026#34;[]\u0026#34;; // Placeholder byte[] response = jsonResponse.getBytes(\u0026#34;UTF-8\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=UTF-8\u0026#34;); exchange.getResponseHeaders().set(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;); exchange.sendResponseHeaders(200, response.length); try (OutputStream os = exchange.getResponseBody()) { os.write(response); } } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else if (\u0026#34;POST\u0026#34;.equals(exchange.getRequestMethod())) { // C\u0026#39;est à vous d\u0026#39;implémenter la logique pour ajouter une ressource exchange.sendResponseHeaders(201, -1); } else { exchange.sendResponseHeaders(405, -1); } }); // Endpoint GET /api/ressources/{id} - Ressource spécifique server.createContext(\u0026#34;/api/ressources/\u0026#34;, exchange -\u0026gt; { String path = exchange.getRequestURI().getPath(); String idStr = path.substring(path.lastIndexOf(\u0026#39;/\u0026#39;) + 1); if (\u0026#34;GET\u0026#34;.equals(exchange.getRequestMethod())) { try { // C\u0026#39;est à vous d\u0026#39;implémenter la logique pour retourner une ressource spécifique exchange.sendResponseHeaders(404, -1); // Placeholder } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else if (\u0026#34;PUT\u0026#34;.equals(exchange.getRequestMethod())) { try { // C\u0026#39;est à vous d\u0026#39;implémenter la logique pour modifier une ressource exchange.sendResponseHeaders(200, -1); // Placeholder } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else if (\u0026#34;DELETE\u0026#34;.equals(exchange.getRequestMethod())) { try { // C\u0026#39;est à vous d\u0026#39;implémenter la logique pour supprimer une ressource exchange.sendResponseHeaders(204, -1); // Placeholder } catch (Exception e) { exchange.sendResponseHeaders(500, -1); } } else { exchange.sendResponseHeaders(405, -1); } }); server.setExecutor(null); server.start(); System.out.println(\u0026#34;Serveur REST démarré sur http://localhost:8080/\u0026#34;); } } Vous devez compléter la logique métier dans chaque endpoint en utilisant Gson pour la manipulation JSON :\nGET /api/ressources : Retourner la liste complète des ressources en JSON GET /api/ressources/{id} : Retourner une ressource spécifique (404 si inexistante) POST /api/ressources : Ajouter une nouvelle ressource avec validation des données PUT /api/ressources/{id} : Modifier une ressource existante (404 si inexistante) DELETE /api/ressources/{id} : Supprimer une ressource (404 si inexistante) Vous devez utiliser la bibliothèque Gson pour la manipulation JSON.\nRessources :\nGuide REST API : https://restfulapi.net/ Java HttpServer : https://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html Livrables : Code Java complet du serveur REST, et documentation des endpoints.\nQuestion 2 : Correction d\u0026rsquo;un fichier YAML # Voici un fichier YAML défaillant que vous devez corriger :\ninvalid_yaml: true person: name: Alice age: 30 jobs: - developer - manager color: red color: blue bad_mapping: {key: value, another: value description: Ceci est une description: avec des deux-points non protégés numbers: - 1 - 2 - 3 Expliquez les erreurs.\n"},{"id":120,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/xslt_20_et_30/","title":"XSLT 2.0 et 3.0","section":"XSLT","content":" XSLT 2.0 et 3.0 Nous nous sommes concentrés sur la version 1.0 du XSLT car elle est la plus répandue et la mieux supportée. Une nouvelle version du XSLT est disponible, nommée XSLT 2.0. Elle ajoute notamment la possibilité de générer plusieurs documents plutôt qu'un seul avec l'instruction xslt:result-document. On peut aussi traiter non seulement des fichiers XML, mais aussi d'autres types de fichiers dont les fichiers CSV (comma-separated values) générés par les chiffriers électroniques et bases de données. L'instruction « xsl:analyze-string » permet de prendre appui sur les nouvelles possibilités du traitement des chaînes de caractères de XPath 2.0. L'instruction « xsl:function » permet quant à elle de définir de nouvelles fonctions qui pourront être utilisées au sein des expressions XPath. L'instruction « xsl:for-each-group » permet de visiter les nœuds par groupes : on peut ainsi visiter tous les éléments etudiant en les regroupant selon la valeur de leur attribut nom. Elliotte Rusty Harold a publié une page sur XSLT 2.0 qui présente quelques exemples. La version 3.0 du XSLT permet de traiter de grands volumes de données en évitant le chargement en mémoire de la totalité des documents. À cette fin, elle introduit des instructions comme xsl:iterate et xsl:stream. "},{"id":121,"href":"/orientee_donnees/docs/modules/c_module_xslt/xslt/autoevaluation_xslt/","title":"Autoévaluation","section":"XSLT","content":" Autoévaluation Questionnaire d'autoévaluation Le bouton « Vérifier ma réponse » donne accès à un script qui, en plus de vous permettre de vérifier vos réponses, fournit une courte explication. Si tous les commentaires sont en bleu , c'est que vous avez la bonne réponse; sinon, lisez les commentaires en rouge pour comprendre votre erreur. Puis, essayez de nouveau en cliquant sur le bouton « Recommencer ». Question 1 . Parmi les suivants, quels sont les documents XSLT corrects? Choisissez toutes les réponses qui s'appliquent, puis appuyez sur le bouton « Vérifier ma réponse ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:text\u0026gt; \u0026lt;/xsl:text\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Oui, c'est correct : le résultat sera un document vide (contenant un espace). \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; Non. Ce n'est pas un document XML bien formé, car il n'y a pas d'élément-racine. Un document XSLT doit être un document XML bien formé. \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:text xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt;\u0026lt;/xsl:text\u0026gt; Non. Bien qu'il s'agisse d'un document XML bien formé, l'élément-racine « text » n'est pas autorisé, il devrait être « transform » ou bien « stylesheet ». \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:transform xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;/xsl:transform\u0026gt; Oui. Il s'agit d'un document XML bien formé et l'élément-racine est « transform », ce qui est autorisé. Question 2 . Étant donné le document XML suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;source\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Graton\u0026lt;/nom\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/source\u0026gt; et le fichier XSLT suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version = '1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'\u0026gt; \u0026lt;xsl:template match=\"employe\"\u0026gt; \u0026lt;b\u0026gt; \u0026lt;xsl:value-of select=\".\"/\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"prenom\"\u0026gt; \u0026lt;i\u0026gt; \u0026lt;xsl:value-of select=\".\"/\u0026gt; \u0026lt;/i\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Qu'est-ce qui s'affichera à l'écran? Choisissez la bonne réponse parmi les suivantes. Jean Graton (Réponse correcte!) Effectivement. Le modèle « employe » sera utilisé, mais pas le modèle « prenom ». Il y aura bel et bien un espace entre « Jean » et « Graton », parce qu'il y a un retour de chariot entre les éléments « prenom » et « nom ». Par défaut, les espaces et les retours de chariot entre les éléments ne sont pas ignorés dans le document XML qui est traité, mais ils le sont dans le document XSLT. Un retour de chariot, en HTML ou XHTML, s'affiche à l'écran comme un espace. JeanGraton (Réponse incorrecte!) Non. L'instruction « value-of » va reproduire le contenu de l'élément, moins les balises, mais en respectant les espaces entre les éléments. Il n'y aurait pas d'espace entre les éléments si le document XML avait pris le forme « \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt;\u0026lt;nom\u0026gt;Graton\u0026lt;/nom\u0026gt; » (sans espace entre les deux éléments). Jean Graton (Réponse incorrecte!) Non. Le modèle « prénom » n'est pas utilisé. Jean Graton (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé; le texte sera donc en caractères gras. Jean Graton (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé; il n'y aura donc pas d'italique. Jean Graton (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé; on n'aura donc pas un mélange de texte normal et de texte en caractères gras. Rien (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé et « value-of » donnera le contenu textuel sans les balises. Jean (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé; on n'aura donc pas de texte en italique. Graton (Réponse incorrecte!) Non. Le modèle « employe » sera utilisé; « value-of » sélectionne tout le texte, et non seulement « Graton ». Question 3 . Étant donné le document XML suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;source\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Graton\u0026lt;/nom\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/source\u0026gt; et le fichier XSLT suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version = '1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'\u0026gt; \u0026lt;xsl:template match=\"employe\"\u0026gt; \u0026lt;b\u0026gt; \u0026lt;xsl:apply-templates select=\"prenom\"/\u0026gt; \u0026lt;/b\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"prenom\"\u0026gt; \u0026lt;i\u0026gt; \u0026lt;xsl:value-of select=\".\"/\u0026gt; \u0026lt;/i\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Qu'est-ce qui s'affichera à l'écran? Choisissez la bonne réponse parmi les suivantes. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Rien (Réponse incorrecte!) Non. Jean (Réponse correcte!) Effectivement. Le modèle « employe » est appelé et lui-même appelle le modèle « prenom ». Graton (Réponse incorrecte!) Non. Question 4 . Étant donné le document XML suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;source\u0026gt; \u0026lt;employe\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Graton\u0026lt;/nom\u0026gt; \u0026lt;/employe\u0026gt; \u0026lt;/source\u0026gt; et le fichier XSLT suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version = '1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'\u0026gt; \u0026lt;xsl:template match=\"prenom\"\u0026gt; \u0026lt;i\u0026gt; \u0026lt;xsl:value-of select=\".\"/\u0026gt; \u0026lt;/i\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Qu'est-ce qui s'affichera à l'écran? Choisissez la bonne réponse parmi les suivantes. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse incorrecte!) Non. Jean Graton (Réponse correcte!) Effectivement. Comme il n'y a pas de modèle pour l'élément « nom », le modèle par défaut s'applique et le contenu du texte est reproduit. Par contre, le modèle « prenom » est utilisé. Rien (Réponse incorrecte!) Non. Jean (Réponse incorrecte!) Non. Graton (Réponse incorrecte!) Non. Question 5 . Étant donné le document XML suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;budget\u0026gt; \u0026lt;item montant=\"50 $\"\u0026gt; \u0026lt;titre\u0026gt;lait\u0026lt;/titre\u0026gt; \u0026lt;description\u0026gt;Je dois acheter beaucoup de lait.\u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;item montant=\"20 $\"\u0026gt; \u0026lt;titre\u0026gt;pomme de terre\u0026lt;/titre\u0026gt; \u0026lt;description\u0026gt;Même si la pomme de terre est mauvaise pour la santé, je dois en acheter beaucoup.\u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/budget\u0026gt; et le fichier XSLT suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"budget\"\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;xsl:apply-templates select=\"item\" /\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"item\"\u0026gt; \u0026lt;li\u0026gt; \u0026lt;xsl:value-of select=\"titre\" /\u0026gt; (\u0026lt;xsl:value-of select=\"@montant\" /\u0026gt;) \u0026lt;/li\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Qu'est-ce qui s'affichera à l'écran? Choisissez la bonne réponse parmi les suivantes. lait (50 $) pomme de terre (Réponse incorrecte!) Non. Le modèle « budget » s'applique; il doit y avoir création d'une liste. lait (50 $) pomme de terre (20 $) (Réponse correcte!) Effectivement. Le modèle « budget » s'applique et il y a création d'une liste. lait (50 $)Je dois acheter beaucoup de lait. pomme de terre (20 $)Même si la pomme de terre est mauvaise pour la santé, je dois en acheter beaucoup. (Réponse incorrecte!) Non. Les éléments « item » sont traités par le modèle « item » qui n'inclut pas l'élément « description ». Question 6 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;xsl:apply-templates select=\".\" mode=\"a\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"*\" mode=\"a\"\u0026gt; \u0026lt;xsl:apply-templates select=\".\" mode=\"b\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"*\" mode=\"b\"\u0026gt; \u0026lt;xsl:value-of select=\".\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il va produire la liste des balises des documents XML. (Réponse incorrecte!) Non. Au contraire, car « value-of » enlève toutes les balises. Il va produire des documents vides. (Réponse incorrecte!) Non. Le modèle « b » s'applique. Il va produire des versions des documents XML, mais sans les balises. (Réponse correcte!) Exactement. Le modèle « b » s'applique, après l'application du modèle par défaut et du modèle « a ». Ce document XSLT n'est pas valide. (Réponse incorrecte!) Il s'agit d'un document XSLT valide. Ce document XSLT est valide, mais ne pourra pas s'exécuter. (Réponse incorrecte!) L'utilisation de « mode » est effectivement dangereuse et peut mener à des boucles sans fin, mais ce n'est pas le cas pour ce document. Question 7 . Si on applique le document XSLT suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;xsl:value-of select=\"count(cours)\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; au document XML suivant... \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?\u0026gt; \u0026lt;universite\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 102 Introduction avancée\u0026lt;/nom\u0026gt; \u0026lt;lien\u0026gt;\u0026lt;cours\u0026gt;INF 101 Introduction\u0026lt;/cours\u0026gt;\u0026lt;/lien\u0026gt; \u0026lt;description\u0026gt;Un cours d'introduction à l'informatique pour futurs ingénieurs.\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 101 Introduction\u0026lt;/nom\u0026gt; \u0026lt;description\u0026gt;Un cours d'introduction à l'informatique pour les étudiants en éducation.\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;cours\u0026gt;\u0026lt;nom\u0026gt;INF 103 Java\u0026lt;/nom\u0026gt; description\u0026gt;Un cours d'introduction au Java\u0026lt;/description\u0026gt;\u0026lt;/cours\u0026gt; \u0026lt;/universite\u0026gt; Quel sera le résultat? Choisissez la bonne réponse parmi les suivantes. Le chiffre « 1 ». (Réponse incorrecte!) Le modèle compte le nombre d'éléments « cours » dans l'élément-racine et il y a plus d'un élément « cours ». Le chiffre « 2 ». (Réponse incorrecte!) Le modèle compte le nombre d'éléments « cours » dans l'élément-racine et il y a plus de deux éléments « cours ». Le chiffre « 3 ». (Réponse correcte!) Comme le modèle « * » ne s'applique qu'à l'élément-racine qui contient 3 éléments « cours », le résultat sera effectivement le chiffre 3. Le chiffre « 4 ». (Réponse incorrecte!) Il y a bien 4 éléments « cours », mais le modèle « * » ne s'applique qu'à l'élément-racine qui lui contient 3 éléments « cours ». Un document vide. (Réponse incorrecte!) Non. L'instruction « \u0026lt;xsl:value-of select=\"count(cours)\"/\u0026gt; » sera exécutée et le résultat doit être un nombre. Question 8 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;xsl:value-of select=\"name(.)\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le nom de tous les éléments dans le document. (Réponse incorrecte!) Le modèle « * » ne s'applique qu'à l'élément-racine. Il donne le nom de tous les éléments et attributs dans le document. (Réponse incorrecte!) Le modèle « * » ne s'applique qu'à l'élément-racine et la fonction « name », appliquée à un élément, ne donne que le nom de l'élément. Il donne le nom de l'élément-racine. (Réponse correcte!) C'est vrai. Le modèle « * » ne s'applique qu'à l'élément-racine. Il donne le nom de l'élément-racine et de tout attribut qu'il pourrait avoir. (Réponse incorrecte!) La fonction « name » appliquée à un élément ne donne que le nom de l'élément. Question 9 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"cours|universite\"\u0026gt; \u0026lt;xsl:value-of select=\"name(.)\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le contenu textuel (sans les balises) de tous les éléments « cours » ou « universite » du document XML. (Réponse incorrecte!) Non. Si un élément « cours » ou « universite » est rencontré, seul son nom s'affiche. Il donne « cours » si l'élément-racine est de type « cours ». (Réponse incorrecte!) Il donne « cours » ou « universite », autant de fois qu'il y a d'éléments « cours » ou « universite » dans le document, et rien d'autre. (Réponse incorrecte!) Non. La règle par défaut s'applique aux autres éléments et leur contenu textuel sera affiché. Il donne « cours » ou « universite », autant de fois qu'il y a d'éléments « cours » ou « universite » dans le document, et le contenu textuel de tous les autres éléments qui ne sont pas contenus dans un élément « cours » ou dans un élément « université ». (Réponse correcte!) Exactement. La règle par défaut s'applique à tous les éléments, sauf aux éléments « cours » dont on ne visite pas les nœuds. Question 10 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:value-of select=\"name(*)\" /\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le nom de tous les éléments contenus dans l'élément-racine. (Réponse incorrecte!) Non, car « / » est le nœud-racine (le document lui-même) et non pas l'élément-racine. Il donne le nom de l'élément-racine. (Réponse correcte!) Effectivement, car « / » est le nœud-racine (le document lui-même) qui ne contient qu'un seul élément : l'élément-racine. Il donne le nom de tous les éléments du document XML. (Réponse incorrecte!) Non. Comme nous avons une règle qui est appliquée au nœud-racine, le traitement du processeur XSLT va s'arrêter immédiatement après l'application du seul modèle contenu dans le document XSLT. Question 11 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; [\u0026lt;xsl:value-of select=\"generate-id(.)\" /\u0026gt;] \u0026lt;xsl:apply-templates select=\"*\" /\u0026gt; \u0026lt;xsl:apply-templates select=\"*\" mode=\"a\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;xsl:template match=\"*\" mode=\"a\"\u0026gt; [\u0026lt;xsl:value-of select=\"generate-id(.)\" /\u0026gt;]\u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne une liste d'identifiants, un et un seul identifiant pour chaque élément du document XML. Il n'y a pas deux identifiants égaux. (Réponse incorrecte!) Non. À cause de l'utilisation du « mode », certains identifiants sont répétés deux fois. Il donne une liste d'identifiants, chacun étant répété deux fois. (Réponse incorrecte!) Non. Pour l'élément-racine, il n'est pas répété deux fois. Il donne une liste d'identifiants dont certains sont répétés deux fois. (Réponse correcte!) Oui. Ils sont tous répétés deux fois, sauf pour l'élément-racine. Question 12 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;xsl:choose\u0026gt; \u0026lt;xsl:when test=\"name(.)='universite'\" \u0026gt; \u0026lt;xsl:apply-templates select=\"*\" /\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:when test=\"name(.)='cours'\" \u0026gt; \u0026lt;xsl:value-of select=\"nom\" /\u0026gt; \u0026lt;/xsl:when\u0026gt; \u0026lt;xsl:otherwise /\u0026gt; \u0026lt;/xsl:choose\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le contenu textuel de tous les éléments « nom » immédiatement contenus dans des éléments « cours » (Réponse incorrecte!) Non. Si un élément « cours » était contenu dans un autre élément « cours », il ne serait jamais visité. Il donne le contenu textuel de tous les éléments « nom » immédiatement contenus dans des éléments « cours », eux-mêmes immédiatement contenus dans des éléments « universite ». (Réponse incorrecte!) Non. Si l'élément « universite » n'est pas l'élément-racine, il ne sera jamais visité. Il donne un document vide. (Réponse incorrecte!) Seulement si les éléments « cours » rencontrés dans les éléments « universite » n'ont pas de contenu textuel dans leurs éléments « nom ». Il donne le contenu textuel de tous les éléments « nom » immédiatement contenus dans des éléments « cours », eux-mêmes immédiatement contenus dans l'élément-racine « universite ». (Réponse correcte!) Effectivement. Il n'y a qu'un seul cas où d'autres éléments que l'élément-racine sont visités et c'est lorsque l'élément-racine est l'élément « universite ». Question 13 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;xsl:if test=\"count(.)=1\" \u0026gt; \u0026lt;xsl:value-of select=\"name(.)\" /\u0026gt; \u0026lt;xsl:apply-templates select=\"*\" /\u0026gt; \u0026lt;/xsl:if\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le nom de tous les éléments. (Réponse correcte!) Effectivement, car « . » n'est que l'élément courant (donc un ensemble d'un seul élément); « count(.) » vaut donc « 1 ». Il donne le nom de l'élément-racine. (Réponse incorrecte!) Oui, mais aussi le nom des autres éléments. Il donne un document vide. (Réponse incorrecte!) Comme « count(.) » vaut toujours « 1 », c'est plutôt le nom de tous les éléments qui est donné. Question 14 . Qu'est-ce qui décrit le mieux le document XSLT suivant? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"*\"\u0026gt; \u0026lt;a valeur=\"{name(.)}\"\u0026gt; \u0026lt;xsl:apply-templates select=\"*\" /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Il donne le document XML original, où les éléments ont tous été remplacés par des éléments de nom « a ». (Réponse incorrecte!) Non. Le contenu textuel ne sera jamais modifié. Il remplace le document XML original par un document ne contenant que des éléments « a » sans contenu textuel. (Réponse correcte!) Effectivement. Le nom des éléments originaux est donné par la valeur de l'attribut « valeur ». Il donne le document XML original. (Réponse incorrecte!) Absolument pas : il n'y a plus que des éléments « a ». Question 15 . Que signifie XSL? Choisissez la bonne réponse parmi les suivantes. eXtensible Stylesheet Language (Réponse correcte!) Effectivement. eXtensible Style Language (Réponse incorrecte!) Non. eXtensible Style Laboratory (Réponse incorrecte!) Non. Question 16 . Comment fait-on appel à un fichier XSLT? Choisissez la bonne réponse parmi les suivantes. \u0026lt;stylesheet type=\"text/xsl\" href=\"mystyle.xsl\" /\u0026gt; (Réponse incorrecte!) Non. \u0026lt;?xml-stylesheet type=\"text/xsl\" href=\"mystyle.xsl\" ?\u0026gt; (Réponse correcte!) Effectivement. \u0026lt;link type=\"text/xsl\" href=\"mystyle.xsl\" /\u0026gt; (Réponse incorrecte!) Non. Question 17 . Le XSLT transforme les documents XML en d'autres documents XML. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Non. Le XSLT n'a pas à produire du XML. On peut déclarer que l'on souhaite produire du texte avec une telle instruction : \u0026lt;xslt:output method=\"text\" omit-xml-declaration=\"yes\" /\u0026gt;. Faux (Réponse correcte!) Effectivement. Question 18 . Le XSLT ne s'applique qu'à des fichiers XML valide. Choisissez la bonne réponse parmi les suivantes. Vrai (Réponse incorrecte!) Non. Il suffit que le fichier XML soit bien formé. Faux (Réponse correcte!) Effectivement. Question 19 . Étant donné le fichier XML suivant. \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;addresses\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/addresses\u0026gt; Quel sera le résultat de la transformation XSLT suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:variable name=\"var\" select=\"/addresses/vendeur[prenom='Jean']\"/\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:value-of select=\"$var\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien du tout (Réponse incorrecte!) Non. Jean (Réponse incorrecte!) La variable sélectionne plutôt l'élément vendeur. \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; (Réponse incorrecte!) Il s'agit bien du contenu de la variable, mais l'instruction value-of va extraire le contenu du texte. Jean Coutu (Réponse correcte!) Correct. Question 20 . Étant donné le fichier XML suivant. \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;addresses\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/addresses\u0026gt; Quel sera le résultat de la transformation XSLT suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:variable name=\"var\" select=\"/addresses/vendeur[prenom='Jean']\"/\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:copy-of select=\"$var\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien du tout (Réponse incorrecte!) Non. Jean (Réponse incorrecte!) La variable sélectionne plutôt l'élément vendeur. Jean Coutu (Réponse incorrecte!) Non, ce n'est pas l'effet de l'instruction copy-of. \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; (Réponse correcte!) Effectivement, l'instruction copy-of donne une copie intégrale du contenu de la variable. Question 21 . Étant donné le fichier XML suivant. \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;addresses\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Marie\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Vanasse\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/addresses\u0026gt; Quel sera le résultat de la transformation XSLT suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:value-of select=\"//vendeur\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien du tout (Réponse incorrecte!) Non. Jean Coutu Marie Vanasse Pierre Coutu (Réponse incorrecte!) Ce n'est pas l'effet de l'instruction value-of. Jean Coutu (Réponse correcte!) Effectivement, seul le contenu textuel du premier élément vendeur sera donné. Question 22 . Étant donné le fichier XML suivant. \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;addresses\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Marie\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Vanasse\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/addresses\u0026gt; Quel sera le résultat de la transformation XSLT suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:value-of select=\"//vendeur[preceding::vendeur/nom=nom]\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien du tout (Réponse incorrecte!) Non. Jean Coutu (Réponse incorrecte!) Non, seul le dernier élément vendeur est sélectionné, car lui seul est précédé par un élément vendeur ayant un sous-élément nom de même valeur. Pierre Coutu (Réponse correcte!) Effectivement, seul le dernier élément vendeur est sélectionné. Question 23 . Étant donné le fichier XML suivant. \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;addresses\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Marie\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Vanasse\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Pierre\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; \u0026lt;/addresses\u0026gt; Quel sera le résultat de la transformation XSLT suivante? \u0026lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u0026gt; \u0026lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\u0026gt; \u0026lt;xsl:template match=\"/\"\u0026gt; \u0026lt;xsl:copy-of select=\"//vendeur[not(preceding::vendeur/nom=nom)]\"/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Choisissez la bonne réponse parmi les suivantes. Rien du tout (Réponse incorrecte!) Non. \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; (Réponse incorrecte!) Non, le deuxième élément est aussi sélectionné. \u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Coutu\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt;\u0026lt;vendeur\u0026gt; \u0026lt;prenom\u0026gt;Marie\u0026lt;/prenom\u0026gt; \u0026lt;nom\u0026gt;Vanasse\u0026lt;/nom\u0026gt; \u0026lt;/vendeur\u0026gt; (Réponse correcte!) Effectivement, le dernier élément n'est pas sélectionné. Question 24 . Que vaut l'expression « //a[1]=current() »? Choisissez la bonne réponse parmi les suivantes. Vrai si le nœud courant est le premier élément a rencontré, faux autrement. (Réponse incorrecte!) Non. L'égalité compare plutôt le contenu des éléments, pas la position dans le document. Vrai si le nœud courant est le premier élément a rencontré au sein d'un même élément, faux autrement. (Réponse incorrecte!) Non. L'égalité compare plutôt le contenu des éléments, pas la position au sein d'un élément. Aucune de ces réponses. (Réponse correcte!) Effectivement, l'expression n'a la valeur vraie que si l'élément courant est un élément « a » ayant le même contenu que le premier élément « a » dans le document. "},{"id":122,"href":"/orientee_donnees/docs/modules/b_module_xml/travail/","title":"Travail noté","section":"Module XML","content":" Travail noté # Question 1 : Application Java pour le traitement XML # Vous développerez une application Java complète pour traiter et analyser des documents XML. Pour démontrer l\u0026rsquo;utilité de votre travail, vous utiliserez le fichier XML suivant comme base de données :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;bibliotheque xmlns=\u0026#34;http://www.example.com/biblio\u0026#34;\u0026gt; \u0026lt;livre id=\u0026#34;1\u0026#34; categorie=\u0026#34;roman\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Le Petit Prince\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Antoine de Saint-Exupéry\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1943\u0026lt;/annee\u0026gt; \u0026lt;prix\u0026gt;15.99\u0026lt;/prix\u0026gt; \u0026lt;stock\u0026gt;25\u0026lt;/stock\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre id=\u0026#34;2\u0026#34; categorie=\u0026#34;science-fiction\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Dune\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Frank Herbert\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1965\u0026lt;/annee\u0026gt; \u0026lt;prix\u0026gt;22.50\u0026lt;/prix\u0026gt; \u0026lt;stock\u0026gt;18\u0026lt;/stock\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre id=\u0026#34;3\u0026#34; categorie=\u0026#34;roman\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;1984\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;George Orwell\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1949\u0026lt;/annee\u0026gt; \u0026lt;prix\u0026gt;18.75\u0026lt;/prix\u0026gt; \u0026lt;stock\u0026gt;12\u0026lt;/stock\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre id=\u0026#34;4\u0026#34; categorie=\u0026#34;biographie\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Steve Jobs\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;Walter Isaacson\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;2011\u0026lt;/annee\u0026gt; \u0026lt;prix\u0026gt;28.99\u0026lt;/prix\u0026gt; \u0026lt;stock\u0026gt;8\u0026lt;/stock\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;livre id=\u0026#34;5\u0026#34; categorie=\u0026#34;science-fiction\u0026#34;\u0026gt; \u0026lt;titre\u0026gt;Neuromancer\u0026lt;/titre\u0026gt; \u0026lt;auteur\u0026gt;William Gibson\u0026lt;/auteur\u0026gt; \u0026lt;annee\u0026gt;1984\u0026lt;/annee\u0026gt; \u0026lt;prix\u0026gt;19.99\u0026lt;/prix\u0026gt; \u0026lt;stock\u0026gt;15\u0026lt;/stock\u0026gt; \u0026lt;/livre\u0026gt; \u0026lt;/bibliotheque\u0026gt; Votre application devra implémenter les fonctionnalités suivantes :\nCharger le fichier XML fourni et afficher le nombre total de livres. Utiliser XPath pour extraire et afficher tous les titres de livres de catégorie \u0026ldquo;roman\u0026rdquo;. Calculer et afficher des statistiques : nombre total de livres, valeur totale du stock (prix × stock), moyenne des prix. Valider le document XML par rapport à une DTD simple que vous créerez. Votre application devra pouvoir charger ce fichier, effectuer les opérations demandées, et produire des résultats cohérents.\nLivrables : Code source Java, fichier XML d\u0026rsquo;exemple, DTD, et un README en Markdown expliquant comment exécuter le projet.\nQuestion 2 : Conversion et traitement de données avec Jackson # Dans ce troisième travail, vous utiliserez la bibliothèque Jackson pour créer une application Java capable de convertir et traiter des données entre les formats JSON et XML. Vous développerez un système de gestion d\u0026rsquo;inventaire de produits qui peut importer des données depuis des fichiers JSON ou XML, effectuer des opérations de traitement, et exporter les résultats dans les deux formats.\nPour votre projet, vous travaillerez avec les données JSON suivantes représentant un inventaire de produits :\n{ \u0026#34;inventaire\u0026#34;: { \u0026#34;produits\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;P001\u0026#34;, \u0026#34;nom\u0026#34;: \u0026#34;Ordinateur portable\u0026#34;, \u0026#34;categorie\u0026#34;: \u0026#34;Informatique\u0026#34;, \u0026#34;prix\u0026#34;: 1299.99, \u0026#34;stock\u0026#34;: 15, \u0026#34;fournisseur\u0026#34;: { \u0026#34;nom\u0026#34;: \u0026#34;TechCorp\u0026#34;, \u0026#34;pays\u0026#34;: \u0026#34;Canada\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;P002\u0026#34;, \u0026#34;nom\u0026#34;: \u0026#34;Smartphone\u0026#34;, \u0026#34;categorie\u0026#34;: \u0026#34;Téléphonie\u0026#34;, \u0026#34;prix\u0026#34;: 899.99, \u0026#34;stock\u0026#34;: 25, \u0026#34;fournisseur\u0026#34;: { \u0026#34;nom\u0026#34;: \u0026#34;MobilePlus\u0026#34;, \u0026#34;pays\u0026#34;: \u0026#34;États-Unis\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;P003\u0026#34;, \u0026#34;nom\u0026#34;: \u0026#34;Casque audio\u0026#34;, \u0026#34;categorie\u0026#34;: \u0026#34;Audio\u0026#34;, \u0026#34;prix\u0026#34;: 199.99, \u0026#34;stock\u0026#34;: 50, \u0026#34;fournisseur\u0026#34;: { \u0026#34;nom\u0026#34;: \u0026#34;SoundTech\u0026#34;, \u0026#34;pays\u0026#34;: \u0026#34;Chine\u0026#34; } } ], \u0026#34;derniere_mise_a_jour\u0026#34;: \u0026#34;2025-12-29\u0026#34; } } Votre application devra impérativement implémenter les fonctionnalités suivantes :\nCharger les données depuis un fichier JSON et les convertir en objets Java structurés. Convertir les données Java en format XML et sauvegarder dans un fichier \u0026ldquo;inventaire.xml\u0026rdquo;. Charger les données depuis le fichier XML généré et les reconvertir en objets Java. Générer un rapport JSON final avec les statistiques complètes de l\u0026rsquo;inventaire. Ressources : Consultez la documentation officielle de Jackson : https://github.com/FasterXML/jackson\nLivrables : Code source Java avec Maven, fichiers JSON et XML d\u0026rsquo;exemple, résultats des conversions, et un README en Markdown détaillant l\u0026rsquo;architecture et l\u0026rsquo;utilisation de l\u0026rsquo;application.\nQuestion 3 : Exécuteur SPARQL avec Apache Jena # Dans ce quatrième travail, vous utiliserez l\u0026rsquo;exécuteur SPARQL du projet JavaRDF disponible sur GitHub (https://github.com/lemire/javardf). Voici un exemple de données RDF/XML que vous utiliserez (plus riche que l\u0026rsquo;exemple du projet de base) :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;rdf:RDF xmlns:rdf=\u0026#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#\u0026#34; xmlns:dc=\u0026#34;http://purl.org/dc/elements/1.1/\u0026#34; xmlns:foaf=\u0026#34;http://xmlns.com/foaf/0.1/\u0026#34; xmlns:bib=\u0026#34;http://example.org/bib/\u0026#34;\u0026gt; \u0026lt;bib:Article rdf:about=\u0026#34;http://example.org/article1\u0026#34;\u0026gt; \u0026lt;dc:title\u0026gt;Traitement automatique des données XML\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator rdf:resource=\u0026#34;http://example.org/author1\u0026#34;/\u0026gt; \u0026lt;dc:creator rdf:resource=\u0026#34;http://example.org/author2\u0026#34;/\u0026gt; \u0026lt;bib:publishedIn\u0026gt;Journal of Data Processing\u0026lt;/bib:publishedIn\u0026gt; \u0026lt;bib:year\u0026gt;2024\u0026lt;/bib:year\u0026gt; \u0026lt;bib:cites rdf:resource=\u0026#34;http://example.org/article2\u0026#34;/\u0026gt; \u0026lt;/bib:Article\u0026gt; \u0026lt;bib:Article rdf:about=\u0026#34;http://example.org/article2\u0026#34;\u0026gt; \u0026lt;dc:title\u0026gt;Introduction aux bases de données\u0026lt;/dc:title\u0026gt; \u0026lt;dc:creator rdf:resource=\u0026#34;http://example.org/author1\u0026#34;/\u0026gt; \u0026lt;bib:publishedIn\u0026gt;Database Journal\u0026lt;/bib:publishedIn\u0026gt; \u0026lt;bib:year\u0026gt;2023\u0026lt;/bib:year\u0026gt; \u0026lt;/bib:Article\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/author1\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Marie Dupont\u0026lt;/foaf:name\u0026gt; \u0026lt;foaf:affiliation rdf:resource=\u0026#34;http://example.org/univ1\u0026#34;/\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;foaf:Person rdf:about=\u0026#34;http://example.org/author2\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Jean Martin\u0026lt;/foaf:name\u0026gt; \u0026lt;foaf:affiliation rdf:resource=\u0026#34;http://example.org/univ1\u0026#34;/\u0026gt; \u0026lt;/foaf:Person\u0026gt; \u0026lt;foaf:Organization rdf:about=\u0026#34;http://example.org/univ1\u0026#34;\u0026gt; \u0026lt;foaf:name\u0026gt;Université de Montréal\u0026lt;/foaf:name\u0026gt; \u0026lt;/foaf:Organization\u0026gt; \u0026lt;/rdf:RDF\u0026gt; Composer et exécuter trois requêtes SPARQL spécifiques :\nRequête 1 : Lister tous les articles écrits par un auteur spécifique (par exemple, Marie Dupont), avec leur titre et année de publication. Requête 2 : Trouver tous les co-auteurs d\u0026rsquo;un chercheur donné et compter le nombre d\u0026rsquo;articles écrits en collaboration. Requête 3 : Calculer des statistiques sur les publications : nombre total d\u0026rsquo;articles, nombre d\u0026rsquo;auteurs distincts, et articles les plus cités. Livrables : Les requêtes et vos explications.\n"},{"id":123,"href":"/orientee_donnees/docs/modules/c_module_xslt/travail/","title":"Travail noté","section":"Module XPath, XSLT, XQuery","content":" Travail noté # Question 1 : Transformations XSLT pour la génération de rapports # Pour ce travail, vous utiliserez le document XML suivant contenant des données d\u0026rsquo;étudiants :\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;universite\u0026gt; \u0026lt;etudiant id=\u0026#34;E001\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Dupont\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Marie\u0026lt;/prenom\u0026gt; \u0026lt;programme\u0026gt;Informatique\u0026lt;/programme\u0026gt; \u0026lt;notes\u0026gt; \u0026lt;note cours=\u0026#34;INF6450\u0026#34; valeur=\u0026#34;85\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;INF6400\u0026#34; valeur=\u0026#34;92\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;INF6500\u0026#34; valeur=\u0026#34;78\u0026#34; /\u0026gt; \u0026lt;/notes\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant id=\u0026#34;E002\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Tremblay\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Jean\u0026lt;/prenom\u0026gt; \u0026lt;programme\u0026gt;Mathématiques\u0026lt;/programme\u0026gt; \u0026lt;notes\u0026gt; \u0026lt;note cours=\u0026#34;MAT6450\u0026#34; valeur=\u0026#34;88\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;MAT6400\u0026#34; valeur=\u0026#34;76\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;MAT6500\u0026#34; valeur=\u0026#34;91\u0026#34; /\u0026gt; \u0026lt;/notes\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant id=\u0026#34;E003\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Gagnon\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Sophie\u0026lt;/prenom\u0026gt; \u0026lt;programme\u0026gt;Informatique\u0026lt;/programme\u0026gt; \u0026lt;notes\u0026gt; \u0026lt;note cours=\u0026#34;INF6450\u0026#34; valeur=\u0026#34;79\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;INF6400\u0026#34; valeur=\u0026#34;88\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;INF6500\u0026#34; valeur=\u0026#34;94\u0026#34; /\u0026gt; \u0026lt;/notes\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;etudiant id=\u0026#34;E004\u0026#34;\u0026gt; \u0026lt;nom\u0026gt;Roy\u0026lt;/nom\u0026gt; \u0026lt;prenom\u0026gt;Michel\u0026lt;/prenom\u0026gt; \u0026lt;programme\u0026gt;Physique\u0026lt;/programme\u0026gt; \u0026lt;notes\u0026gt; \u0026lt;note cours=\u0026#34;PHY6450\u0026#34; valeur=\u0026#34;82\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;PHY6400\u0026#34; valeur=\u0026#34;89\u0026#34; /\u0026gt; \u0026lt;note cours=\u0026#34;PHY6500\u0026#34; valeur=\u0026#34;85\u0026#34; /\u0026gt; \u0026lt;/notes\u0026gt; \u0026lt;/etudiant\u0026gt; \u0026lt;/universite\u0026gt; Créer une feuille XSLT qui transforme le XML en format JSON, avec une structure contenant la liste des étudiants et leurs informations, y compris un calcul de la moyenne pour chaque étudiant.\nVous devrez tester vos transformations avec un processeur XSLT (comme Saxon ou xsltproc) et fournir les résultats de sortie pour validation.\nRessources : Consultez la documentation officielle de XSLT : https://www.w3.org/TR/xslt-30/\nLivrables : Feuilles XSLT (.xslt), fichier XML d\u0026rsquo;exemple, résultats des transformations, et un README en Markdown expliquant les transformations et comment les exécuter.\nQuestion 2 : Requêtes XPath pour l\u0026rsquo;extraction de données # Utilisez le même document XML des étudiants que dans la Question 1 pour pratiquer les expressions XPath.\nTâches à effectuer :\nÉcrivez des expressions XPath pour extraire les informations suivantes :\nTous les noms d\u0026rsquo;étudiants en Informatique Les notes supérieures à 85 pour tous les cours L\u0026rsquo;étudiant avec la meilleure moyenne générale Les cours distincts offerts dans l\u0026rsquo;université Expressions XPath avancées :\nUtilisez des prédicats complexes pour filtrer les données Combinez plusieurs conditions avec les opérateurs and et or Utilisez les fonctions XPath (count, sum, avg, etc.) Naviguez dans la hiérarchie XML avec des chemins absolus et relatifs Validation des résultats :\nTestez vos expressions XPath avec un outil en ligne ou un processeur XML Fournissez les résultats attendus pour chaque expression Expliquez le fonctionnement de chaque expression XPath Ressources :\nSpécification XPath : https://www.w3.org/TR/xpath-31/ Tutoriel XPath : https://www.w3schools.com/xml/xpath_intro.asp Livrables : Liste des expressions XPath, résultats des requêtes, et explication du fonctionnement.\nQuestion 3 : Requêtes XQuery pour l\u0026rsquo;analyse de données # Utilisez le document XML des étudiants pour créer des requêtes XQuery qui effectuent des analyses complexes.\nTâches à effectuer :\nRequêtes XQuery de base :\nLister tous les étudiants avec leurs moyennes calculées Grouper les étudiants par programme d\u0026rsquo;études Trier les étudiants par moyenne décroissante Analyses statistiques :\nCalculer la moyenne générale par programme Identifier les cours avec les meilleures et pires performances Générer un rapport des statistiques par matière Transformations XQuery :\nCréer du HTML à partir des données XML Générer du JSON structuré avec les analyses Construire des rapports XML complexes Requêtes avancées :\nUtiliser FLWOR expressions pour des analyses complexes Implémenter des jointures et des agrégations Gérer les données manquantes et les erreurs Exemple de requête XQuery attendue :\nfor $etudiant in //etudiant let $moyenne := avg($etudiant/notes/note/@valeur) order by $moyenne descending return \u0026lt;resultat\u0026gt; \u0026lt;nom\u0026gt;{concat($etudiant/prenom, \u0026#39; \u0026#39;, $etudiant/nom)}\u0026lt;/nom\u0026gt; \u0026lt;programme\u0026gt;{$etudiant/programme}\u0026lt;/programme\u0026gt; \u0026lt;moyenne\u0026gt;{$moyenne}\u0026lt;/moyenne\u0026gt; \u0026lt;/resultat\u0026gt; Ressources :\nSpécification XQuery : https://www.w3.org/TR/xquery-31/ Tutoriel XQuery : https://www.w3schools.com/xml/xquery_intro.asp Livrables : Requêtes XQuery (.xq), résultats des analyses, et documentation des fonctionnalités utilisées.\n"}]